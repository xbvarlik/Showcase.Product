"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_XRTNIFND_exports = {};
__export(chunk_XRTNIFND_exports, {
  require_commonjs: () => require_commonjs
});
module.exports = __toCommonJS(chunk_XRTNIFND_exports);
var import_chunk_WWAWV7DQ = require("./chunk-WWAWV7DQ.js");
var require_commonjs = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/lru-cache@10.2.0/node_modules/lru-cache/dist/commonjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LRUCache = void 0;
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var warned = /* @__PURE__ */ new Set();
    var PROCESS = typeof process === "object" && !!process ? process : {};
    var emitWarning = (msg, type, code, fn) => {
      typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
    };
    var AC = globalThis.AbortController;
    var AS = globalThis.AbortSignal;
    if (typeof AC === "undefined") {
      AS = class AbortSignal {
        constructor() {
          (0, import_chunk_WWAWV7DQ.__publicField)(this, "onabort");
          (0, import_chunk_WWAWV7DQ.__publicField)(this, "_onabort", []);
          (0, import_chunk_WWAWV7DQ.__publicField)(this, "reason");
          (0, import_chunk_WWAWV7DQ.__publicField)(this, "aborted", false);
        }
        addEventListener(_, fn) {
          this._onabort.push(fn);
        }
      };
      AC = class AbortController {
        constructor() {
          (0, import_chunk_WWAWV7DQ.__publicField)(this, "signal", new AS());
          warnACPolyfill();
        }
        abort(reason) {
          if (this.signal.aborted)
            return;
          this.signal.reason = reason;
          this.signal.aborted = true;
          for (const fn of this.signal._onabort) {
            fn(reason);
          }
          this.signal.onabort?.(reason);
        }
      };
      let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
      const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
          return;
        printACPolyfillWarning = false;
        emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
      };
    }
    var shouldWarn = (code) => !warned.has(code);
    var TYPE = Symbol("type");
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var _constructing;
    var _Stack = class _Stack2 {
      constructor(max, HeapCls) {
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "heap");
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "length");
        if (!(0, import_chunk_WWAWV7DQ.__privateGet)(_Stack2, _constructing)) {
          throw new TypeError("instantiate Stack using Stack.create(n)");
        }
        this.heap = new HeapCls(max);
        this.length = 0;
      }
      static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
          return [];
        (0, import_chunk_WWAWV7DQ.__privateSet)(_Stack2, _constructing, true);
        const s = new _Stack2(max, HeapCls);
        (0, import_chunk_WWAWV7DQ.__privateSet)(_Stack2, _constructing, false);
        return s;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    _constructing = /* @__PURE__ */ new WeakMap();
    (0, import_chunk_WWAWV7DQ.__privateAdd)(_Stack, _constructing, false);
    var Stack = _Stack;
    var _a, _b, _max, _maxSize, _dispose, _disposeAfter, _fetchMethod, _size, _calculatedSize, _keyMap, _keyList, _valList, _next, _prev, _head, _tail, _free, _disposed, _sizes, _starts, _ttls, _hasDispose, _hasFetchMethod, _hasDisposeAfter, _LRUCache_instances, initializeTTLTracking_fn, _updateItemAge, _statusTTL, _setItemTTL, _isStale, initializeSizeTracking_fn, _removeItemSize, _addItemSize, _requireSize, indexes_fn, rindexes_fn, isValidIndex_fn, evict_fn, backgroundFetch_fn, isBackgroundFetch_fn, connect_fn, moveToTail_fn;
    var _LRUCache = class _LRUCache2 {
      constructor(options) {
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _LRUCache_instances);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _max);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _maxSize);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _dispose);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _disposeAfter);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _fetchMethod);
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "ttl");
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "ttlResolution");
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "ttlAutopurge");
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "updateAgeOnGet");
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "updateAgeOnHas");
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "allowStale");
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "noDisposeOnSet");
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "noUpdateTTL");
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "maxEntrySize");
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "sizeCalculation");
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "noDeleteOnFetchRejection");
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "noDeleteOnStaleGet");
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "allowStaleOnFetchAbort");
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "allowStaleOnFetchRejection");
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "ignoreFetchAbort");
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _size);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _calculatedSize);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _keyMap);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _keyList);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _valList);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _next);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _prev);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _head);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _tail);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _free);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _disposed);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _sizes);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _starts);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _ttls);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _hasDispose);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _hasFetchMethod);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _hasDisposeAfter);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _updateItemAge, () => {
        });
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _statusTTL, () => {
        });
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _setItemTTL, () => {
        });
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _isStale, () => false);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _removeItemSize, (_i) => {
        });
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _addItemSize, (_i, _s, _st) => {
        });
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _requireSize, (_k, _v, size, sizeCalculation2) => {
          if (size || sizeCalculation2) {
            throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
          }
          return 0;
        });
        (0, import_chunk_WWAWV7DQ.__publicField)(this, _a, "LRUCache");
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _max, max);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _maxSize, maxSize);
        this.maxEntrySize = maxEntrySize || (0, import_chunk_WWAWV7DQ.__privateGet)(this, _maxSize);
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
          if (!(0, import_chunk_WWAWV7DQ.__privateGet)(this, _maxSize) && !this.maxEntrySize) {
            throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
          throw new TypeError("fetchMethod must be a function if specified");
        }
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _fetchMethod, fetchMethod);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _hasFetchMethod, !!fetchMethod);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _keyMap, /* @__PURE__ */ new Map());
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _keyList, new Array(max).fill(void 0));
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _valList, new Array(max).fill(void 0));
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _next, new UintArray(max));
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _prev, new UintArray(max));
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _head, 0);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _tail, 0);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _free, Stack.create(max));
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _size, 0);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _calculatedSize, 0);
        if (typeof dispose === "function") {
          (0, import_chunk_WWAWV7DQ.__privateSet)(this, _dispose, dispose);
        }
        if (typeof disposeAfter === "function") {
          (0, import_chunk_WWAWV7DQ.__privateSet)(this, _disposeAfter, disposeAfter);
          (0, import_chunk_WWAWV7DQ.__privateSet)(this, _disposed, []);
        } else {
          (0, import_chunk_WWAWV7DQ.__privateSet)(this, _disposeAfter, void 0);
          (0, import_chunk_WWAWV7DQ.__privateSet)(this, _disposed, void 0);
        }
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _hasDispose, !!(0, import_chunk_WWAWV7DQ.__privateGet)(this, _dispose));
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _hasDisposeAfter, !!(0, import_chunk_WWAWV7DQ.__privateGet)(this, _disposeAfter));
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _maxSize) !== 0) {
            if (!isPosInt((0, import_chunk_WWAWV7DQ.__privateGet)(this, _maxSize))) {
              throw new TypeError("maxSize must be a positive integer if specified");
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError("maxEntrySize must be a positive integer if specified");
          }
          (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, initializeSizeTracking_fn).call(this);
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError("ttl must be a positive integer if specified");
          }
          (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, initializeTTLTracking_fn).call(this);
        }
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _max) === 0 && this.ttl === 0 && (0, import_chunk_WWAWV7DQ.__privateGet)(this, _maxSize) === 0) {
          throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !(0, import_chunk_WWAWV7DQ.__privateGet)(this, _max) && !(0, import_chunk_WWAWV7DQ.__privateGet)(this, _maxSize)) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache2);
          }
        }
      }
      /**
       * Do not call this method unless you need to inspect the
       * inner workings of the cache.  If anything returned by this
       * object is modified in any way, strange breakage may occur.
       *
       * These fields are private for a reason!
       *
       * @internal
       */
      static unsafeExposeInternals(c) {
        return {
          // properties
          starts: (0, import_chunk_WWAWV7DQ.__privateGet)(c, _starts),
          ttls: (0, import_chunk_WWAWV7DQ.__privateGet)(c, _ttls),
          sizes: (0, import_chunk_WWAWV7DQ.__privateGet)(c, _sizes),
          keyMap: (0, import_chunk_WWAWV7DQ.__privateGet)(c, _keyMap),
          keyList: (0, import_chunk_WWAWV7DQ.__privateGet)(c, _keyList),
          valList: (0, import_chunk_WWAWV7DQ.__privateGet)(c, _valList),
          next: (0, import_chunk_WWAWV7DQ.__privateGet)(c, _next),
          prev: (0, import_chunk_WWAWV7DQ.__privateGet)(c, _prev),
          get head() {
            return (0, import_chunk_WWAWV7DQ.__privateGet)(c, _head);
          },
          get tail() {
            return (0, import_chunk_WWAWV7DQ.__privateGet)(c, _tail);
          },
          free: (0, import_chunk_WWAWV7DQ.__privateGet)(c, _free),
          // methods
          isBackgroundFetch: (p) => {
            var _a2;
            return (0, import_chunk_WWAWV7DQ.__privateMethod)(_a2 = c, _LRUCache_instances, isBackgroundFetch_fn).call(_a2, p);
          },
          backgroundFetch: (k, index, options, context) => {
            var _a2;
            return (0, import_chunk_WWAWV7DQ.__privateMethod)(_a2 = c, _LRUCache_instances, backgroundFetch_fn).call(_a2, k, index, options, context);
          },
          moveToTail: (index) => {
            var _a2;
            return (0, import_chunk_WWAWV7DQ.__privateMethod)(_a2 = c, _LRUCache_instances, moveToTail_fn).call(_a2, index);
          },
          indexes: (options) => {
            var _a2;
            return (0, import_chunk_WWAWV7DQ.__privateMethod)(_a2 = c, _LRUCache_instances, indexes_fn).call(_a2, options);
          },
          rindexes: (options) => {
            var _a2;
            return (0, import_chunk_WWAWV7DQ.__privateMethod)(_a2 = c, _LRUCache_instances, rindexes_fn).call(_a2, options);
          },
          isStale: (index) => {
            var _a2;
            return (0, import_chunk_WWAWV7DQ.__privateGet)(_a2 = c, _isStale).call(_a2, index);
          }
        };
      }
      // Protected read-only members
      /**
       * {@link LRUCache.OptionsBase.max} (read-only)
       */
      get max() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _max);
      }
      /**
       * {@link LRUCache.OptionsBase.maxSize} (read-only)
       */
      get maxSize() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _maxSize);
      }
      /**
       * The total computed size of items in the cache (read-only)
       */
      get calculatedSize() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _calculatedSize);
      }
      /**
       * The number of items stored in the cache (read-only)
       */
      get size() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _size);
      }
      /**
       * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
       */
      get fetchMethod() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _fetchMethod);
      }
      /**
       * {@link LRUCache.OptionsBase.dispose} (read-only)
       */
      get dispose() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _dispose);
      }
      /**
       * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
       */
      get disposeAfter() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _disposeAfter);
      }
      /**
       * Return the remaining TTL time for a given entry key
       */
      getRemainingTTL(key) {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyMap).has(key) ? Infinity : 0;
      }
      /**
       * Return a generator yielding `[key, value]` pairs,
       * in order from most recently used to least recently used.
       */
      *entries() {
        for (const i of (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, indexes_fn).call(this)) {
          if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[i] !== void 0 && (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyList)[i] !== void 0 && !(0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[i])) {
            yield [(0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyList)[i], (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[i]];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.entries}
       *
       * Return a generator yielding `[key, value]` pairs,
       * in order from least recently used to most recently used.
       */
      *rentries() {
        for (const i of (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, rindexes_fn).call(this)) {
          if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[i] !== void 0 && (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyList)[i] !== void 0 && !(0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[i])) {
            yield [(0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyList)[i], (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[i]];
          }
        }
      }
      /**
       * Return a generator yielding the keys in the cache,
       * in order from most recently used to least recently used.
       */
      *keys() {
        for (const i of (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, indexes_fn).call(this)) {
          const k = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyList)[i];
          if (k !== void 0 && !(0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[i])) {
            yield k;
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.keys}
       *
       * Return a generator yielding the keys in the cache,
       * in order from least recently used to most recently used.
       */
      *rkeys() {
        for (const i of (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, rindexes_fn).call(this)) {
          const k = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyList)[i];
          if (k !== void 0 && !(0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[i])) {
            yield k;
          }
        }
      }
      /**
       * Return a generator yielding the values in the cache,
       * in order from most recently used to least recently used.
       */
      *values() {
        for (const i of (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, indexes_fn).call(this)) {
          const v = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[i];
          if (v !== void 0 && !(0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[i])) {
            yield (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[i];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.values}
       *
       * Return a generator yielding the values in the cache,
       * in order from least recently used to most recently used.
       */
      *rvalues() {
        for (const i of (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, rindexes_fn).call(this)) {
          const v = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[i];
          if (v !== void 0 && !(0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[i])) {
            yield (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[i];
          }
        }
      }
      /**
       * Iterating over the cache itself yields the same results as
       * {@link LRUCache.entries}
       */
      [(_b = Symbol.iterator, _a = Symbol.toStringTag, _b)]() {
        return this.entries();
      }
      /**
       * Find a value for which the supplied fn method returns a truthy value,
       * similar to Array.find().  fn is called as fn(value, key, cache).
       */
      find(fn, getOptions = {}) {
        for (const i of (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, indexes_fn).call(this)) {
          const v = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[i];
          const value = (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          if (fn(value, (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyList)[i], this)) {
            return this.get((0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyList)[i], getOptions);
          }
        }
      }
      /**
       * Call the supplied function on each item in the cache, in order from
       * most recently used to least recently used.  fn is called as
       * fn(value, key, cache).  Does not update age or recenty of use.
       * Does not iterate over stale values.
       */
      forEach(fn, thisp = this) {
        for (const i of (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, indexes_fn).call(this)) {
          const v = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[i];
          const value = (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyList)[i], this);
        }
      }
      /**
       * The same as {@link LRUCache.forEach} but items are iterated over in
       * reverse order.  (ie, less recently used items are iterated over first.)
       */
      rforEach(fn, thisp = this) {
        for (const i of (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, rindexes_fn).call(this)) {
          const v = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[i];
          const value = (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyList)[i], this);
        }
      }
      /**
       * Delete any stale entries. Returns true if anything was removed,
       * false otherwise.
       */
      purgeStale() {
        let deleted = false;
        for (const i of (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: true })) {
          if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _isStale).call(this, i)) {
            this.delete((0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyList)[i]);
            deleted = true;
          }
        }
        return deleted;
      }
      /**
       * Get the extended info about a given entry, to get its value, size, and
       * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a
       * single key. Always returns stale values, if their info is found in the
       * cache, so be sure to check for expired TTLs if relevant.
       */
      info(key) {
        const i = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyMap).get(key);
        if (i === void 0)
          return void 0;
        const v = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[i];
        const value = (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          return void 0;
        const entry = { value };
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _ttls) && (0, import_chunk_WWAWV7DQ.__privateGet)(this, _starts)) {
          const ttl = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _ttls)[i];
          const start = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _starts)[i];
          if (ttl && start) {
            const remain = ttl - (perf.now() - start);
            entry.ttl = remain;
            entry.start = Date.now();
          }
        }
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _sizes)) {
          entry.size = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _sizes)[i];
        }
        return entry;
      }
      /**
       * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
       * passed to cache.load()
       */
      dump() {
        const arr = [];
        for (const i of (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, indexes_fn).call(this, { allowStale: true })) {
          const key = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyList)[i];
          const v = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[i];
          const value = (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0 || key === void 0)
            continue;
          const entry = { value };
          if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _ttls) && (0, import_chunk_WWAWV7DQ.__privateGet)(this, _starts)) {
            entry.ttl = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _ttls)[i];
            const age = perf.now() - (0, import_chunk_WWAWV7DQ.__privateGet)(this, _starts)[i];
            entry.start = Math.floor(Date.now() - age);
          }
          if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _sizes)) {
            entry.size = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _sizes)[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      /**
       * Reset the cache and load in the items in entries in the order listed.
       * Note that the shape of the resulting cache may be different if the
       * same options are not used in both caches.
       */
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      /**
       * Add a value to the cache.
       *
       * Note: if `undefined` is specified as a value, this is an alias for
       * {@link LRUCache#delete}
       */
      set(k, v, setOptions = {}) {
        var _a2, _b2, _c;
        if (v === void 0) {
          this.delete(k);
          return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _requireSize).call(this, k, v, setOptions.size || 0, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          if (status) {
            status.set = "miss";
            status.maxEntrySizeExceeded = true;
          }
          this.delete(k);
          return this;
        }
        let index = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _size) === 0 ? void 0 : (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyMap).get(k);
        if (index === void 0) {
          index = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _size) === 0 ? (0, import_chunk_WWAWV7DQ.__privateGet)(this, _tail) : (0, import_chunk_WWAWV7DQ.__privateGet)(this, _free).length !== 0 ? (0, import_chunk_WWAWV7DQ.__privateGet)(this, _free).pop() : (0, import_chunk_WWAWV7DQ.__privateGet)(this, _size) === (0, import_chunk_WWAWV7DQ.__privateGet)(this, _max) ? (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, evict_fn).call(this, false) : (0, import_chunk_WWAWV7DQ.__privateGet)(this, _size);
          (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyList)[index] = k;
          (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[index] = v;
          (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyMap).set(k, index);
          (0, import_chunk_WWAWV7DQ.__privateGet)(this, _next)[(0, import_chunk_WWAWV7DQ.__privateGet)(this, _tail)] = index;
          (0, import_chunk_WWAWV7DQ.__privateGet)(this, _prev)[index] = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _tail);
          (0, import_chunk_WWAWV7DQ.__privateSet)(this, _tail, index);
          (0, import_chunk_WWAWV7DQ.__privateWrapper)(this, _size)._++;
          (0, import_chunk_WWAWV7DQ.__privateGet)(this, _addItemSize).call(this, index, size, status);
          if (status)
            status.set = "add";
          noUpdateTTL = false;
        } else {
          (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, moveToTail_fn).call(this, index);
          const oldVal = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[index];
          if (v !== oldVal) {
            if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _hasFetchMethod) && (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
              const { __staleWhileFetching: s } = oldVal;
              if (s !== void 0 && !noDisposeOnSet) {
                if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _hasDispose)) {
                  (_a2 = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _dispose)) == null ? void 0 : _a2.call(this, s, k, "set");
                }
                if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _hasDisposeAfter)) {
                  (0, import_chunk_WWAWV7DQ.__privateGet)(this, _disposed)?.push([s, k, "set"]);
                }
              }
            } else if (!noDisposeOnSet) {
              if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _hasDispose)) {
                (_b2 = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _dispose)) == null ? void 0 : _b2.call(this, oldVal, k, "set");
              }
              if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _hasDisposeAfter)) {
                (0, import_chunk_WWAWV7DQ.__privateGet)(this, _disposed)?.push([oldVal, k, "set"]);
              }
            }
            (0, import_chunk_WWAWV7DQ.__privateGet)(this, _removeItemSize).call(this, index);
            (0, import_chunk_WWAWV7DQ.__privateGet)(this, _addItemSize).call(this, index, size, status);
            (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[index] = v;
            if (status) {
              status.set = "replace";
              const oldValue = oldVal && (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;
              if (oldValue !== void 0)
                status.oldValue = oldValue;
            }
          } else if (status) {
            status.set = "update";
          }
        }
        if (ttl !== 0 && !(0, import_chunk_WWAWV7DQ.__privateGet)(this, _ttls)) {
          (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, initializeTTLTracking_fn).call(this);
        }
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _ttls)) {
          if (!noUpdateTTL) {
            (0, import_chunk_WWAWV7DQ.__privateGet)(this, _setItemTTL).call(this, index, ttl, start);
          }
          if (status)
            (0, import_chunk_WWAWV7DQ.__privateGet)(this, _statusTTL).call(this, status, index);
        }
        if (!noDisposeOnSet && (0, import_chunk_WWAWV7DQ.__privateGet)(this, _hasDisposeAfter) && (0, import_chunk_WWAWV7DQ.__privateGet)(this, _disposed)) {
          const dt = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _disposed);
          let task;
          while (task = dt?.shift()) {
            (_c = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _disposeAfter)) == null ? void 0 : _c.call(this, ...task);
          }
        }
        return this;
      }
      /**
       * Evict the least recently used item, returning its value or
       * `undefined` if cache is empty.
       */
      pop() {
        var _a2;
        try {
          while ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _size)) {
            const val = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[(0, import_chunk_WWAWV7DQ.__privateGet)(this, _head)];
            (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, evict_fn).call(this, true);
            if ((0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, val)) {
              if (val.__staleWhileFetching) {
                return val.__staleWhileFetching;
              }
            } else if (val !== void 0) {
              return val;
            }
          }
        } finally {
          if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _hasDisposeAfter) && (0, import_chunk_WWAWV7DQ.__privateGet)(this, _disposed)) {
            const dt = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _disposed);
            let task;
            while (task = dt?.shift()) {
              (_a2 = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _disposeAfter)) == null ? void 0 : _a2.call(this, ...task);
            }
          }
        }
      }
      /**
       * Check if a key is in the cache, without updating the recency of use.
       * Will return false if the item is stale, even though it is technically
       * in the cache.
       *
       * Will not update item age unless
       * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
       */
      has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyMap).get(k);
        if (index !== void 0) {
          const v = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[index];
          if ((0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) && v.__staleWhileFetching === void 0) {
            return false;
          }
          if (!(0, import_chunk_WWAWV7DQ.__privateGet)(this, _isStale).call(this, index)) {
            if (updateAgeOnHas) {
              (0, import_chunk_WWAWV7DQ.__privateGet)(this, _updateItemAge).call(this, index);
            }
            if (status) {
              status.has = "hit";
              (0, import_chunk_WWAWV7DQ.__privateGet)(this, _statusTTL).call(this, status, index);
            }
            return true;
          } else if (status) {
            status.has = "stale";
            (0, import_chunk_WWAWV7DQ.__privateGet)(this, _statusTTL).call(this, status, index);
          }
        } else if (status) {
          status.has = "miss";
        }
        return false;
      }
      /**
       * Like {@link LRUCache#get} but doesn't update recency or delete stale
       * items.
       *
       * Returns `undefined` if the item is stale, unless
       * {@link LRUCache.OptionsBase.allowStale} is set.
       */
      peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyMap).get(k);
        if (index === void 0 || !allowStale && (0, import_chunk_WWAWV7DQ.__privateGet)(this, _isStale).call(this, index)) {
          return;
        }
        const v = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[index];
        return (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      }
      async fetch(k, fetchOptions = {}) {
        const {
          // get options
          allowStale = this.allowStale,
          updateAgeOnGet = this.updateAgeOnGet,
          noDeleteOnStaleGet = this.noDeleteOnStaleGet,
          // set options
          ttl = this.ttl,
          noDisposeOnSet = this.noDisposeOnSet,
          size = 0,
          sizeCalculation = this.sizeCalculation,
          noUpdateTTL = this.noUpdateTTL,
          // fetch exclusive options
          noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
          allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
          ignoreFetchAbort = this.ignoreFetchAbort,
          allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
          context,
          forceRefresh = false,
          status,
          signal
        } = fetchOptions;
        if (!(0, import_chunk_WWAWV7DQ.__privateGet)(this, _hasFetchMethod)) {
          if (status)
            status.fetch = "get";
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            status
          });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          status,
          signal
        };
        let index = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyMap).get(k);
        if (index === void 0) {
          if (status)
            status.fetch = "miss";
          const p = (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, backgroundFetch_fn).call(this, k, index, options, context);
          return p.__returned = p;
        } else {
          const v = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[index];
          if ((0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
            const stale = allowStale && v.__staleWhileFetching !== void 0;
            if (status) {
              status.fetch = "inflight";
              if (stale)
                status.returnedStale = true;
            }
            return stale ? v.__staleWhileFetching : v.__returned = v;
          }
          const isStale = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _isStale).call(this, index);
          if (!forceRefresh && !isStale) {
            if (status)
              status.fetch = "hit";
            (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, moveToTail_fn).call(this, index);
            if (updateAgeOnGet) {
              (0, import_chunk_WWAWV7DQ.__privateGet)(this, _updateItemAge).call(this, index);
            }
            if (status)
              (0, import_chunk_WWAWV7DQ.__privateGet)(this, _statusTTL).call(this, status, index);
            return v;
          }
          const p = (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, backgroundFetch_fn).call(this, k, index, options, context);
          const hasStale = p.__staleWhileFetching !== void 0;
          const staleVal = hasStale && allowStale;
          if (status) {
            status.fetch = isStale ? "stale" : "refresh";
            if (staleVal && isStale)
              status.returnedStale = true;
          }
          return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      /**
       * Return a value from the cache. Will update the recency of the cache
       * entry found.
       *
       * If the key is not found, get() will return `undefined`.
       */
      get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
        const index = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyMap).get(k);
        if (index !== void 0) {
          const value = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[index];
          const fetching = (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, value);
          if (status)
            (0, import_chunk_WWAWV7DQ.__privateGet)(this, _statusTTL).call(this, status, index);
          if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _isStale).call(this, index)) {
            if (status)
              status.get = "stale";
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.delete(k);
              }
              if (status && allowStale)
                status.returnedStale = true;
              return allowStale ? value : void 0;
            } else {
              if (status && allowStale && value.__staleWhileFetching !== void 0) {
                status.returnedStale = true;
              }
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (status)
              status.get = "hit";
            if (fetching) {
              return value.__staleWhileFetching;
            }
            (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, moveToTail_fn).call(this, index);
            if (updateAgeOnGet) {
              (0, import_chunk_WWAWV7DQ.__privateGet)(this, _updateItemAge).call(this, index);
            }
            return value;
          }
        } else if (status) {
          status.get = "miss";
        }
      }
      /**
       * Deletes a key out of the cache.
       * Returns true if the key was deleted, false otherwise.
       */
      delete(k) {
        var _a2, _b2;
        let deleted = false;
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _size) !== 0) {
          const index = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyMap).get(k);
          if (index !== void 0) {
            deleted = true;
            if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _size) === 1) {
              this.clear();
            } else {
              (0, import_chunk_WWAWV7DQ.__privateGet)(this, _removeItemSize).call(this, index);
              const v = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[index];
              if ((0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
                v.__abortController.abort(new Error("deleted"));
              } else if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _hasDispose) || (0, import_chunk_WWAWV7DQ.__privateGet)(this, _hasDisposeAfter)) {
                if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _hasDispose)) {
                  (_a2 = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _dispose)) == null ? void 0 : _a2.call(this, v, k, "delete");
                }
                if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _hasDisposeAfter)) {
                  (0, import_chunk_WWAWV7DQ.__privateGet)(this, _disposed)?.push([v, k, "delete"]);
                }
              }
              (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyMap).delete(k);
              (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyList)[index] = void 0;
              (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[index] = void 0;
              if (index === (0, import_chunk_WWAWV7DQ.__privateGet)(this, _tail)) {
                (0, import_chunk_WWAWV7DQ.__privateSet)(this, _tail, (0, import_chunk_WWAWV7DQ.__privateGet)(this, _prev)[index]);
              } else if (index === (0, import_chunk_WWAWV7DQ.__privateGet)(this, _head)) {
                (0, import_chunk_WWAWV7DQ.__privateSet)(this, _head, (0, import_chunk_WWAWV7DQ.__privateGet)(this, _next)[index]);
              } else {
                const pi = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _prev)[index];
                (0, import_chunk_WWAWV7DQ.__privateGet)(this, _next)[pi] = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _next)[index];
                const ni = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _next)[index];
                (0, import_chunk_WWAWV7DQ.__privateGet)(this, _prev)[ni] = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _prev)[index];
              }
              (0, import_chunk_WWAWV7DQ.__privateWrapper)(this, _size)._--;
              (0, import_chunk_WWAWV7DQ.__privateGet)(this, _free).push(index);
            }
          }
        }
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _hasDisposeAfter) && (0, import_chunk_WWAWV7DQ.__privateGet)(this, _disposed)?.length) {
          const dt = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _disposed);
          let task;
          while (task = dt?.shift()) {
            (_b2 = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _disposeAfter)) == null ? void 0 : _b2.call(this, ...task);
          }
        }
        return deleted;
      }
      /**
       * Clear the cache entirely, throwing away all values.
       */
      clear() {
        var _a2, _b2;
        for (const index of (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: true })) {
          const v = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[index];
          if ((0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
            v.__abortController.abort(new Error("deleted"));
          } else {
            const k = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyList)[index];
            if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _hasDispose)) {
              (_a2 = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _dispose)) == null ? void 0 : _a2.call(this, v, k, "delete");
            }
            if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _hasDisposeAfter)) {
              (0, import_chunk_WWAWV7DQ.__privateGet)(this, _disposed)?.push([v, k, "delete"]);
            }
          }
        }
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyMap).clear();
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList).fill(void 0);
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyList).fill(void 0);
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _ttls) && (0, import_chunk_WWAWV7DQ.__privateGet)(this, _starts)) {
          (0, import_chunk_WWAWV7DQ.__privateGet)(this, _ttls).fill(0);
          (0, import_chunk_WWAWV7DQ.__privateGet)(this, _starts).fill(0);
        }
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _sizes)) {
          (0, import_chunk_WWAWV7DQ.__privateGet)(this, _sizes).fill(0);
        }
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _head, 0);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _tail, 0);
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _free).length = 0;
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _calculatedSize, 0);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _size, 0);
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _hasDisposeAfter) && (0, import_chunk_WWAWV7DQ.__privateGet)(this, _disposed)) {
          const dt = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _disposed);
          let task;
          while (task = dt?.shift()) {
            (_b2 = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _disposeAfter)) == null ? void 0 : _b2.call(this, ...task);
          }
        }
      }
    };
    _max = /* @__PURE__ */ new WeakMap();
    _maxSize = /* @__PURE__ */ new WeakMap();
    _dispose = /* @__PURE__ */ new WeakMap();
    _disposeAfter = /* @__PURE__ */ new WeakMap();
    _fetchMethod = /* @__PURE__ */ new WeakMap();
    _size = /* @__PURE__ */ new WeakMap();
    _calculatedSize = /* @__PURE__ */ new WeakMap();
    _keyMap = /* @__PURE__ */ new WeakMap();
    _keyList = /* @__PURE__ */ new WeakMap();
    _valList = /* @__PURE__ */ new WeakMap();
    _next = /* @__PURE__ */ new WeakMap();
    _prev = /* @__PURE__ */ new WeakMap();
    _head = /* @__PURE__ */ new WeakMap();
    _tail = /* @__PURE__ */ new WeakMap();
    _free = /* @__PURE__ */ new WeakMap();
    _disposed = /* @__PURE__ */ new WeakMap();
    _sizes = /* @__PURE__ */ new WeakMap();
    _starts = /* @__PURE__ */ new WeakMap();
    _ttls = /* @__PURE__ */ new WeakMap();
    _hasDispose = /* @__PURE__ */ new WeakMap();
    _hasFetchMethod = /* @__PURE__ */ new WeakMap();
    _hasDisposeAfter = /* @__PURE__ */ new WeakMap();
    _LRUCache_instances = /* @__PURE__ */ new WeakSet();
    initializeTTLTracking_fn = function() {
      const ttls = new ZeroArray((0, import_chunk_WWAWV7DQ.__privateGet)(this, _max));
      const starts = new ZeroArray((0, import_chunk_WWAWV7DQ.__privateGet)(this, _max));
      (0, import_chunk_WWAWV7DQ.__privateSet)(this, _ttls, ttls);
      (0, import_chunk_WWAWV7DQ.__privateSet)(this, _starts, starts);
      (0, import_chunk_WWAWV7DQ.__privateSet)(this, _setItemTTL, (index, ttl, start = perf.now()) => {
        starts[index] = ttl !== 0 ? start : 0;
        ttls[index] = ttl;
        if (ttl !== 0 && this.ttlAutopurge) {
          const t = setTimeout(() => {
            if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _isStale).call(this, index)) {
              this.delete((0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyList)[index]);
            }
          }, ttl + 1);
          if (t.unref) {
            t.unref();
          }
        }
      });
      (0, import_chunk_WWAWV7DQ.__privateSet)(this, _updateItemAge, (index) => {
        starts[index] = ttls[index] !== 0 ? perf.now() : 0;
      });
      (0, import_chunk_WWAWV7DQ.__privateSet)(this, _statusTTL, (status, index) => {
        if (ttls[index]) {
          const ttl = ttls[index];
          const start = starts[index];
          if (!ttl || !start)
            return;
          status.ttl = ttl;
          status.start = start;
          status.now = cachedNow || getNow();
          const age = status.now - start;
          status.remainingTTL = ttl - age;
        }
      });
      let cachedNow = 0;
      const getNow = () => {
        const n = perf.now();
        if (this.ttlResolution > 0) {
          cachedNow = n;
          const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
          if (t.unref) {
            t.unref();
          }
        }
        return n;
      };
      this.getRemainingTTL = (key) => {
        const index = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyMap).get(key);
        if (index === void 0) {
          return 0;
        }
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start) {
          return Infinity;
        }
        const age = (cachedNow || getNow()) - start;
        return ttl - age;
      };
      (0, import_chunk_WWAWV7DQ.__privateSet)(this, _isStale, (index) => {
        const s = starts[index];
        const t = ttls[index];
        return !!t && !!s && (cachedNow || getNow()) - s > t;
      });
    };
    _updateItemAge = /* @__PURE__ */ new WeakMap();
    _statusTTL = /* @__PURE__ */ new WeakMap();
    _setItemTTL = /* @__PURE__ */ new WeakMap();
    _isStale = /* @__PURE__ */ new WeakMap();
    initializeSizeTracking_fn = function() {
      const sizes = new ZeroArray((0, import_chunk_WWAWV7DQ.__privateGet)(this, _max));
      (0, import_chunk_WWAWV7DQ.__privateSet)(this, _calculatedSize, 0);
      (0, import_chunk_WWAWV7DQ.__privateSet)(this, _sizes, sizes);
      (0, import_chunk_WWAWV7DQ.__privateSet)(this, _removeItemSize, (index) => {
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _calculatedSize, (0, import_chunk_WWAWV7DQ.__privateGet)(this, _calculatedSize) - sizes[index]);
        sizes[index] = 0;
      });
      (0, import_chunk_WWAWV7DQ.__privateSet)(this, _requireSize, (k, v, size, sizeCalculation) => {
        if ((0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
          return 0;
        }
        if (!isPosInt(size)) {
          if (sizeCalculation) {
            if (typeof sizeCalculation !== "function") {
              throw new TypeError("sizeCalculation must be a function");
            }
            size = sizeCalculation(v, k);
            if (!isPosInt(size)) {
              throw new TypeError("sizeCalculation return invalid (expect positive integer)");
            }
          } else {
            throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
          }
        }
        return size;
      });
      (0, import_chunk_WWAWV7DQ.__privateSet)(this, _addItemSize, (index, size, status) => {
        sizes[index] = size;
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _maxSize)) {
          const maxSize = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _maxSize) - sizes[index];
          while ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _calculatedSize) > maxSize) {
            (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, evict_fn).call(this, true);
          }
        }
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _calculatedSize, (0, import_chunk_WWAWV7DQ.__privateGet)(this, _calculatedSize) + sizes[index]);
        if (status) {
          status.entrySize = size;
          status.totalCalculatedSize = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _calculatedSize);
        }
      });
    };
    _removeItemSize = /* @__PURE__ */ new WeakMap();
    _addItemSize = /* @__PURE__ */ new WeakMap();
    _requireSize = /* @__PURE__ */ new WeakMap();
    indexes_fn = function* ({ allowStale = this.allowStale } = {}) {
      if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _size)) {
        for (let i = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _tail); true; ) {
          if (!(0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isValidIndex_fn).call(this, i)) {
            break;
          }
          if (allowStale || !(0, import_chunk_WWAWV7DQ.__privateGet)(this, _isStale).call(this, i)) {
            yield i;
          }
          if (i === (0, import_chunk_WWAWV7DQ.__privateGet)(this, _head)) {
            break;
          } else {
            i = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _prev)[i];
          }
        }
      }
    };
    rindexes_fn = function* ({ allowStale = this.allowStale } = {}) {
      if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _size)) {
        for (let i = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _head); true; ) {
          if (!(0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isValidIndex_fn).call(this, i)) {
            break;
          }
          if (allowStale || !(0, import_chunk_WWAWV7DQ.__privateGet)(this, _isStale).call(this, i)) {
            yield i;
          }
          if (i === (0, import_chunk_WWAWV7DQ.__privateGet)(this, _tail)) {
            break;
          } else {
            i = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _next)[i];
          }
        }
      }
    };
    isValidIndex_fn = function(index) {
      return index !== void 0 && (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyMap).get((0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyList)[index]) === index;
    };
    evict_fn = function(free) {
      var _a2;
      const head = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _head);
      const k = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyList)[head];
      const v = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[head];
      if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _hasFetchMethod) && (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
        v.__abortController.abort(new Error("evicted"));
      } else if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _hasDispose) || (0, import_chunk_WWAWV7DQ.__privateGet)(this, _hasDisposeAfter)) {
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _hasDispose)) {
          (_a2 = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _dispose)) == null ? void 0 : _a2.call(this, v, k, "evict");
        }
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _hasDisposeAfter)) {
          (0, import_chunk_WWAWV7DQ.__privateGet)(this, _disposed)?.push([v, k, "evict"]);
        }
      }
      (0, import_chunk_WWAWV7DQ.__privateGet)(this, _removeItemSize).call(this, head);
      if (free) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyList)[head] = void 0;
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[head] = void 0;
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _free).push(head);
      }
      if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _size) === 1) {
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _head, (0, import_chunk_WWAWV7DQ.__privateSet)(this, _tail, 0));
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _free).length = 0;
      } else {
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _head, (0, import_chunk_WWAWV7DQ.__privateGet)(this, _next)[head]);
      }
      (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyMap).delete(k);
      (0, import_chunk_WWAWV7DQ.__privateWrapper)(this, _size)._--;
      return head;
    };
    backgroundFetch_fn = function(k, index, options, context) {
      const v = index === void 0 ? void 0 : (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[index];
      if ((0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
        return v;
      }
      const ac = new AC();
      const { signal } = options;
      signal?.addEventListener("abort", () => ac.abort(signal.reason), {
        signal: ac.signal
      });
      const fetchOpts = {
        signal: ac.signal,
        options,
        context
      };
      const cb = (v2, updateCache = false) => {
        const { aborted } = ac.signal;
        const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
        if (options.status) {
          if (aborted && !updateCache) {
            options.status.fetchAborted = true;
            options.status.fetchError = ac.signal.reason;
            if (ignoreAbort)
              options.status.fetchAbortIgnored = true;
          } else {
            options.status.fetchResolved = true;
          }
        }
        if (aborted && !ignoreAbort && !updateCache) {
          return fetchFail(ac.signal.reason);
        }
        const bf2 = p;
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[index] === p) {
          if (v2 === void 0) {
            if (bf2.__staleWhileFetching) {
              (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[index] = bf2.__staleWhileFetching;
            } else {
              this.delete(k);
            }
          } else {
            if (options.status)
              options.status.fetchUpdated = true;
            this.set(k, v2, fetchOpts.options);
          }
        }
        return v2;
      };
      const eb = (er) => {
        if (options.status) {
          options.status.fetchRejected = true;
          options.status.fetchError = er;
        }
        return fetchFail(er);
      };
      const fetchFail = (er) => {
        const { aborted } = ac.signal;
        const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
        const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
        const noDelete = allowStale || options.noDeleteOnFetchRejection;
        const bf2 = p;
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[index] === p) {
          const del = !noDelete || bf2.__staleWhileFetching === void 0;
          if (del) {
            this.delete(k);
          } else if (!allowStaleAborted) {
            (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[index] = bf2.__staleWhileFetching;
          }
        }
        if (allowStale) {
          if (options.status && bf2.__staleWhileFetching !== void 0) {
            options.status.returnedStale = true;
          }
          return bf2.__staleWhileFetching;
        } else if (bf2.__returned === bf2) {
          throw er;
        }
      };
      const pcall = (res, rej) => {
        var _a2;
        const fmp = (_a2 = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _fetchMethod)) == null ? void 0 : _a2.call(this, k, v, fetchOpts);
        if (fmp && fmp instanceof Promise) {
          fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
        }
        ac.signal.addEventListener("abort", () => {
          if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
            res(void 0);
            if (options.allowStaleOnFetchAbort) {
              res = (v2) => cb(v2, true);
            }
          }
        });
      };
      if (options.status)
        options.status.fetchDispatched = true;
      const p = new Promise(pcall).then(cb, eb);
      const bf = Object.assign(p, {
        __abortController: ac,
        __staleWhileFetching: v,
        __returned: void 0
      });
      if (index === void 0) {
        this.set(k, bf, { ...fetchOpts.options, status: void 0 });
        index = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _keyMap).get(k);
      } else {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _valList)[index] = bf;
      }
      return bf;
    };
    isBackgroundFetch_fn = function(p) {
      if (!(0, import_chunk_WWAWV7DQ.__privateGet)(this, _hasFetchMethod))
        return false;
      const b = p;
      return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
    };
    connect_fn = function(p, n) {
      (0, import_chunk_WWAWV7DQ.__privateGet)(this, _prev)[n] = p;
      (0, import_chunk_WWAWV7DQ.__privateGet)(this, _next)[p] = n;
    };
    moveToTail_fn = function(index) {
      if (index !== (0, import_chunk_WWAWV7DQ.__privateGet)(this, _tail)) {
        if (index === (0, import_chunk_WWAWV7DQ.__privateGet)(this, _head)) {
          (0, import_chunk_WWAWV7DQ.__privateSet)(this, _head, (0, import_chunk_WWAWV7DQ.__privateGet)(this, _next)[index]);
        } else {
          (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, connect_fn).call(this, (0, import_chunk_WWAWV7DQ.__privateGet)(this, _prev)[index], (0, import_chunk_WWAWV7DQ.__privateGet)(this, _next)[index]);
        }
        (0, import_chunk_WWAWV7DQ.__privateMethod)(this, _LRUCache_instances, connect_fn).call(this, (0, import_chunk_WWAWV7DQ.__privateGet)(this, _tail), index);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _tail, index);
      }
    };
    var LRUCache = _LRUCache;
    exports.LRUCache = LRUCache;
  }
});
