"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var setupMysql_exports = {};
__export(setupMysql_exports, {
  setupMysql: () => setupMysql,
  tearDownMysql: () => tearDownMysql
});
module.exports = __toCommonJS(setupMysql_exports);
var import_chunk_LOGAFLCN = require("../chunk-LOGAFLCN.js");
var import_chunk_XRTNIFND = require("../chunk-XRTNIFND.js");
var import_chunk_WWAWV7DQ = require("../chunk-WWAWV7DQ.js");
var import_internals = require("@prisma/internals");
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var require_package = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/package.json"(exports, module2) {
    module2.exports = {
      name: "mariadb",
      version: "3.3.1",
      description: "fast mariadb or mysql connector.",
      main: "promise.js",
      types: "types/index.d.ts",
      directories: {
        lib: "lib",
        test: "test"
      },
      private: false,
      scripts: {
        test: "npm run test:types-prettier && npm run test:prettier && npm run test:types && npm run test:lint && npm run test:base",
        "test:base": 'mocha --no-parallel --timeout 5000 "test/**/*.js" ',
        "test:lint": 'eslint "*.js" "{lib,test}/**/*.js" ',
        "test:types": 'eslint "types/*.ts" ',
        "test:types-prettier": 'prettier --write "types/*.ts"',
        "test:prettier": 'prettier --write "*.js" "{tools,lib,test,benchmarks}/**/*.js"',
        coverage: "npm run coverage:test && npm run coverage:create && npm run coverage:send",
        "coverage:test": 'nyc mocha --no-parallel --timeout 5000 "test/**/*.js"',
        "coverage:report": "npm run coverage:create && npm run coverage:send",
        "coverage:create": "nyc report --reporter=text-lcov > coverage.lcov",
        "coverage:send": "./codecov --disable=gcov",
        benchmark: "node benchmarks/benchmarks-all.js",
        generate: "node ./tools/generate-mariadb.js"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/mariadb-corporation/mariadb-connector-nodejs.git"
      },
      keywords: [
        "mariadb",
        "mysql",
        "client",
        "driver",
        "connector"
      ],
      files: [
        "lib",
        "types/index.d.ts",
        "promise.js",
        "check-node.js",
        "callback.js"
      ],
      engines: {
        node: ">= 14"
      },
      author: "Diego Dupin <diego.dupin@mariadb.com>",
      license: "LGPL-2.1-or-later",
      dependencies: {
        "@types/geojson": "^7946.0.14",
        "@types/node": "^20.11.17",
        denque: "^2.1.0",
        "iconv-lite": "^0.6.3",
        "lru-cache": "^10.2.0"
      },
      devDependencies: {
        "@typescript-eslint/eslint-plugin": "^6.6.0",
        "@typescript-eslint/parser": "^6.6.0",
        benchmark: "^2.1.4",
        chai: "^4.4.1",
        chalk: "^4.1.2",
        "error-stack-parser": "^2.1.4",
        eslint: "^8.48.0",
        "eslint-config-prettier": "^9.0.0",
        "eslint-plugin-markdown": "^3.0.1",
        "eslint-plugin-prettier": "^5.0.0",
        mocha: "^10.2.0",
        "mocha-lcov-reporter": "^1.3.0",
        nyc: "^15.1.0",
        prettier: "^3.0.3",
        typescript: "^5.3.3",
        winston: "^3.10.0"
      },
      bugs: {
        url: "https://jira.mariadb.org/projects/CONJS/"
      },
      homepage: "https://github.com/mariadb-corporation/mariadb-connector-nodejs#readme"
    };
  }
});
var require_check_node = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/check-node.js"(exports, module2) {
    "use strict";
    var hasMinVersion = function(nodeVersionStr, connectorRequirement2) {
      const versNode = nodeVersionStr.split(".");
      const versReq = connectorRequirement2.split(".");
      const majorNode = Number(versNode[0]);
      const majorReq = Number(versReq[0]);
      if (majorNode > majorReq) return true;
      if (majorNode < majorReq) return false;
      if (versReq.length === 1) return true;
      const minorNode = Number(versNode[1]);
      const minorReq = Number(versReq[1]);
      return minorNode >= minorReq;
    };
    module2.exports.hasMinVersion = hasMinVersion;
    var requirement = require_package().engines.node;
    var connectorRequirement = requirement.replace(">=", "").trim();
    var currentNodeVersion = process.version.replace("v", "");
    if (!hasMinVersion(currentNodeVersion, connectorRequirement)) {
      console.error(`please upgrade node: mariadb requires at least version ${connectorRequirement}`);
      process.exit(1);
    }
  }
});
var require_denque = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/denque@2.1.0/node_modules/denque/index.js"(exports, module2) {
    "use strict";
    function Denque(array, options) {
      var options = options || {};
      this._capacity = options.capacity;
      this._head = 0;
      this._tail = 0;
      if (Array.isArray(array)) {
        this._fromArray(array);
      } else {
        this._capacityMask = 3;
        this._list = new Array(4);
      }
    }
    Denque.prototype.peekAt = function peekAt(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var len = this.size();
      if (i >= len || i < -len) return void 0;
      if (i < 0) i += len;
      i = this._head + i & this._capacityMask;
      return this._list[i];
    };
    Denque.prototype.get = function get(i) {
      return this.peekAt(i);
    };
    Denque.prototype.peek = function peek() {
      if (this._head === this._tail) return void 0;
      return this._list[this._head];
    };
    Denque.prototype.peekFront = function peekFront() {
      return this.peek();
    };
    Denque.prototype.peekBack = function peekBack() {
      return this.peekAt(-1);
    };
    Object.defineProperty(Denque.prototype, "length", {
      get: function length() {
        return this.size();
      }
    });
    Denque.prototype.size = function size() {
      if (this._head === this._tail) return 0;
      if (this._head < this._tail) return this._tail - this._head;
      else return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.unshift = function unshift(item) {
      if (arguments.length === 0) return this.size();
      var len = this._list.length;
      this._head = this._head - 1 + len & this._capacityMask;
      this._list[this._head] = item;
      if (this._tail === this._head) this._growArray();
      if (this._capacity && this.size() > this._capacity) this.pop();
      if (this._head < this._tail) return this._tail - this._head;
      else return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.shift = function shift() {
      var head = this._head;
      if (head === this._tail) return void 0;
      var item = this._list[head];
      this._list[head] = void 0;
      this._head = head + 1 & this._capacityMask;
      if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2) this._shrinkArray();
      return item;
    };
    Denque.prototype.push = function push(item) {
      if (arguments.length === 0) return this.size();
      var tail = this._tail;
      this._list[tail] = item;
      this._tail = tail + 1 & this._capacityMask;
      if (this._tail === this._head) {
        this._growArray();
      }
      if (this._capacity && this.size() > this._capacity) {
        this.shift();
      }
      if (this._head < this._tail) return this._tail - this._head;
      else return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.pop = function pop() {
      var tail = this._tail;
      if (tail === this._head) return void 0;
      var len = this._list.length;
      this._tail = tail - 1 + len & this._capacityMask;
      var item = this._list[this._tail];
      this._list[this._tail] = void 0;
      if (this._head < 2 && tail > 1e4 && tail <= len >>> 2) this._shrinkArray();
      return item;
    };
    Denque.prototype.removeOne = function removeOne(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail) return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size) return void 0;
      if (i < 0) i += size;
      i = this._head + i & this._capacityMask;
      var item = this._list[i];
      var k;
      if (index < size / 2) {
        for (k = index; k > 0; k--) {
          this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._head = this._head + 1 + len & this._capacityMask;
      } else {
        for (k = size - 1 - index; k > 0; k--) {
          this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._tail = this._tail - 1 + len & this._capacityMask;
      }
      return item;
    };
    Denque.prototype.remove = function remove(index, count) {
      var i = index;
      var removed;
      var del_count = count;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail) return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size || count < 1) return void 0;
      if (i < 0) i += size;
      if (count === 1 || !count) {
        removed = new Array(1);
        removed[0] = this.removeOne(i);
        return removed;
      }
      if (i === 0 && i + count >= size) {
        removed = this.toArray();
        this.clear();
        return removed;
      }
      if (i + count > size) count = size - i;
      var k;
      removed = new Array(count);
      for (k = 0; k < count; k++) {
        removed[k] = this._list[this._head + i + k & this._capacityMask];
      }
      i = this._head + i & this._capacityMask;
      if (index + count === size) {
        this._tail = this._tail - count + len & this._capacityMask;
        for (k = count; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (index === 0) {
        this._head = this._head + count + len & this._capacityMask;
        for (k = count - 1; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (i < size / 2) {
        this._head = this._head + index + count + len & this._capacityMask;
        for (k = index; k > 0; k--) {
          this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
        }
        i = this._head - 1 + len & this._capacityMask;
        while (del_count > 0) {
          this._list[i = i - 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
        if (index < 0) this._tail = i;
      } else {
        this._tail = i;
        i = i + count + len & this._capacityMask;
        for (k = size - (count + index); k > 0; k--) {
          this.push(this._list[i++]);
        }
        i = this._tail;
        while (del_count > 0) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
      }
      if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2) this._shrinkArray();
      return removed;
    };
    Denque.prototype.splice = function splice(index, count) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var size = this.size();
      if (i < 0) i += size;
      if (i > size) return void 0;
      if (arguments.length > 2) {
        var k;
        var temp;
        var removed;
        var arg_len = arguments.length;
        var len = this._list.length;
        var arguments_index = 2;
        if (!size || i < size / 2) {
          temp = new Array(i);
          for (k = 0; k < i; k++) {
            temp[k] = this._list[this._head + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i > 0) {
              this._head = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._head = this._head + i + len & this._capacityMask;
          }
          while (arg_len > arguments_index) {
            this.unshift(arguments[--arg_len]);
          }
          for (k = i; k > 0; k--) {
            this.unshift(temp[k - 1]);
          }
        } else {
          temp = new Array(size - (i + count));
          var leng = temp.length;
          for (k = 0; k < leng; k++) {
            temp[k] = this._list[this._head + i + count + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i != size) {
              this._tail = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._tail = this._tail - leng + len & this._capacityMask;
          }
          while (arguments_index < arg_len) {
            this.push(arguments[arguments_index++]);
          }
          for (k = 0; k < leng; k++) {
            this.push(temp[k]);
          }
        }
        return removed;
      } else {
        return this.remove(i, count);
      }
    };
    Denque.prototype.clear = function clear() {
      this._list = new Array(this._list.length);
      this._head = 0;
      this._tail = 0;
    };
    Denque.prototype.isEmpty = function isEmpty() {
      return this._head === this._tail;
    };
    Denque.prototype.toArray = function toArray() {
      return this._copyArray(false);
    };
    Denque.prototype._fromArray = function _fromArray(array) {
      var length = array.length;
      var capacity = this._nextPowerOf2(length);
      this._list = new Array(capacity);
      this._capacityMask = capacity - 1;
      this._tail = length;
      for (var i = 0; i < length; i++) this._list[i] = array[i];
    };
    Denque.prototype._copyArray = function _copyArray(fullCopy, size) {
      var src = this._list;
      var capacity = src.length;
      var length = this.length;
      size = size | length;
      if (size == length && this._head < this._tail) {
        return this._list.slice(this._head, this._tail);
      }
      var dest = new Array(size);
      var k = 0;
      var i;
      if (fullCopy || this._head > this._tail) {
        for (i = this._head; i < capacity; i++) dest[k++] = src[i];
        for (i = 0; i < this._tail; i++) dest[k++] = src[i];
      } else {
        for (i = this._head; i < this._tail; i++) dest[k++] = src[i];
      }
      return dest;
    };
    Denque.prototype._growArray = function _growArray() {
      if (this._head != 0) {
        var newList = this._copyArray(true, this._list.length << 1);
        this._tail = this._list.length;
        this._head = 0;
        this._list = newList;
      } else {
        this._tail = this._list.length;
        this._list.length <<= 1;
      }
      this._capacityMask = this._capacityMask << 1 | 1;
    };
    Denque.prototype._shrinkArray = function _shrinkArray() {
      this._list.length >>>= 1;
      this._capacityMask >>>= 1;
    };
    Denque.prototype._nextPowerOf2 = function _nextPowerOf2(num) {
      var log2 = Math.log(num) / Math.log(2);
      var nextPow2 = 1 << log2 + 1;
      return Math.max(nextPow2, 4);
    };
    module2.exports = Denque;
  }
});
var require_error_code = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/const/error-code.js"(exports, module2) {
    "use strict";
    var codes = {};
    codes[120] = "HA_ERR_KEY_NOT_FOUND";
    codes[121] = "HA_ERR_FOUND_DUPP_KEY";
    codes[122] = "HA_ERR_INTERNAL_ERROR";
    codes[123] = "HA_ERR_RECORD_CHANGED";
    codes[124] = "HA_ERR_WRONG_INDEX";
    codes[126] = "HA_ERR_CRASHED";
    codes[127] = "HA_ERR_WRONG_IN_RECORD";
    codes[128] = "HA_ERR_OUT_OF_MEM";
    codes[130] = "HA_ERR_NOT_A_TABLE";
    codes[131] = "HA_ERR_WRONG_COMMAND";
    codes[132] = "HA_ERR_OLD_FILE";
    codes[133] = "HA_ERR_NO_ACTIVE_RECORD";
    codes[134] = "HA_ERR_RECORD_DELETED";
    codes[135] = "HA_ERR_RECORD_FILE_FULL";
    codes[136] = "HA_ERR_INDEX_FILE_FULL";
    codes[137] = "HA_ERR_END_OF_FILE";
    codes[138] = "HA_ERR_UNSUPPORTED";
    codes[139] = "HA_ERR_TO_BIG_ROW";
    codes[140] = "HA_WRONG_CREATE_OPTION";
    codes[141] = "HA_ERR_FOUND_DUPP_UNIQUE";
    codes[142] = "HA_ERR_UNKNOWN_CHARSET";
    codes[143] = "HA_ERR_WRONG_MRG_TABLE_DEF";
    codes[144] = "HA_ERR_CRASHED_ON_REPAIR";
    codes[145] = "HA_ERR_CRASHED_ON_USAGE";
    codes[146] = "HA_ERR_LOCK_WAIT_TIMEOUT";
    codes[147] = "HA_ERR_LOCK_TABLE_FULL";
    codes[148] = "HA_ERR_READ_ONLY_TRANSACTION";
    codes[149] = "HA_ERR_LOCK_DEADLOCK";
    codes[150] = "HA_ERR_CANNOT_ADD_FOREIGN";
    codes[151] = "HA_ERR_NO_REFERENCED_ROW";
    codes[152] = "HA_ERR_ROW_IS_REFERENCED";
    codes[153] = "HA_ERR_NO_SAVEPOINT";
    codes[154] = "HA_ERR_NON_UNIQUE_BLOCK_SIZE";
    codes[155] = "HA_ERR_NO_SUCH_TABLE";
    codes[156] = "HA_ERR_TABLE_EXIST";
    codes[157] = "HA_ERR_NO_CONNECTION";
    codes[158] = "HA_ERR_NULL_IN_SPATIAL";
    codes[159] = "HA_ERR_TABLE_DEF_CHANGED";
    codes[160] = "HA_ERR_NO_PARTITION_FOUND";
    codes[161] = "HA_ERR_RBR_LOGGING_FAILED";
    codes[162] = "HA_ERR_DROP_INDEX_FK";
    codes[163] = "HA_ERR_FOREIGN_DUPLICATE_KEY";
    codes[164] = "HA_ERR_TABLE_NEEDS_UPGRADE";
    codes[165] = "HA_ERR_TABLE_READONLY";
    codes[166] = "HA_ERR_AUTOINC_READ_FAILED";
    codes[167] = "HA_ERR_AUTOINC_ERANGE";
    codes[168] = "HA_ERR_GENERIC";
    codes[169] = "HA_ERR_RECORD_IS_THE_SAME";
    codes[170] = "HA_ERR_LOGGING_IMPOSSIBLE";
    codes[171] = "HA_ERR_CORRUPT_EVENT";
    codes[172] = "HA_ERR_NEW_FILE";
    codes[173] = "HA_ERR_ROWS_EVENT_APPLY";
    codes[174] = "HA_ERR_INITIALIZATION";
    codes[175] = "HA_ERR_FILE_TOO_SHORT";
    codes[176] = "HA_ERR_WRONG_CRC";
    codes[177] = "HA_ERR_TOO_MANY_CONCURRENT_TRXS";
    codes[178] = "HA_ERR_NOT_IN_LOCK_PARTITIONS";
    codes[179] = "HA_ERR_INDEX_COL_TOO_LONG";
    codes[180] = "HA_ERR_INDEX_CORRUPT";
    codes[181] = "HA_ERR_UNDO_REC_TOO_BIG";
    codes[182] = "HA_FTS_INVALID_DOCID";
    codes[184] = "HA_ERR_TABLESPACE_EXISTS";
    codes[185] = "HA_ERR_TOO_MANY_FIELDS";
    codes[186] = "HA_ERR_ROW_IN_WRONG_PARTITION";
    codes[187] = "HA_ERR_ROW_NOT_VISIBLE";
    codes[188] = "HA_ERR_ABORTED_BY_USER";
    codes[189] = "HA_ERR_DISK_FULL";
    codes[190] = "HA_ERR_INCOMPATIBLE_DEFINITION";
    codes[191] = "HA_ERR_FTS_TOO_MANY_WORDS_IN_PHRASE";
    codes[192] = "HA_ERR_DECRYPTION_FAILED";
    codes[193] = "HA_ERR_FK_DEPTH_EXCEEDED";
    codes[194] = "HA_ERR_TABLESPACE_MISSING";
    codes[195] = "HA_ERR_SEQUENCE_INVALID_DATA";
    codes[196] = "HA_ERR_SEQUENCE_RUN_OUT";
    codes[197] = "HA_ERR_COMMIT_ERROR";
    codes[198] = "HA_ERR_PARTITION_LIST";
    codes[1e3] = "ER_HASHCHK";
    codes[1001] = "ER_NISAMCHK";
    codes[1002] = "ER_NO";
    codes[1003] = "ER_YES";
    codes[1004] = "ER_CANT_CREATE_FILE";
    codes[1005] = "ER_CANT_CREATE_TABLE";
    codes[1006] = "ER_CANT_CREATE_DB";
    codes[1007] = "ER_DB_CREATE_EXISTS";
    codes[1008] = "ER_DB_DROP_EXISTS";
    codes[1009] = "ER_DB_DROP_DELETE";
    codes[1010] = "ER_DB_DROP_RMDIR";
    codes[1011] = "ER_CANT_DELETE_FILE";
    codes[1012] = "ER_CANT_FIND_SYSTEM_REC";
    codes[1013] = "ER_CANT_GET_STAT";
    codes[1014] = "ER_CANT_GET_WD";
    codes[1015] = "ER_CANT_LOCK";
    codes[1016] = "ER_CANT_OPEN_FILE";
    codes[1017] = "ER_FILE_NOT_FOUND";
    codes[1018] = "ER_CANT_READ_DIR";
    codes[1019] = "ER_CANT_SET_WD";
    codes[1020] = "ER_CHECKREAD";
    codes[1021] = "ER_DISK_FULL";
    codes[1022] = "ER_DUP_KEY";
    codes[1023] = "ER_ERROR_ON_CLOSE";
    codes[1024] = "ER_ERROR_ON_READ";
    codes[1025] = "ER_ERROR_ON_RENAME";
    codes[1026] = "ER_ERROR_ON_WRITE";
    codes[1027] = "ER_FILE_USED";
    codes[1028] = "ER_FILSORT_ABORT";
    codes[1029] = "ER_FORM_NOT_FOUND";
    codes[1030] = "ER_GET_ERRNO";
    codes[1031] = "ER_ILLEGAL_HA";
    codes[1032] = "ER_KEY_NOT_FOUND";
    codes[1033] = "ER_NOT_FORM_FILE";
    codes[1034] = "ER_NOT_KEYFILE";
    codes[1035] = "ER_OLD_KEYFILE";
    codes[1036] = "ER_OPEN_AS_READONLY";
    codes[1037] = "ER_OUTOFMEMORY";
    codes[1038] = "ER_OUT_OF_SORTMEMORY";
    codes[1039] = "ER_UNEXPECTED_EOF";
    codes[1040] = "ER_CON_COUNT_ERROR";
    codes[1041] = "ER_OUT_OF_RESOURCES";
    codes[1042] = "ER_BAD_HOST_ERROR";
    codes[1043] = "ER_HANDSHAKE_ERROR";
    codes[1044] = "ER_DBACCESS_DENIED_ERROR";
    codes[1045] = "ER_ACCESS_DENIED_ERROR";
    codes[1046] = "ER_NO_DB_ERROR";
    codes[1047] = "ER_UNKNOWN_COM_ERROR";
    codes[1048] = "ER_BAD_NULL_ERROR";
    codes[1049] = "ER_BAD_DB_ERROR";
    codes[1050] = "ER_TABLE_EXISTS_ERROR";
    codes[1051] = "ER_BAD_TABLE_ERROR";
    codes[1052] = "ER_NON_UNIQ_ERROR";
    codes[1053] = "ER_SERVER_SHUTDOWN";
    codes[1054] = "ER_BAD_FIELD_ERROR";
    codes[1055] = "ER_WRONG_FIELD_WITH_GROUP";
    codes[1056] = "ER_WRONG_GROUP_FIELD";
    codes[1057] = "ER_WRONG_SUM_SELECT";
    codes[1058] = "ER_WRONG_VALUE_COUNT";
    codes[1059] = "ER_TOO_LONG_IDENT";
    codes[1060] = "ER_DUP_FIELDNAME";
    codes[1061] = "ER_DUP_KEYNAME";
    codes[1062] = "ER_DUP_ENTRY";
    codes[1063] = "ER_WRONG_FIELD_SPEC";
    codes[1064] = "ER_PARSE_ERROR";
    codes[1065] = "ER_EMPTY_QUERY";
    codes[1066] = "ER_NONUNIQ_TABLE";
    codes[1067] = "ER_INVALID_DEFAULT";
    codes[1068] = "ER_MULTIPLE_PRI_KEY";
    codes[1069] = "ER_TOO_MANY_KEYS";
    codes[1070] = "ER_TOO_MANY_KEY_PARTS";
    codes[1071] = "ER_TOO_LONG_KEY";
    codes[1072] = "ER_KEY_COLUMN_DOES_NOT_EXIST";
    codes[1073] = "ER_BLOB_USED_AS_KEY";
    codes[1074] = "ER_TOO_BIG_FIELDLENGTH";
    codes[1075] = "ER_WRONG_AUTO_KEY";
    codes[1076] = "ER_BINLOG_CANT_DELETE_GTID_DOMAIN";
    codes[1077] = "ER_NORMAL_SHUTDOWN";
    codes[1078] = "ER_GOT_SIGNAL";
    codes[1079] = "ER_SHUTDOWN_COMPLETE";
    codes[1080] = "ER_FORCING_CLOSE";
    codes[1081] = "ER_IPSOCK_ERROR";
    codes[1082] = "ER_NO_SUCH_INDEX";
    codes[1083] = "ER_WRONG_FIELD_TERMINATORS";
    codes[1084] = "ER_BLOBS_AND_NO_TERMINATED";
    codes[1085] = "ER_TEXTFILE_NOT_READABLE";
    codes[1086] = "ER_FILE_EXISTS_ERROR";
    codes[1087] = "ER_LOAD_INFO";
    codes[1088] = "ER_ALTER_INFO";
    codes[1089] = "ER_WRONG_SUB_KEY";
    codes[1090] = "ER_CANT_REMOVE_ALL_FIELDS";
    codes[1091] = "ER_CANT_DROP_FIELD_OR_KEY";
    codes[1092] = "ER_INSERT_INFO";
    codes[1093] = "ER_UPDATE_TABLE_USED";
    codes[1094] = "ER_NO_SUCH_THREAD";
    codes[1095] = "ER_KILL_DENIED_ERROR";
    codes[1096] = "ER_NO_TABLES_USED";
    codes[1097] = "ER_TOO_BIG_SET";
    codes[1098] = "ER_NO_UNIQUE_LOGFILE";
    codes[1099] = "ER_TABLE_NOT_LOCKED_FOR_WRITE";
    codes[1100] = "ER_TABLE_NOT_LOCKED";
    codes[1101] = "ER_UNUSED_17";
    codes[1102] = "ER_WRONG_DB_NAME";
    codes[1103] = "ER_WRONG_TABLE_NAME";
    codes[1104] = "ER_TOO_BIG_SELECT";
    codes[1105] = "ER_UNKNOWN_ERROR";
    codes[1106] = "ER_UNKNOWN_PROCEDURE";
    codes[1107] = "ER_WRONG_PARAMCOUNT_TO_PROCEDURE";
    codes[1108] = "ER_WRONG_PARAMETERS_TO_PROCEDURE";
    codes[1109] = "ER_UNKNOWN_TABLE";
    codes[1110] = "ER_FIELD_SPECIFIED_TWICE";
    codes[1111] = "ER_INVALID_GROUP_FUNC_USE";
    codes[1112] = "ER_UNSUPPORTED_EXTENSION";
    codes[1113] = "ER_TABLE_MUST_HAVE_COLUMNS";
    codes[1114] = "ER_RECORD_FILE_FULL";
    codes[1115] = "ER_UNKNOWN_CHARACTER_SET";
    codes[1116] = "ER_TOO_MANY_TABLES";
    codes[1117] = "ER_TOO_MANY_FIELDS";
    codes[1118] = "ER_TOO_BIG_ROWSIZE";
    codes[1119] = "ER_STACK_OVERRUN";
    codes[1120] = "ER_WRONG_OUTER_JOIN";
    codes[1121] = "ER_NULL_COLUMN_IN_INDEX";
    codes[1122] = "ER_CANT_FIND_UDF";
    codes[1123] = "ER_CANT_INITIALIZE_UDF";
    codes[1124] = "ER_UDF_NO_PATHS";
    codes[1125] = "ER_UDF_EXISTS";
    codes[1126] = "ER_CANT_OPEN_LIBRARY";
    codes[1127] = "ER_CANT_FIND_DL_ENTRY";
    codes[1128] = "ER_FUNCTION_NOT_DEFINED";
    codes[1129] = "ER_HOST_IS_BLOCKED";
    codes[1130] = "ER_HOST_NOT_PRIVILEGED";
    codes[1131] = "ER_PASSWORD_ANONYMOUS_USER";
    codes[1132] = "ER_PASSWORD_NOT_ALLOWED";
    codes[1133] = "ER_PASSWORD_NO_MATCH";
    codes[1134] = "ER_UPDATE_INFO";
    codes[1135] = "ER_CANT_CREATE_THREAD";
    codes[1136] = "ER_WRONG_VALUE_COUNT_ON_ROW";
    codes[1137] = "ER_CANT_REOPEN_TABLE";
    codes[1138] = "ER_INVALID_USE_OF_NULL";
    codes[1139] = "ER_REGEXP_ERROR";
    codes[1140] = "ER_MIX_OF_GROUP_FUNC_AND_FIELDS";
    codes[1141] = "ER_NONEXISTING_GRANT";
    codes[1142] = "ER_TABLEACCESS_DENIED_ERROR";
    codes[1143] = "ER_COLUMNACCESS_DENIED_ERROR";
    codes[1144] = "ER_ILLEGAL_GRANT_FOR_TABLE";
    codes[1145] = "ER_GRANT_WRONG_HOST_OR_USER";
    codes[1146] = "ER_NO_SUCH_TABLE";
    codes[1147] = "ER_NONEXISTING_TABLE_GRANT";
    codes[1148] = "ER_NOT_ALLOWED_COMMAND";
    codes[1149] = "ER_SYNTAX_ERROR";
    codes[1150] = "ER_DELAYED_CANT_CHANGE_LOCK";
    codes[1151] = "ER_TOO_MANY_DELAYED_THREADS";
    codes[1152] = "ER_ABORTING_CONNECTION";
    codes[1153] = "ER_NET_PACKET_TOO_LARGE";
    codes[1154] = "ER_NET_READ_ERROR_FROM_PIPE";
    codes[1155] = "ER_NET_FCNTL_ERROR";
    codes[1156] = "ER_NET_PACKETS_OUT_OF_ORDER";
    codes[1157] = "ER_NET_UNCOMPRESS_ERROR";
    codes[1158] = "ER_NET_READ_ERROR";
    codes[1159] = "ER_NET_READ_INTERRUPTED";
    codes[1160] = "ER_NET_ERROR_ON_WRITE";
    codes[1161] = "ER_NET_WRITE_INTERRUPTED";
    codes[1162] = "ER_TOO_LONG_STRING";
    codes[1163] = "ER_TABLE_CANT_HANDLE_BLOB";
    codes[1164] = "ER_TABLE_CANT_HANDLE_AUTO_INCREMENT";
    codes[1165] = "ER_DELAYED_INSERT_TABLE_LOCKED";
    codes[1166] = "ER_WRONG_COLUMN_NAME";
    codes[1167] = "ER_WRONG_KEY_COLUMN";
    codes[1168] = "ER_WRONG_MRG_TABLE";
    codes[1169] = "ER_DUP_UNIQUE";
    codes[1170] = "ER_BLOB_KEY_WITHOUT_LENGTH";
    codes[1171] = "ER_PRIMARY_CANT_HAVE_NULL";
    codes[1172] = "ER_TOO_MANY_ROWS";
    codes[1173] = "ER_REQUIRES_PRIMARY_KEY";
    codes[1174] = "ER_NO_RAID_COMPILED";
    codes[1175] = "ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE";
    codes[1176] = "ER_KEY_DOES_NOT_EXISTS";
    codes[1177] = "ER_CHECK_NO_SUCH_TABLE";
    codes[1178] = "ER_CHECK_NOT_IMPLEMENTED";
    codes[1179] = "ER_CANT_DO_THIS_DURING_AN_TRANSACTION";
    codes[1180] = "ER_ERROR_DURING_COMMIT";
    codes[1181] = "ER_ERROR_DURING_ROLLBACK";
    codes[1182] = "ER_ERROR_DURING_FLUSH_LOGS";
    codes[1183] = "ER_ERROR_DURING_CHECKPOINT";
    codes[1184] = "ER_NEW_ABORTING_CONNECTION";
    codes[1185] = "ER_UNUSED_10";
    codes[1186] = "ER_FLUSH_MASTER_BINLOG_CLOSED";
    codes[1187] = "ER_INDEX_REBUILD";
    codes[1188] = "ER_MASTER";
    codes[1189] = "ER_MASTER_NET_READ";
    codes[1190] = "ER_MASTER_NET_WRITE";
    codes[1191] = "ER_FT_MATCHING_KEY_NOT_FOUND";
    codes[1192] = "ER_LOCK_OR_ACTIVE_TRANSACTION";
    codes[1193] = "ER_UNKNOWN_SYSTEM_VARIABLE";
    codes[1194] = "ER_CRASHED_ON_USAGE";
    codes[1195] = "ER_CRASHED_ON_REPAIR";
    codes[1196] = "ER_WARNING_NOT_COMPLETE_ROLLBACK";
    codes[1197] = "ER_TRANS_CACHE_FULL";
    codes[1198] = "ER_SLAVE_MUST_STOP";
    codes[1199] = "ER_SLAVE_NOT_RUNNING";
    codes[1200] = "ER_BAD_SLAVE";
    codes[1201] = "ER_MASTER_INFO";
    codes[1202] = "ER_SLAVE_THREAD";
    codes[1203] = "ER_TOO_MANY_USER_CONNECTIONS";
    codes[1204] = "ER_SET_CONSTANTS_ONLY";
    codes[1205] = "ER_LOCK_WAIT_TIMEOUT";
    codes[1206] = "ER_LOCK_TABLE_FULL";
    codes[1207] = "ER_READ_ONLY_TRANSACTION";
    codes[1208] = "ER_DROP_DB_WITH_READ_LOCK";
    codes[1209] = "ER_CREATE_DB_WITH_READ_LOCK";
    codes[1210] = "ER_WRONG_ARGUMENTS";
    codes[1211] = "ER_NO_PERMISSION_TO_CREATE_USER";
    codes[1212] = "ER_UNION_TABLES_IN_DIFFERENT_DIR";
    codes[1213] = "ER_LOCK_DEADLOCK";
    codes[1214] = "ER_TABLE_CANT_HANDLE_FT";
    codes[1215] = "ER_CANNOT_ADD_FOREIGN";
    codes[1216] = "ER_NO_REFERENCED_ROW";
    codes[1217] = "ER_ROW_IS_REFERENCED";
    codes[1218] = "ER_CONNECT_TO_MASTER";
    codes[1219] = "ER_QUERY_ON_MASTER";
    codes[1220] = "ER_ERROR_WHEN_EXECUTING_COMMAND";
    codes[1221] = "ER_WRONG_USAGE";
    codes[1222] = "ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT";
    codes[1223] = "ER_CANT_UPDATE_WITH_READLOCK";
    codes[1224] = "ER_MIXING_NOT_ALLOWED";
    codes[1225] = "ER_DUP_ARGUMENT";
    codes[1226] = "ER_USER_LIMIT_REACHED";
    codes[1227] = "ER_SPECIFIC_ACCESS_DENIED_ERROR";
    codes[1228] = "ER_LOCAL_VARIABLE";
    codes[1229] = "ER_GLOBAL_VARIABLE";
    codes[1230] = "ER_NO_DEFAULT";
    codes[1231] = "ER_WRONG_VALUE_FOR_VAR";
    codes[1232] = "ER_WRONG_TYPE_FOR_VAR";
    codes[1233] = "ER_VAR_CANT_BE_READ";
    codes[1234] = "ER_CANT_USE_OPTION_HERE";
    codes[1235] = "ER_NOT_SUPPORTED_YET";
    codes[1236] = "ER_MASTER_FATAL_ERROR_READING_BINLOG";
    codes[1237] = "ER_SLAVE_IGNORED_TABLE";
    codes[1238] = "ER_INCORRECT_GLOBAL_LOCAL_VAR";
    codes[1239] = "ER_WRONG_FK_DEF";
    codes[1240] = "ER_KEY_REF_DO_NOT_MATCH_TABLE_REF";
    codes[1241] = "ER_OPERAND_COLUMNS";
    codes[1242] = "ER_SUBQUERY_NO_1_ROW";
    codes[1243] = "ER_UNKNOWN_STMT_HANDLER";
    codes[1244] = "ER_CORRUPT_HELP_DB";
    codes[1245] = "ER_CYCLIC_REFERENCE";
    codes[1246] = "ER_AUTO_CONVERT";
    codes[1247] = "ER_ILLEGAL_REFERENCE";
    codes[1248] = "ER_DERIVED_MUST_HAVE_ALIAS";
    codes[1249] = "ER_SELECT_REDUCED";
    codes[1250] = "ER_TABLENAME_NOT_ALLOWED_HERE";
    codes[1251] = "ER_NOT_SUPPORTED_AUTH_MODE";
    codes[1252] = "ER_SPATIAL_CANT_HAVE_NULL";
    codes[1253] = "ER_COLLATION_CHARSET_MISMATCH";
    codes[1254] = "ER_SLAVE_WAS_RUNNING";
    codes[1255] = "ER_SLAVE_WAS_NOT_RUNNING";
    codes[1256] = "ER_TOO_BIG_FOR_UNCOMPRESS";
    codes[1257] = "ER_ZLIB_Z_MEM_ERROR";
    codes[1258] = "ER_ZLIB_Z_BUF_ERROR";
    codes[1259] = "ER_ZLIB_Z_DATA_ERROR";
    codes[1260] = "ER_CUT_VALUE_GROUP_CONCAT";
    codes[1261] = "ER_WARN_TOO_FEW_RECORDS";
    codes[1262] = "ER_WARN_TOO_MANY_RECORDS";
    codes[1263] = "ER_WARN_NULL_TO_NOTNULL";
    codes[1264] = "ER_WARN_DATA_OUT_OF_RANGE";
    codes[1265] = "WARN_DATA_TRUNCATED";
    codes[1266] = "ER_WARN_USING_OTHER_HANDLER";
    codes[1267] = "ER_CANT_AGGREGATE_2COLLATIONS";
    codes[1268] = "ER_DROP_USER";
    codes[1269] = "ER_REVOKE_GRANTS";
    codes[1270] = "ER_CANT_AGGREGATE_3COLLATIONS";
    codes[1271] = "ER_CANT_AGGREGATE_NCOLLATIONS";
    codes[1272] = "ER_VARIABLE_IS_NOT_STRUCT";
    codes[1273] = "ER_UNKNOWN_COLLATION";
    codes[1274] = "ER_SLAVE_IGNORED_SSL_PARAMS";
    codes[1275] = "ER_SERVER_IS_IN_SECURE_AUTH_MODE";
    codes[1276] = "ER_WARN_FIELD_RESOLVED";
    codes[1277] = "ER_BAD_SLAVE_UNTIL_COND";
    codes[1278] = "ER_MISSING_SKIP_SLAVE";
    codes[1279] = "ER_UNTIL_COND_IGNORED";
    codes[1280] = "ER_WRONG_NAME_FOR_INDEX";
    codes[1281] = "ER_WRONG_NAME_FOR_CATALOG";
    codes[1282] = "ER_WARN_QC_RESIZE";
    codes[1283] = "ER_BAD_FT_COLUMN";
    codes[1284] = "ER_UNKNOWN_KEY_CACHE";
    codes[1285] = "ER_WARN_HOSTNAME_WONT_WORK";
    codes[1286] = "ER_UNKNOWN_STORAGE_ENGINE";
    codes[1287] = "ER_WARN_DEPRECATED_SYNTAX";
    codes[1288] = "ER_NON_UPDATABLE_TABLE";
    codes[1289] = "ER_FEATURE_DISABLED";
    codes[1290] = "ER_OPTION_PREVENTS_STATEMENT";
    codes[1291] = "ER_DUPLICATED_VALUE_IN_TYPE";
    codes[1292] = "ER_TRUNCATED_WRONG_VALUE";
    codes[1293] = "ER_TOO_MUCH_AUTO_TIMESTAMP_COLS";
    codes[1294] = "ER_INVALID_ON_UPDATE";
    codes[1295] = "ER_UNSUPPORTED_PS";
    codes[1296] = "ER_GET_ERRMSG";
    codes[1297] = "ER_GET_TEMPORARY_ERRMSG";
    codes[1298] = "ER_UNKNOWN_TIME_ZONE";
    codes[1299] = "ER_WARN_INVALID_TIMESTAMP";
    codes[1300] = "ER_INVALID_CHARACTER_STRING";
    codes[1301] = "ER_WARN_ALLOWED_PACKET_OVERFLOWED";
    codes[1302] = "ER_CONFLICTING_DECLARATIONS";
    codes[1303] = "ER_SP_NO_RECURSIVE_CREATE";
    codes[1304] = "ER_SP_ALREADY_EXISTS";
    codes[1305] = "ER_SP_DOES_NOT_EXIST";
    codes[1306] = "ER_SP_DROP_FAILED";
    codes[1307] = "ER_SP_STORE_FAILED";
    codes[1308] = "ER_SP_LILABEL_MISMATCH";
    codes[1309] = "ER_SP_LABEL_REDEFINE";
    codes[1310] = "ER_SP_LABEL_MISMATCH";
    codes[1311] = "ER_SP_UNINIT_VAR";
    codes[1312] = "ER_SP_BADSELECT";
    codes[1313] = "ER_SP_BADRETURN";
    codes[1314] = "ER_SP_BADSTATEMENT";
    codes[1315] = "ER_UPDATE_LOG_DEPRECATED_IGNORED";
    codes[1316] = "ER_UPDATE_LOG_DEPRECATED_TRANSLATED";
    codes[1317] = "ER_QUERY_INTERRUPTED";
    codes[1318] = "ER_SP_WRONG_NO_OF_ARGS";
    codes[1319] = "ER_SP_COND_MISMATCH";
    codes[1320] = "ER_SP_NORETURN";
    codes[1321] = "ER_SP_NORETURNEND";
    codes[1322] = "ER_SP_BAD_CURSOR_QUERY";
    codes[1323] = "ER_SP_BAD_CURSOR_SELECT";
    codes[1324] = "ER_SP_CURSOR_MISMATCH";
    codes[1325] = "ER_SP_CURSOR_ALREADY_OPEN";
    codes[1326] = "ER_SP_CURSOR_NOT_OPEN";
    codes[1327] = "ER_SP_UNDECLARED_VAR";
    codes[1328] = "ER_SP_WRONG_NO_OF_FETCH_ARGS";
    codes[1329] = "ER_SP_FETCH_NO_DATA";
    codes[1330] = "ER_SP_DUP_PARAM";
    codes[1331] = "ER_SP_DUP_VAR";
    codes[1332] = "ER_SP_DUP_COND";
    codes[1333] = "ER_SP_DUP_CURS";
    codes[1334] = "ER_SP_CANT_ALTER";
    codes[1335] = "ER_SP_SUBSELECT_NYI";
    codes[1336] = "ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG";
    codes[1337] = "ER_SP_VARCOND_AFTER_CURSHNDLR";
    codes[1338] = "ER_SP_CURSOR_AFTER_HANDLER";
    codes[1339] = "ER_SP_CASE_NOT_FOUND";
    codes[1340] = "ER_FPARSER_TOO_BIG_FILE";
    codes[1341] = "ER_FPARSER_BAD_HEADER";
    codes[1342] = "ER_FPARSER_EOF_IN_COMMENT";
    codes[1343] = "ER_FPARSER_ERROR_IN_PARAMETER";
    codes[1344] = "ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER";
    codes[1345] = "ER_VIEW_NO_EXPLAIN";
    codes[1346] = "ER_FRM_UNKNOWN_TYPE";
    codes[1347] = "ER_WRONG_OBJECT";
    codes[1348] = "ER_NONUPDATEABLE_COLUMN";
    codes[1349] = "ER_VIEW_SELECT_DERIVED";
    codes[1350] = "ER_VIEW_SELECT_CLAUSE";
    codes[1351] = "ER_VIEW_SELECT_VARIABLE";
    codes[1352] = "ER_VIEW_SELECT_TMPTABLE";
    codes[1353] = "ER_VIEW_WRONG_LIST";
    codes[1354] = "ER_WARN_VIEW_MERGE";
    codes[1355] = "ER_WARN_VIEW_WITHOUT_KEY";
    codes[1356] = "ER_VIEW_INVALID";
    codes[1357] = "ER_SP_NO_DROP_SP";
    codes[1358] = "ER_SP_GOTO_IN_HNDLR";
    codes[1359] = "ER_TRG_ALREADY_EXISTS";
    codes[1360] = "ER_TRG_DOES_NOT_EXIST";
    codes[1361] = "ER_TRG_ON_VIEW_OR_TEMP_TABLE";
    codes[1362] = "ER_TRG_CANT_CHANGE_ROW";
    codes[1363] = "ER_TRG_NO_SUCH_ROW_IN_TRG";
    codes[1364] = "ER_NO_DEFAULT_FOR_FIELD";
    codes[1365] = "ER_DIVISION_BY_ZERO";
    codes[1366] = "ER_TRUNCATED_WRONG_VALUE_FOR_FIELD";
    codes[1367] = "ER_ILLEGAL_VALUE_FOR_TYPE";
    codes[1368] = "ER_VIEW_NONUPD_CHECK";
    codes[1369] = "ER_VIEW_CHECK_FAILED";
    codes[1370] = "ER_PROCACCESS_DENIED_ERROR";
    codes[1371] = "ER_RELAY_LOG_FAIL";
    codes[1372] = "ER_PASSWD_LENGTH";
    codes[1373] = "ER_UNKNOWN_TARGET_BINLOG";
    codes[1374] = "ER_IO_ERR_LOG_INDEX_READ";
    codes[1375] = "ER_BINLOG_PURGE_PROHIBITED";
    codes[1376] = "ER_FSEEK_FAIL";
    codes[1377] = "ER_BINLOG_PURGE_FATAL_ERR";
    codes[1378] = "ER_LOG_IN_USE";
    codes[1379] = "ER_LOG_PURGE_UNKNOWN_ERR";
    codes[1380] = "ER_RELAY_LOG_INIT";
    codes[1381] = "ER_NO_BINARY_LOGGING";
    codes[1382] = "ER_RESERVED_SYNTAX";
    codes[1383] = "ER_WSAS_FAILED";
    codes[1384] = "ER_DIFF_GROUPS_PROC";
    codes[1385] = "ER_NO_GROUP_FOR_PROC";
    codes[1386] = "ER_ORDER_WITH_PROC";
    codes[1387] = "ER_LOGGING_PROHIBIT_CHANGING_OF";
    codes[1388] = "ER_NO_FILE_MAPPING";
    codes[1389] = "ER_WRONG_MAGIC";
    codes[1390] = "ER_PS_MANY_PARAM";
    codes[1391] = "ER_KEY_PART_0";
    codes[1392] = "ER_VIEW_CHECKSUM";
    codes[1393] = "ER_VIEW_MULTIUPDATE";
    codes[1394] = "ER_VIEW_NO_INSERT_FIELD_LIST";
    codes[1395] = "ER_VIEW_DELETE_MERGE_VIEW";
    codes[1396] = "ER_CANNOT_USER";
    codes[1397] = "ER_XAER_NOTA";
    codes[1398] = "ER_XAER_INVAL";
    codes[1399] = "ER_XAER_RMFAIL";
    codes[1400] = "ER_XAER_OUTSIDE";
    codes[1401] = "ER_XAER_RMERR";
    codes[1402] = "ER_XA_RBROLLBACK";
    codes[1403] = "ER_NONEXISTING_PROC_GRANT";
    codes[1404] = "ER_PROC_AUTO_GRANT_FAIL";
    codes[1405] = "ER_PROC_AUTO_REVOKE_FAIL";
    codes[1406] = "ER_DATA_TOO_LONG";
    codes[1407] = "ER_SP_BAD_SQLSTATE";
    codes[1408] = "ER_STARTUP";
    codes[1409] = "ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR";
    codes[1410] = "ER_CANT_CREATE_USER_WITH_GRANT";
    codes[1411] = "ER_WRONG_VALUE_FOR_TYPE";
    codes[1412] = "ER_TABLE_DEF_CHANGED";
    codes[1413] = "ER_SP_DUP_HANDLER";
    codes[1414] = "ER_SP_NOT_VAR_ARG";
    codes[1415] = "ER_SP_NO_RETSET";
    codes[1416] = "ER_CANT_CREATE_GEOMETRY_OBJECT";
    codes[1417] = "ER_FAILED_ROUTINE_BREAK_BINLOG";
    codes[1418] = "ER_BINLOG_UNSAFE_ROUTINE";
    codes[1419] = "ER_BINLOG_CREATE_ROUTINE_NEED_SUPER";
    codes[1420] = "ER_EXEC_STMT_WITH_OPEN_CURSOR";
    codes[1421] = "ER_STMT_HAS_NO_OPEN_CURSOR";
    codes[1422] = "ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG";
    codes[1423] = "ER_NO_DEFAULT_FOR_VIEW_FIELD";
    codes[1424] = "ER_SP_NO_RECURSION";
    codes[1425] = "ER_TOO_BIG_SCALE";
    codes[1426] = "ER_TOO_BIG_PRECISION";
    codes[1427] = "ER_M_BIGGER_THAN_D";
    codes[1428] = "ER_WRONG_LOCK_OF_SYSTEM_TABLE";
    codes[1429] = "ER_CONNECT_TO_FOREIGN_DATA_SOURCE";
    codes[1430] = "ER_QUERY_ON_FOREIGN_DATA_SOURCE";
    codes[1431] = "ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST";
    codes[1432] = "ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE";
    codes[1433] = "ER_FOREIGN_DATA_STRING_INVALID";
    codes[1434] = "ER_CANT_CREATE_FEDERATED_TABLE";
    codes[1435] = "ER_TRG_IN_WRONG_SCHEMA";
    codes[1436] = "ER_STACK_OVERRUN_NEED_MORE";
    codes[1437] = "ER_TOO_LONG_BODY";
    codes[1438] = "ER_WARN_CANT_DROP_DEFAULT_KEYCACHE";
    codes[1439] = "ER_TOO_BIG_DISPLAYWIDTH";
    codes[1440] = "ER_XAER_DUPID";
    codes[1441] = "ER_DATETIME_FUNCTION_OVERFLOW";
    codes[1442] = "ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG";
    codes[1443] = "ER_VIEW_PREVENT_UPDATE";
    codes[1444] = "ER_PS_NO_RECURSION";
    codes[1445] = "ER_SP_CANT_SET_AUTOCOMMIT";
    codes[1446] = "ER_MALFORMED_DEFINER";
    codes[1447] = "ER_VIEW_FRM_NO_USER";
    codes[1448] = "ER_VIEW_OTHER_USER";
    codes[1449] = "ER_NO_SUCH_USER";
    codes[1450] = "ER_FORBID_SCHEMA_CHANGE";
    codes[1451] = "ER_ROW_IS_REFERENCED_2";
    codes[1452] = "ER_NO_REFERENCED_ROW_2";
    codes[1453] = "ER_SP_BAD_VAR_SHADOW";
    codes[1454] = "ER_TRG_NO_DEFINER";
    codes[1455] = "ER_OLD_FILE_FORMAT";
    codes[1456] = "ER_SP_RECURSION_LIMIT";
    codes[1457] = "ER_SP_PROC_TABLE_CORRUPT";
    codes[1458] = "ER_SP_WRONG_NAME";
    codes[1459] = "ER_TABLE_NEEDS_UPGRADE";
    codes[1460] = "ER_SP_NO_AGGREGATE";
    codes[1461] = "ER_MAX_PREPARED_STMT_COUNT_REACHED";
    codes[1462] = "ER_VIEW_RECURSIVE";
    codes[1463] = "ER_NON_GROUPING_FIELD_USED";
    codes[1464] = "ER_TABLE_CANT_HANDLE_SPKEYS";
    codes[1465] = "ER_NO_TRIGGERS_ON_SYSTEM_SCHEMA";
    codes[1466] = "ER_REMOVED_SPACES";
    codes[1467] = "ER_AUTOINC_READ_FAILED";
    codes[1468] = "ER_USERNAME";
    codes[1469] = "ER_HOSTNAME";
    codes[1470] = "ER_WRONG_STRING_LENGTH";
    codes[1471] = "ER_NON_INSERTABLE_TABLE";
    codes[1472] = "ER_ADMIN_WRONG_MRG_TABLE";
    codes[1473] = "ER_TOO_HIGH_LEVEL_OF_NESTING_FOR_SELECT";
    codes[1474] = "ER_NAME_BECOMES_EMPTY";
    codes[1475] = "ER_AMBIGUOUS_FIELD_TERM";
    codes[1476] = "ER_FOREIGN_SERVER_EXISTS";
    codes[1477] = "ER_FOREIGN_SERVER_DOESNT_EXIST";
    codes[1478] = "ER_ILLEGAL_HA_CREATE_OPTION";
    codes[1479] = "ER_PARTITION_REQUIRES_VALUES_ERROR";
    codes[1480] = "ER_PARTITION_WRONG_VALUES_ERROR";
    codes[1481] = "ER_PARTITION_MAXVALUE_ERROR";
    codes[1482] = "ER_PARTITION_SUBPARTITION_ERROR";
    codes[1483] = "ER_PARTITION_SUBPART_MIX_ERROR";
    codes[1484] = "ER_PARTITION_WRONG_NO_PART_ERROR";
    codes[1485] = "ER_PARTITION_WRONG_NO_SUBPART_ERROR";
    codes[1486] = "ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR";
    codes[1487] = "ER_NOT_CONSTANT_EXPRESSION";
    codes[1488] = "ER_FIELD_NOT_FOUND_PART_ERROR";
    codes[1489] = "ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR";
    codes[1490] = "ER_INCONSISTENT_PARTITION_INFO_ERROR";
    codes[1491] = "ER_PARTITION_FUNC_NOT_ALLOWED_ERROR";
    codes[1492] = "ER_PARTITIONS_MUST_BE_DEFINED_ERROR";
    codes[1493] = "ER_RANGE_NOT_INCREASING_ERROR";
    codes[1494] = "ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR";
    codes[1495] = "ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR";
    codes[1496] = "ER_PARTITION_ENTRY_ERROR";
    codes[1497] = "ER_MIX_HANDLER_ERROR";
    codes[1498] = "ER_PARTITION_NOT_DEFINED_ERROR";
    codes[1499] = "ER_TOO_MANY_PARTITIONS_ERROR";
    codes[1500] = "ER_SUBPARTITION_ERROR";
    codes[1501] = "ER_CANT_CREATE_HANDLER_FILE";
    codes[1502] = "ER_BLOB_FIELD_IN_PART_FUNC_ERROR";
    codes[1503] = "ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF";
    codes[1504] = "ER_NO_PARTS_ERROR";
    codes[1505] = "ER_PARTITION_MGMT_ON_NONPARTITIONED";
    codes[1506] = "ER_FEATURE_NOT_SUPPORTED_WITH_PARTITIONING";
    codes[1507] = "ER_PARTITION_DOES_NOT_EXIST";
    codes[1508] = "ER_DROP_LAST_PARTITION";
    codes[1509] = "ER_COALESCE_ONLY_ON_HASH_PARTITION";
    codes[1510] = "ER_REORG_HASH_ONLY_ON_SAME_NO";
    codes[1511] = "ER_REORG_NO_PARAM_ERROR";
    codes[1512] = "ER_ONLY_ON_RANGE_LIST_PARTITION";
    codes[1513] = "ER_ADD_PARTITION_SUBPART_ERROR";
    codes[1514] = "ER_ADD_PARTITION_NO_NEW_PARTITION";
    codes[1515] = "ER_COALESCE_PARTITION_NO_PARTITION";
    codes[1516] = "ER_REORG_PARTITION_NOT_EXIST";
    codes[1517] = "ER_SAME_NAME_PARTITION";
    codes[1518] = "ER_NO_BINLOG_ERROR";
    codes[1519] = "ER_CONSECUTIVE_REORG_PARTITIONS";
    codes[1520] = "ER_REORG_OUTSIDE_RANGE";
    codes[1521] = "ER_PARTITION_FUNCTION_FAILURE";
    codes[1522] = "ER_PART_STATE_ERROR";
    codes[1523] = "ER_LIMITED_PART_RANGE";
    codes[1524] = "ER_PLUGIN_IS_NOT_LOADED";
    codes[1525] = "ER_WRONG_VALUE";
    codes[1526] = "ER_NO_PARTITION_FOR_GIVEN_VALUE";
    codes[1527] = "ER_FILEGROUP_OPTION_ONLY_ONCE";
    codes[1528] = "ER_CREATE_FILEGROUP_FAILED";
    codes[1529] = "ER_DROP_FILEGROUP_FAILED";
    codes[1530] = "ER_TABLESPACE_AUTO_EXTEND_ERROR";
    codes[1531] = "ER_WRONG_SIZE_NUMBER";
    codes[1532] = "ER_SIZE_OVERFLOW_ERROR";
    codes[1533] = "ER_ALTER_FILEGROUP_FAILED";
    codes[1534] = "ER_BINLOG_ROW_LOGGING_FAILED";
    codes[1535] = "ER_BINLOG_ROW_WRONG_TABLE_DEF";
    codes[1536] = "ER_BINLOG_ROW_RBR_TO_SBR";
    codes[1537] = "ER_EVENT_ALREADY_EXISTS";
    codes[1538] = "ER_EVENT_STORE_FAILED";
    codes[1539] = "ER_EVENT_DOES_NOT_EXIST";
    codes[1540] = "ER_EVENT_CANT_ALTER";
    codes[1541] = "ER_EVENT_DROP_FAILED";
    codes[1542] = "ER_EVENT_INTERVAL_NOT_POSITIVE_OR_TOO_BIG";
    codes[1543] = "ER_EVENT_ENDS_BEFORE_STARTS";
    codes[1544] = "ER_EVENT_EXEC_TIME_IN_THE_PAST";
    codes[1545] = "ER_EVENT_OPEN_TABLE_FAILED";
    codes[1546] = "ER_EVENT_NEITHER_M_EXPR_NOR_M_AT";
    codes[1547] = "ER_UNUSED_2";
    codes[1548] = "ER_UNUSED_3";
    codes[1549] = "ER_EVENT_CANNOT_DELETE";
    codes[1550] = "ER_EVENT_COMPILE_ERROR";
    codes[1551] = "ER_EVENT_SAME_NAME";
    codes[1552] = "ER_EVENT_DATA_TOO_LONG";
    codes[1553] = "ER_DROP_INDEX_FK";
    codes[1554] = "ER_WARN_DEPRECATED_SYNTAX_WITH_VER";
    codes[1555] = "ER_CANT_WRITE_LOCK_LOG_TABLE";
    codes[1556] = "ER_CANT_LOCK_LOG_TABLE";
    codes[1557] = "ER_UNUSED_4";
    codes[1558] = "ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE";
    codes[1559] = "ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR";
    codes[1560] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT";
    codes[1561] = "ER_UNUSED_13";
    codes[1562] = "ER_PARTITION_NO_TEMPORARY";
    codes[1563] = "ER_PARTITION_CONST_DOMAIN_ERROR";
    codes[1564] = "ER_PARTITION_FUNCTION_IS_NOT_ALLOWED";
    codes[1565] = "ER_DDL_LOG_ERROR";
    codes[1566] = "ER_NULL_IN_VALUES_LESS_THAN";
    codes[1567] = "ER_WRONG_PARTITION_NAME";
    codes[1568] = "ER_CANT_CHANGE_TX_CHARACTERISTICS";
    codes[1569] = "ER_DUP_ENTRY_AUTOINCREMENT_CASE";
    codes[1570] = "ER_EVENT_MODIFY_QUEUE_ERROR";
    codes[1571] = "ER_EVENT_SET_VAR_ERROR";
    codes[1572] = "ER_PARTITION_MERGE_ERROR";
    codes[1573] = "ER_CANT_ACTIVATE_LOG";
    codes[1574] = "ER_RBR_NOT_AVAILABLE";
    codes[1575] = "ER_BASE64_DECODE_ERROR";
    codes[1576] = "ER_EVENT_RECURSION_FORBIDDEN";
    codes[1577] = "ER_EVENTS_DB_ERROR";
    codes[1578] = "ER_ONLY_INTEGERS_ALLOWED";
    codes[1579] = "ER_UNSUPORTED_LOG_ENGINE";
    codes[1580] = "ER_BAD_LOG_STATEMENT";
    codes[1581] = "ER_CANT_RENAME_LOG_TABLE";
    codes[1582] = "ER_WRONG_PARAMCOUNT_TO_NATIVE_FCT";
    codes[1583] = "ER_WRONG_PARAMETERS_TO_NATIVE_FCT";
    codes[1584] = "ER_WRONG_PARAMETERS_TO_STORED_FCT";
    codes[1585] = "ER_NATIVE_FCT_NAME_COLLISION";
    codes[1586] = "ER_DUP_ENTRY_WITH_KEY_NAME";
    codes[1587] = "ER_BINLOG_PURGE_EMFILE";
    codes[1588] = "ER_EVENT_CANNOT_CREATE_IN_THE_PAST";
    codes[1589] = "ER_EVENT_CANNOT_ALTER_IN_THE_PAST";
    codes[1590] = "ER_SLAVE_INCIDENT";
    codes[1591] = "ER_NO_PARTITION_FOR_GIVEN_VALUE_SILENT";
    codes[1592] = "ER_BINLOG_UNSAFE_STATEMENT";
    codes[1593] = "ER_SLAVE_FATAL_ERROR";
    codes[1594] = "ER_SLAVE_RELAY_LOG_READ_FAILURE";
    codes[1595] = "ER_SLAVE_RELAY_LOG_WRITE_FAILURE";
    codes[1596] = "ER_SLAVE_CREATE_EVENT_FAILURE";
    codes[1597] = "ER_SLAVE_MASTER_COM_FAILURE";
    codes[1598] = "ER_BINLOG_LOGGING_IMPOSSIBLE";
    codes[1599] = "ER_VIEW_NO_CREATION_CTX";
    codes[1600] = "ER_VIEW_INVALID_CREATION_CTX";
    codes[1601] = "ER_SR_INVALID_CREATION_CTX";
    codes[1602] = "ER_TRG_CORRUPTED_FILE";
    codes[1603] = "ER_TRG_NO_CREATION_CTX";
    codes[1604] = "ER_TRG_INVALID_CREATION_CTX";
    codes[1605] = "ER_EVENT_INVALID_CREATION_CTX";
    codes[1606] = "ER_TRG_CANT_OPEN_TABLE";
    codes[1607] = "ER_CANT_CREATE_SROUTINE";
    codes[1608] = "ER_UNUSED_11";
    codes[1609] = "ER_NO_FORMAT_DESCRIPTION_EVENT_BEFORE_BINLOG_STATEMENT";
    codes[1610] = "ER_SLAVE_CORRUPT_EVENT";
    codes[1611] = "ER_LOAD_DATA_INVALID_COLUMN";
    codes[1612] = "ER_LOG_PURGE_NO_FILE";
    codes[1613] = "ER_XA_RBTIMEOUT";
    codes[1614] = "ER_XA_RBDEADLOCK";
    codes[1615] = "ER_NEED_REPREPARE";
    codes[1616] = "ER_DELAYED_NOT_SUPPORTED";
    codes[1617] = "WARN_NO_MASTER_INFO";
    codes[1618] = "WARN_OPTION_IGNORED";
    codes[1619] = "ER_PLUGIN_DELETE_BUILTIN";
    codes[1620] = "WARN_PLUGIN_BUSY";
    codes[1621] = "ER_VARIABLE_IS_READONLY";
    codes[1622] = "ER_WARN_ENGINE_TRANSACTION_ROLLBACK";
    codes[1623] = "ER_SLAVE_HEARTBEAT_FAILURE";
    codes[1624] = "ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE";
    codes[1625] = "ER_UNUSED_14";
    codes[1626] = "ER_CONFLICT_FN_PARSE_ERROR";
    codes[1627] = "ER_EXCEPTIONS_WRITE_ERROR";
    codes[1628] = "ER_TOO_LONG_TABLE_COMMENT";
    codes[1629] = "ER_TOO_LONG_FIELD_COMMENT";
    codes[1630] = "ER_FUNC_INEXISTENT_NAME_COLLISION";
    codes[1631] = "ER_DATABASE_NAME";
    codes[1632] = "ER_TABLE_NAME";
    codes[1633] = "ER_PARTITION_NAME";
    codes[1634] = "ER_SUBPARTITION_NAME";
    codes[1635] = "ER_TEMPORARY_NAME";
    codes[1636] = "ER_RENAMED_NAME";
    codes[1637] = "ER_TOO_MANY_CONCURRENT_TRXS";
    codes[1638] = "WARN_NON_ASCII_SEPARATOR_NOT_IMPLEMENTED";
    codes[1639] = "ER_DEBUG_SYNC_TIMEOUT";
    codes[1640] = "ER_DEBUG_SYNC_HIT_LIMIT";
    codes[1641] = "ER_DUP_SIGNAL_SET";
    codes[1642] = "ER_SIGNAL_WARN";
    codes[1643] = "ER_SIGNAL_NOT_FOUND";
    codes[1644] = "ER_SIGNAL_EXCEPTION";
    codes[1645] = "ER_RESIGNAL_WITHOUT_ACTIVE_HANDLER";
    codes[1646] = "ER_SIGNAL_BAD_CONDITION_TYPE";
    codes[1647] = "WARN_COND_ITEM_TRUNCATED";
    codes[1648] = "ER_COND_ITEM_TOO_LONG";
    codes[1649] = "ER_UNKNOWN_LOCALE";
    codes[1650] = "ER_SLAVE_IGNORE_SERVER_IDS";
    codes[1651] = "ER_QUERY_CACHE_DISABLED";
    codes[1652] = "ER_SAME_NAME_PARTITION_FIELD";
    codes[1653] = "ER_PARTITION_COLUMN_LIST_ERROR";
    codes[1654] = "ER_WRONG_TYPE_COLUMN_VALUE_ERROR";
    codes[1655] = "ER_TOO_MANY_PARTITION_FUNC_FIELDS_ERROR";
    codes[1656] = "ER_MAXVALUE_IN_VALUES_IN";
    codes[1657] = "ER_TOO_MANY_VALUES_ERROR";
    codes[1658] = "ER_ROW_SINGLE_PARTITION_FIELD_ERROR";
    codes[1659] = "ER_FIELD_TYPE_NOT_ALLOWED_AS_PARTITION_FIELD";
    codes[1660] = "ER_PARTITION_FIELDS_TOO_LONG";
    codes[1661] = "ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE";
    codes[1662] = "ER_BINLOG_ROW_MODE_AND_STMT_ENGINE";
    codes[1663] = "ER_BINLOG_UNSAFE_AND_STMT_ENGINE";
    codes[1664] = "ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE";
    codes[1665] = "ER_BINLOG_STMT_MODE_AND_ROW_ENGINE";
    codes[1666] = "ER_BINLOG_ROW_INJECTION_AND_STMT_MODE";
    codes[1667] = "ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE";
    codes[1668] = "ER_BINLOG_UNSAFE_LIMIT";
    codes[1669] = "ER_BINLOG_UNSAFE_INSERT_DELAYED";
    codes[1670] = "ER_BINLOG_UNSAFE_SYSTEM_TABLE";
    codes[1671] = "ER_BINLOG_UNSAFE_AUTOINC_COLUMNS";
    codes[1672] = "ER_BINLOG_UNSAFE_UDF";
    codes[1673] = "ER_BINLOG_UNSAFE_SYSTEM_VARIABLE";
    codes[1674] = "ER_BINLOG_UNSAFE_SYSTEM_FUNCTION";
    codes[1675] = "ER_BINLOG_UNSAFE_NONTRANS_AFTER_TRANS";
    codes[1676] = "ER_MESSAGE_AND_STATEMENT";
    codes[1677] = "ER_SLAVE_CONVERSION_FAILED";
    codes[1678] = "ER_SLAVE_CANT_CREATE_CONVERSION";
    codes[1679] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT";
    codes[1680] = "ER_PATH_LENGTH";
    codes[1681] = "ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT";
    codes[1682] = "ER_WRONG_NATIVE_TABLE_STRUCTURE";
    codes[1683] = "ER_WRONG_PERFSCHEMA_USAGE";
    codes[1684] = "ER_WARN_I_S_SKIPPED_TABLE";
    codes[1685] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT";
    codes[1686] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT";
    codes[1687] = "ER_SPATIAL_MUST_HAVE_GEOM_COL";
    codes[1688] = "ER_TOO_LONG_INDEX_COMMENT";
    codes[1689] = "ER_LOCK_ABORTED";
    codes[1690] = "ER_DATA_OUT_OF_RANGE";
    codes[1691] = "ER_WRONG_SPVAR_TYPE_IN_LIMIT";
    codes[1692] = "ER_BINLOG_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE";
    codes[1693] = "ER_BINLOG_UNSAFE_MIXED_STATEMENT";
    codes[1694] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN";
    codes[1695] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN";
    codes[1696] = "ER_FAILED_READ_FROM_PAR_FILE";
    codes[1697] = "ER_VALUES_IS_NOT_INT_TYPE_ERROR";
    codes[1698] = "ER_ACCESS_DENIED_NO_PASSWORD_ERROR";
    codes[1699] = "ER_SET_PASSWORD_AUTH_PLUGIN";
    codes[1700] = "ER_GRANT_PLUGIN_USER_EXISTS";
    codes[1701] = "ER_TRUNCATE_ILLEGAL_FK";
    codes[1702] = "ER_PLUGIN_IS_PERMANENT";
    codes[1703] = "ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MIN";
    codes[1704] = "ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX";
    codes[1705] = "ER_STMT_CACHE_FULL";
    codes[1706] = "ER_MULTI_UPDATE_KEY_CONFLICT";
    codes[1707] = "ER_TABLE_NEEDS_REBUILD";
    codes[1708] = "WARN_OPTION_BELOW_LIMIT";
    codes[1709] = "ER_INDEX_COLUMN_TOO_LONG";
    codes[1710] = "ER_ERROR_IN_TRIGGER_BODY";
    codes[1711] = "ER_ERROR_IN_UNKNOWN_TRIGGER_BODY";
    codes[1712] = "ER_INDEX_CORRUPT";
    codes[1713] = "ER_UNDO_RECORD_TOO_BIG";
    codes[1714] = "ER_BINLOG_UNSAFE_INSERT_IGNORE_SELECT";
    codes[1715] = "ER_BINLOG_UNSAFE_INSERT_SELECT_UPDATE";
    codes[1716] = "ER_BINLOG_UNSAFE_REPLACE_SELECT";
    codes[1717] = "ER_BINLOG_UNSAFE_CREATE_IGNORE_SELECT";
    codes[1718] = "ER_BINLOG_UNSAFE_CREATE_REPLACE_SELECT";
    codes[1719] = "ER_BINLOG_UNSAFE_UPDATE_IGNORE";
    codes[1720] = "ER_UNUSED_15";
    codes[1721] = "ER_UNUSED_16";
    codes[1722] = "ER_BINLOG_UNSAFE_WRITE_AUTOINC_SELECT";
    codes[1723] = "ER_BINLOG_UNSAFE_CREATE_SELECT_AUTOINC";
    codes[1724] = "ER_BINLOG_UNSAFE_INSERT_TWO_KEYS";
    codes[1725] = "ER_UNUSED_28";
    codes[1726] = "ER_VERS_NOT_ALLOWED";
    codes[1727] = "ER_BINLOG_UNSAFE_AUTOINC_NOT_FIRST";
    codes[1728] = "ER_CANNOT_LOAD_FROM_TABLE_V2";
    codes[1729] = "ER_MASTER_DELAY_VALUE_OUT_OF_RANGE";
    codes[1730] = "ER_ONLY_FD_AND_RBR_EVENTS_ALLOWED_IN_BINLOG_STATEMENT";
    codes[1731] = "ER_PARTITION_EXCHANGE_DIFFERENT_OPTION";
    codes[1732] = "ER_PARTITION_EXCHANGE_PART_TABLE";
    codes[1733] = "ER_PARTITION_EXCHANGE_TEMP_TABLE";
    codes[1734] = "ER_PARTITION_INSTEAD_OF_SUBPARTITION";
    codes[1735] = "ER_UNKNOWN_PARTITION";
    codes[1736] = "ER_TABLES_DIFFERENT_METADATA";
    codes[1737] = "ER_ROW_DOES_NOT_MATCH_PARTITION";
    codes[1738] = "ER_BINLOG_CACHE_SIZE_GREATER_THAN_MAX";
    codes[1739] = "ER_WARN_INDEX_NOT_APPLICABLE";
    codes[1740] = "ER_PARTITION_EXCHANGE_FOREIGN_KEY";
    codes[1741] = "ER_NO_SUCH_KEY_VALUE";
    codes[1742] = "ER_VALUE_TOO_LONG";
    codes[1743] = "ER_NETWORK_READ_EVENT_CHECKSUM_FAILURE";
    codes[1744] = "ER_BINLOG_READ_EVENT_CHECKSUM_FAILURE";
    codes[1745] = "ER_BINLOG_STMT_CACHE_SIZE_GREATER_THAN_MAX";
    codes[1746] = "ER_CANT_UPDATE_TABLE_IN_CREATE_TABLE_SELECT";
    codes[1747] = "ER_PARTITION_CLAUSE_ON_NONPARTITIONED";
    codes[1748] = "ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET";
    codes[1749] = "ER_UNUSED_5";
    codes[1750] = "ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE";
    codes[1751] = "ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_CREATED_TEMP_TABLE";
    codes[1752] = "ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_DROPPED_TEMP_TABLE";
    codes[1753] = "ER_MTS_FEATURE_IS_NOT_SUPPORTED";
    codes[1754] = "ER_MTS_UPDATED_DBS_GREATER_MAX";
    codes[1755] = "ER_MTS_CANT_PARALLEL";
    codes[1756] = "ER_MTS_INCONSISTENT_DATA";
    codes[1757] = "ER_FULLTEXT_NOT_SUPPORTED_WITH_PARTITIONING";
    codes[1758] = "ER_DA_INVALID_CONDITION_NUMBER";
    codes[1759] = "ER_INSECURE_PLAIN_TEXT";
    codes[1760] = "ER_INSECURE_CHANGE_MASTER";
    codes[1761] = "ER_FOREIGN_DUPLICATE_KEY_WITH_CHILD_INFO";
    codes[1762] = "ER_FOREIGN_DUPLICATE_KEY_WITHOUT_CHILD_INFO";
    codes[1763] = "ER_SQLTHREAD_WITH_SECURE_SLAVE";
    codes[1764] = "ER_TABLE_HAS_NO_FT";
    codes[1765] = "ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER";
    codes[1766] = "ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION";
    codes[1767] = "ER_GTID_NEXT_IS_NOT_IN_GTID_NEXT_LIST";
    codes[1768] = "ER_CANT_CHANGE_GTID_NEXT_IN_TRANSACTION_WHEN_GTID_NEXT_LIST_IS_NULL";
    codes[1769] = "ER_SET_STATEMENT_CANNOT_INVOKE_FUNCTION";
    codes[1770] = "ER_GTID_NEXT_CANT_BE_AUTOMATIC_IF_GTID_NEXT_LIST_IS_NON_NULL";
    codes[1771] = "ER_SKIPPING_LOGGED_TRANSACTION";
    codes[1772] = "ER_MALFORMED_GTID_SET_SPECIFICATION";
    codes[1773] = "ER_MALFORMED_GTID_SET_ENCODING";
    codes[1774] = "ER_MALFORMED_GTID_SPECIFICATION";
    codes[1775] = "ER_GNO_EXHAUSTED";
    codes[1776] = "ER_BAD_SLAVE_AUTO_POSITION";
    codes[1777] = "ER_AUTO_POSITION_REQUIRES_GTID_MODE_ON";
    codes[1778] = "ER_CANT_DO_IMPLICIT_COMMIT_IN_TRX_WHEN_GTID_NEXT_IS_SET";
    codes[1779] = "ER_GTID_MODE_2_OR_3_REQUIRES_ENFORCE_GTID_CONSISTENCY_ON";
    codes[1780] = "ER_GTID_MODE_REQUIRES_BINLOG";
    codes[1781] = "ER_CANT_SET_GTID_NEXT_TO_GTID_WHEN_GTID_MODE_IS_OFF";
    codes[1782] = "ER_CANT_SET_GTID_NEXT_TO_ANONYMOUS_WHEN_GTID_MODE_IS_ON";
    codes[1783] = "ER_CANT_SET_GTID_NEXT_LIST_TO_NON_NULL_WHEN_GTID_MODE_IS_OFF";
    codes[1784] = "ER_FOUND_GTID_EVENT_WHEN_GTID_MODE_IS_OFF";
    codes[1785] = "ER_GTID_UNSAFE_NON_TRANSACTIONAL_TABLE";
    codes[1786] = "ER_GTID_UNSAFE_CREATE_SELECT";
    codes[1787] = "ER_GTID_UNSAFE_CREATE_DROP_TEMPORARY_TABLE_IN_TRANSACTION";
    codes[1788] = "ER_GTID_MODE_CAN_ONLY_CHANGE_ONE_STEP_AT_A_TIME";
    codes[1789] = "ER_MASTER_HAS_PURGED_REQUIRED_GTIDS";
    codes[1790] = "ER_CANT_SET_GTID_NEXT_WHEN_OWNING_GTID";
    codes[1791] = "ER_UNKNOWN_EXPLAIN_FORMAT";
    codes[1792] = "ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION";
    codes[1793] = "ER_TOO_LONG_TABLE_PARTITION_COMMENT";
    codes[1794] = "ER_SLAVE_CONFIGURATION";
    codes[1795] = "ER_INNODB_FT_LIMIT";
    codes[1796] = "ER_INNODB_NO_FT_TEMP_TABLE";
    codes[1797] = "ER_INNODB_FT_WRONG_DOCID_COLUMN";
    codes[1798] = "ER_INNODB_FT_WRONG_DOCID_INDEX";
    codes[1799] = "ER_INNODB_ONLINE_LOG_TOO_BIG";
    codes[1800] = "ER_UNKNOWN_ALTER_ALGORITHM";
    codes[1801] = "ER_UNKNOWN_ALTER_LOCK";
    codes[1802] = "ER_MTS_CHANGE_MASTER_CANT_RUN_WITH_GAPS";
    codes[1803] = "ER_MTS_RECOVERY_FAILURE";
    codes[1804] = "ER_MTS_RESET_WORKERS";
    codes[1805] = "ER_COL_COUNT_DOESNT_MATCH_CORRUPTED_V2";
    codes[1806] = "ER_SLAVE_SILENT_RETRY_TRANSACTION";
    codes[1807] = "ER_UNUSED_22";
    codes[1808] = "ER_TABLE_SCHEMA_MISMATCH";
    codes[1809] = "ER_TABLE_IN_SYSTEM_TABLESPACE";
    codes[1810] = "ER_IO_READ_ERROR";
    codes[1811] = "ER_IO_WRITE_ERROR";
    codes[1812] = "ER_TABLESPACE_MISSING";
    codes[1813] = "ER_TABLESPACE_EXISTS";
    codes[1814] = "ER_TABLESPACE_DISCARDED";
    codes[1815] = "ER_INTERNAL_ERROR";
    codes[1816] = "ER_INNODB_IMPORT_ERROR";
    codes[1817] = "ER_INNODB_INDEX_CORRUPT";
    codes[1818] = "ER_INVALID_YEAR_COLUMN_LENGTH";
    codes[1819] = "ER_NOT_VALID_PASSWORD";
    codes[1820] = "ER_MUST_CHANGE_PASSWORD";
    codes[1821] = "ER_FK_NO_INDEX_CHILD";
    codes[1822] = "ER_FK_NO_INDEX_PARENT";
    codes[1823] = "ER_FK_FAIL_ADD_SYSTEM";
    codes[1824] = "ER_FK_CANNOT_OPEN_PARENT";
    codes[1825] = "ER_FK_INCORRECT_OPTION";
    codes[1826] = "ER_DUP_CONSTRAINT_NAME";
    codes[1827] = "ER_PASSWORD_FORMAT";
    codes[1828] = "ER_FK_COLUMN_CANNOT_DROP";
    codes[1829] = "ER_FK_COLUMN_CANNOT_DROP_CHILD";
    codes[1830] = "ER_FK_COLUMN_NOT_NULL";
    codes[1831] = "ER_DUP_INDEX";
    codes[1832] = "ER_FK_COLUMN_CANNOT_CHANGE";
    codes[1833] = "ER_FK_COLUMN_CANNOT_CHANGE_CHILD";
    codes[1834] = "ER_FK_CANNOT_DELETE_PARENT";
    codes[1835] = "ER_MALFORMED_PACKET";
    codes[1836] = "ER_READ_ONLY_MODE";
    codes[1837] = "ER_GTID_NEXT_TYPE_UNDEFINED_GROUP";
    codes[1838] = "ER_VARIABLE_NOT_SETTABLE_IN_SP";
    codes[1839] = "ER_CANT_SET_GTID_PURGED_WHEN_GTID_MODE_IS_OFF";
    codes[1840] = "ER_CANT_SET_GTID_PURGED_WHEN_GTID_EXECUTED_IS_NOT_EMPTY";
    codes[1841] = "ER_CANT_SET_GTID_PURGED_WHEN_OWNED_GTIDS_IS_NOT_EMPTY";
    codes[1842] = "ER_GTID_PURGED_WAS_CHANGED";
    codes[1843] = "ER_GTID_EXECUTED_WAS_CHANGED";
    codes[1844] = "ER_BINLOG_STMT_MODE_AND_NO_REPL_TABLES";
    codes[1845] = "ER_ALTER_OPERATION_NOT_SUPPORTED";
    codes[1846] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON";
    codes[1847] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COPY";
    codes[1848] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_PARTITION";
    codes[1849] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_RENAME";
    codes[1850] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE";
    codes[1851] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_CHECK";
    codes[1852] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_IGNORE";
    codes[1853] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOPK";
    codes[1854] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_AUTOINC";
    codes[1855] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_HIDDEN_FTS";
    codes[1856] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_CHANGE_FTS";
    codes[1857] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FTS";
    codes[1858] = "ER_SQL_SLAVE_SKIP_COUNTER_NOT_SETTABLE_IN_GTID_MODE";
    codes[1859] = "ER_DUP_UNKNOWN_IN_INDEX";
    codes[1860] = "ER_IDENT_CAUSES_TOO_LONG_PATH";
    codes[1861] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOT_NULL";
    codes[1862] = "ER_MUST_CHANGE_PASSWORD_LOGIN";
    codes[1863] = "ER_ROW_IN_WRONG_PARTITION";
    codes[1864] = "ER_MTS_EVENT_BIGGER_PENDING_JOBS_SIZE_MAX";
    codes[1865] = "ER_INNODB_NO_FT_USES_PARSER";
    codes[1866] = "ER_BINLOG_LOGICAL_CORRUPTION";
    codes[1867] = "ER_WARN_PURGE_LOG_IN_USE";
    codes[1868] = "ER_WARN_PURGE_LOG_IS_ACTIVE";
    codes[1869] = "ER_AUTO_INCREMENT_CONFLICT";
    codes[1870] = "WARN_ON_BLOCKHOLE_IN_RBR";
    codes[1871] = "ER_SLAVE_MI_INIT_REPOSITORY";
    codes[1872] = "ER_SLAVE_RLI_INIT_REPOSITORY";
    codes[1873] = "ER_ACCESS_DENIED_CHANGE_USER_ERROR";
    codes[1874] = "ER_INNODB_READ_ONLY";
    codes[1875] = "ER_STOP_SLAVE_SQL_THREAD_TIMEOUT";
    codes[1876] = "ER_STOP_SLAVE_IO_THREAD_TIMEOUT";
    codes[1877] = "ER_TABLE_CORRUPT";
    codes[1878] = "ER_TEMP_FILE_WRITE_FAILURE";
    codes[1879] = "ER_INNODB_FT_AUX_NOT_HEX_ID";
    codes[1880] = "ER_LAST_MYSQL_ERROR_MESSAGE";
    codes[1900] = "ER_UNUSED_18";
    codes[1901] = "ER_GENERATED_COLUMN_FUNCTION_IS_NOT_ALLOWED";
    codes[1902] = "ER_UNUSED_19";
    codes[1903] = "ER_PRIMARY_KEY_BASED_ON_GENERATED_COLUMN";
    codes[1904] = "ER_KEY_BASED_ON_GENERATED_VIRTUAL_COLUMN";
    codes[1905] = "ER_WRONG_FK_OPTION_FOR_GENERATED_COLUMN";
    codes[1906] = "ER_WARNING_NON_DEFAULT_VALUE_FOR_GENERATED_COLUMN";
    codes[1907] = "ER_UNSUPPORTED_ACTION_ON_GENERATED_COLUMN";
    codes[1908] = "ER_UNUSED_20";
    codes[1909] = "ER_UNUSED_21";
    codes[1910] = "ER_UNSUPPORTED_ENGINE_FOR_GENERATED_COLUMNS";
    codes[1911] = "ER_UNKNOWN_OPTION";
    codes[1912] = "ER_BAD_OPTION_VALUE";
    codes[1913] = "ER_UNUSED_6";
    codes[1914] = "ER_UNUSED_7";
    codes[1915] = "ER_UNUSED_8";
    codes[1916] = "ER_DATA_OVERFLOW";
    codes[1917] = "ER_DATA_TRUNCATED";
    codes[1918] = "ER_BAD_DATA";
    codes[1919] = "ER_DYN_COL_WRONG_FORMAT";
    codes[1920] = "ER_DYN_COL_IMPLEMENTATION_LIMIT";
    codes[1921] = "ER_DYN_COL_DATA";
    codes[1922] = "ER_DYN_COL_WRONG_CHARSET";
    codes[1923] = "ER_ILLEGAL_SUBQUERY_OPTIMIZER_SWITCHES";
    codes[1924] = "ER_QUERY_CACHE_IS_DISABLED";
    codes[1925] = "ER_QUERY_CACHE_IS_GLOBALY_DISABLED";
    codes[1926] = "ER_VIEW_ORDERBY_IGNORED";
    codes[1927] = "ER_CONNECTION_KILLED";
    codes[1928] = "ER_UNUSED_12";
    codes[1929] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SKIP_REPLICATION";
    codes[1930] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_SKIP_REPLICATION";
    codes[1931] = "ER_QUERY_EXCEEDED_ROWS_EXAMINED_LIMIT";
    codes[1932] = "ER_NO_SUCH_TABLE_IN_ENGINE";
    codes[1933] = "ER_TARGET_NOT_EXPLAINABLE";
    codes[1934] = "ER_CONNECTION_ALREADY_EXISTS";
    codes[1935] = "ER_MASTER_LOG_PREFIX";
    codes[1936] = "ER_CANT_START_STOP_SLAVE";
    codes[1937] = "ER_SLAVE_STARTED";
    codes[1938] = "ER_SLAVE_STOPPED";
    codes[1939] = "ER_SQL_DISCOVER_ERROR";
    codes[1940] = "ER_FAILED_GTID_STATE_INIT";
    codes[1941] = "ER_INCORRECT_GTID_STATE";
    codes[1942] = "ER_CANNOT_UPDATE_GTID_STATE";
    codes[1943] = "ER_DUPLICATE_GTID_DOMAIN";
    codes[1944] = "ER_GTID_OPEN_TABLE_FAILED";
    codes[1945] = "ER_GTID_POSITION_NOT_FOUND_IN_BINLOG";
    codes[1946] = "ER_CANNOT_LOAD_SLAVE_GTID_STATE";
    codes[1947] = "ER_MASTER_GTID_POS_CONFLICTS_WITH_BINLOG";
    codes[1948] = "ER_MASTER_GTID_POS_MISSING_DOMAIN";
    codes[1949] = "ER_UNTIL_REQUIRES_USING_GTID";
    codes[1950] = "ER_GTID_STRICT_OUT_OF_ORDER";
    codes[1951] = "ER_GTID_START_FROM_BINLOG_HOLE";
    codes[1952] = "ER_SLAVE_UNEXPECTED_MASTER_SWITCH";
    codes[1953] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_GTID_DOMAIN_ID_SEQ_NO";
    codes[1954] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_GTID_DOMAIN_ID_SEQ_NO";
    codes[1955] = "ER_GTID_POSITION_NOT_FOUND_IN_BINLOG2";
    codes[1956] = "ER_BINLOG_MUST_BE_EMPTY";
    codes[1957] = "ER_NO_SUCH_QUERY";
    codes[1958] = "ER_BAD_BASE64_DATA";
    codes[1959] = "ER_INVALID_ROLE";
    codes[1960] = "ER_INVALID_CURRENT_USER";
    codes[1961] = "ER_CANNOT_GRANT_ROLE";
    codes[1962] = "ER_CANNOT_REVOKE_ROLE";
    codes[1963] = "ER_CHANGE_SLAVE_PARALLEL_THREADS_ACTIVE";
    codes[1964] = "ER_PRIOR_COMMIT_FAILED";
    codes[1965] = "ER_IT_IS_A_VIEW";
    codes[1966] = "ER_SLAVE_SKIP_NOT_IN_GTID";
    codes[1967] = "ER_TABLE_DEFINITION_TOO_BIG";
    codes[1968] = "ER_PLUGIN_INSTALLED";
    codes[1969] = "ER_STATEMENT_TIMEOUT";
    codes[1970] = "ER_SUBQUERIES_NOT_SUPPORTED";
    codes[1971] = "ER_SET_STATEMENT_NOT_SUPPORTED";
    codes[1972] = "ER_UNUSED_9";
    codes[1973] = "ER_USER_CREATE_EXISTS";
    codes[1974] = "ER_USER_DROP_EXISTS";
    codes[1975] = "ER_ROLE_CREATE_EXISTS";
    codes[1976] = "ER_ROLE_DROP_EXISTS";
    codes[1977] = "ER_CANNOT_CONVERT_CHARACTER";
    codes[1978] = "ER_INVALID_DEFAULT_VALUE_FOR_FIELD";
    codes[1979] = "ER_KILL_QUERY_DENIED_ERROR";
    codes[1980] = "ER_NO_EIS_FOR_FIELD";
    codes[1981] = "ER_WARN_AGGFUNC_DEPENDENCE";
    codes[1982] = "WARN_INNODB_PARTITION_OPTION_IGNORED";
    codes[3e3] = "ER_FILE_CORRUPT";
    codes[3001] = "ER_ERROR_ON_MASTER";
    codes[3002] = "ER_INCONSISTENT_ERROR";
    codes[3003] = "ER_STORAGE_ENGINE_NOT_LOADED";
    codes[3004] = "ER_GET_STACKED_DA_WITHOUT_ACTIVE_HANDLER";
    codes[3005] = "ER_WARN_LEGACY_SYNTAX_CONVERTED";
    codes[3006] = "ER_BINLOG_UNSAFE_FULLTEXT_PLUGIN";
    codes[3007] = "ER_CANNOT_DISCARD_TEMPORARY_TABLE";
    codes[3008] = "ER_FK_DEPTH_EXCEEDED";
    codes[3009] = "ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE_V2";
    codes[3010] = "ER_WARN_TRIGGER_DOESNT_HAVE_CREATED";
    codes[3011] = "ER_REFERENCED_TRG_DOES_NOT_EXIST_MYSQL";
    codes[3012] = "ER_EXPLAIN_NOT_SUPPORTED";
    codes[3013] = "ER_INVALID_FIELD_SIZE";
    codes[3014] = "ER_MISSING_HA_CREATE_OPTION";
    codes[3015] = "ER_ENGINE_OUT_OF_MEMORY";
    codes[3016] = "ER_PASSWORD_EXPIRE_ANONYMOUS_USER";
    codes[3017] = "ER_SLAVE_SQL_THREAD_MUST_STOP";
    codes[3018] = "ER_NO_FT_MATERIALIZED_SUBQUERY";
    codes[3019] = "ER_INNODB_UNDO_LOG_FULL";
    codes[3020] = "ER_INVALID_ARGUMENT_FOR_LOGARITHM";
    codes[3021] = "ER_SLAVE_CHANNEL_IO_THREAD_MUST_STOP";
    codes[3022] = "ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO";
    codes[3023] = "ER_WARN_ONLY_MASTER_LOG_FILE_NO_POS";
    codes[3024] = "ER_QUERY_TIMEOUT";
    codes[3025] = "ER_NON_RO_SELECT_DISABLE_TIMER";
    codes[3026] = "ER_DUP_LIST_ENTRY";
    codes[3027] = "ER_SQL_MODE_NO_EFFECT";
    codes[3028] = "ER_AGGREGATE_ORDER_FOR_UNION";
    codes[3029] = "ER_AGGREGATE_ORDER_NON_AGG_QUERY";
    codes[3030] = "ER_SLAVE_WORKER_STOPPED_PREVIOUS_THD_ERROR";
    codes[3031] = "ER_DONT_SUPPORT_SLAVE_PRESERVE_COMMIT_ORDER";
    codes[3032] = "ER_SERVER_OFFLINE_MODE";
    codes[3033] = "ER_GIS_DIFFERENT_SRIDS";
    codes[3034] = "ER_GIS_UNSUPPORTED_ARGUMENT";
    codes[3035] = "ER_GIS_UNKNOWN_ERROR";
    codes[3036] = "ER_GIS_UNKNOWN_EXCEPTION";
    codes[3037] = "ER_GIS_INVALID_DATA";
    codes[3038] = "ER_BOOST_GEOMETRY_EMPTY_INPUT_EXCEPTION";
    codes[3039] = "ER_BOOST_GEOMETRY_CENTROID_EXCEPTION";
    codes[3040] = "ER_BOOST_GEOMETRY_OVERLAY_INVALID_INPUT_EXCEPTION";
    codes[3041] = "ER_BOOST_GEOMETRY_TURN_INFO_EXCEPTION";
    codes[3042] = "ER_BOOST_GEOMETRY_SELF_INTERSECTION_POINT_EXCEPTION";
    codes[3043] = "ER_BOOST_GEOMETRY_UNKNOWN_EXCEPTION";
    codes[3044] = "ER_STD_BAD_ALLOC_ERROR";
    codes[3045] = "ER_STD_DOMAIN_ERROR";
    codes[3046] = "ER_STD_LENGTH_ERROR";
    codes[3047] = "ER_STD_INVALID_ARGUMENT";
    codes[3048] = "ER_STD_OUT_OF_RANGE_ERROR";
    codes[3049] = "ER_STD_OVERFLOW_ERROR";
    codes[3050] = "ER_STD_RANGE_ERROR";
    codes[3051] = "ER_STD_UNDERFLOW_ERROR";
    codes[3052] = "ER_STD_LOGIC_ERROR";
    codes[3053] = "ER_STD_RUNTIME_ERROR";
    codes[3054] = "ER_STD_UNKNOWN_EXCEPTION";
    codes[3055] = "ER_GIS_DATA_WRONG_ENDIANESS";
    codes[3056] = "ER_CHANGE_MASTER_PASSWORD_LENGTH";
    codes[3057] = "ER_USER_LOCK_WRONG_NAME";
    codes[3058] = "ER_USER_LOCK_DEADLOCK";
    codes[3059] = "ER_REPLACE_INACCESSIBLE_ROWS";
    codes[3060] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_GIS";
    codes[4e3] = "ER_UNUSED_26";
    codes[4001] = "ER_UNUSED_27";
    codes[4002] = "ER_WITH_COL_WRONG_LIST";
    codes[4003] = "ER_TOO_MANY_DEFINITIONS_IN_WITH_CLAUSE";
    codes[4004] = "ER_DUP_QUERY_NAME";
    codes[4005] = "ER_RECURSIVE_WITHOUT_ANCHORS";
    codes[4006] = "ER_UNACCEPTABLE_MUTUAL_RECURSION";
    codes[4007] = "ER_REF_TO_RECURSIVE_WITH_TABLE_IN_DERIVED";
    codes[4008] = "ER_NOT_STANDARD_COMPLIANT_RECURSIVE";
    codes[4009] = "ER_WRONG_WINDOW_SPEC_NAME";
    codes[4010] = "ER_DUP_WINDOW_NAME";
    codes[4011] = "ER_PARTITION_LIST_IN_REFERENCING_WINDOW_SPEC";
    codes[4012] = "ER_ORDER_LIST_IN_REFERENCING_WINDOW_SPEC";
    codes[4013] = "ER_WINDOW_FRAME_IN_REFERENCED_WINDOW_SPEC";
    codes[4014] = "ER_BAD_COMBINATION_OF_WINDOW_FRAME_BOUND_SPECS";
    codes[4015] = "ER_WRONG_PLACEMENT_OF_WINDOW_FUNCTION";
    codes[4016] = "ER_WINDOW_FUNCTION_IN_WINDOW_SPEC";
    codes[4017] = "ER_NOT_ALLOWED_WINDOW_FRAME";
    codes[4018] = "ER_NO_ORDER_LIST_IN_WINDOW_SPEC";
    codes[4019] = "ER_RANGE_FRAME_NEEDS_SIMPLE_ORDERBY";
    codes[4020] = "ER_WRONG_TYPE_FOR_ROWS_FRAME";
    codes[4021] = "ER_WRONG_TYPE_FOR_RANGE_FRAME";
    codes[4022] = "ER_FRAME_EXCLUSION_NOT_SUPPORTED";
    codes[4023] = "ER_WINDOW_FUNCTION_DONT_HAVE_FRAME";
    codes[4024] = "ER_INVALID_NTILE_ARGUMENT";
    codes[4025] = "ER_CONSTRAINT_FAILED";
    codes[4026] = "ER_EXPRESSION_IS_TOO_BIG";
    codes[4027] = "ER_ERROR_EVALUATING_EXPRESSION";
    codes[4028] = "ER_CALCULATING_DEFAULT_VALUE";
    codes[4029] = "ER_EXPRESSION_REFERS_TO_UNINIT_FIELD";
    codes[4030] = "ER_PARTITION_DEFAULT_ERROR";
    codes[4031] = "ER_REFERENCED_TRG_DOES_NOT_EXIST";
    codes[4032] = "ER_INVALID_DEFAULT_PARAM";
    codes[4033] = "ER_BINLOG_NON_SUPPORTED_BULK";
    codes[4034] = "ER_BINLOG_UNCOMPRESS_ERROR";
    codes[4035] = "ER_JSON_BAD_CHR";
    codes[4036] = "ER_JSON_NOT_JSON_CHR";
    codes[4037] = "ER_JSON_EOS";
    codes[4038] = "ER_JSON_SYNTAX";
    codes[4039] = "ER_JSON_ESCAPING";
    codes[4040] = "ER_JSON_DEPTH";
    codes[4041] = "ER_JSON_PATH_EOS";
    codes[4042] = "ER_JSON_PATH_SYNTAX";
    codes[4043] = "ER_JSON_PATH_DEPTH";
    codes[4044] = "ER_JSON_PATH_NO_WILDCARD";
    codes[4045] = "ER_JSON_PATH_ARRAY";
    codes[4046] = "ER_JSON_ONE_OR_ALL";
    codes[4047] = "ER_UNSUPPORTED_COMPRESSED_TABLE";
    codes[4048] = "ER_GEOJSON_INCORRECT";
    codes[4049] = "ER_GEOJSON_TOO_FEW_POINTS";
    codes[4050] = "ER_GEOJSON_NOT_CLOSED";
    codes[4051] = "ER_JSON_PATH_EMPTY";
    codes[4052] = "ER_SLAVE_SAME_ID";
    codes[4053] = "ER_FLASHBACK_NOT_SUPPORTED";
    codes[4054] = "ER_KEYS_OUT_OF_ORDER";
    codes[4055] = "ER_OVERLAPPING_KEYS";
    codes[4056] = "ER_REQUIRE_ROW_BINLOG_FORMAT";
    codes[4057] = "ER_ISOLATION_MODE_NOT_SUPPORTED";
    codes[4058] = "ER_ON_DUPLICATE_DISABLED";
    codes[4059] = "ER_UPDATES_WITH_CONSISTENT_SNAPSHOT";
    codes[4060] = "ER_ROLLBACK_ONLY";
    codes[4061] = "ER_ROLLBACK_TO_SAVEPOINT";
    codes[4062] = "ER_ISOLATION_LEVEL_WITH_CONSISTENT_SNAPSHOT";
    codes[4063] = "ER_UNSUPPORTED_COLLATION";
    codes[4064] = "ER_METADATA_INCONSISTENCY";
    codes[4065] = "ER_CF_DIFFERENT";
    codes[4066] = "ER_RDB_TTL_DURATION_FORMAT";
    codes[4067] = "ER_RDB_STATUS_GENERAL";
    codes[4068] = "ER_RDB_STATUS_MSG";
    codes[4069] = "ER_RDB_TTL_UNSUPPORTED";
    codes[4070] = "ER_RDB_TTL_COL_FORMAT";
    codes[4071] = "ER_PER_INDEX_CF_DEPRECATED";
    codes[4072] = "ER_KEY_CREATE_DURING_ALTER";
    codes[4073] = "ER_SK_POPULATE_DURING_ALTER";
    codes[4074] = "ER_SUM_FUNC_WITH_WINDOW_FUNC_AS_ARG";
    codes[4075] = "ER_NET_OK_PACKET_TOO_LARGE";
    codes[4076] = "ER_GEOJSON_EMPTY_COORDINATES";
    codes[4077] = "ER_MYROCKS_CANT_NOPAD_COLLATION";
    codes[4078] = "ER_ILLEGAL_PARAMETER_DATA_TYPES2_FOR_OPERATION";
    codes[4079] = "ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION";
    codes[4080] = "ER_WRONG_PARAMCOUNT_TO_CURSOR";
    codes[4081] = "ER_UNKNOWN_STRUCTURED_VARIABLE";
    codes[4082] = "ER_ROW_VARIABLE_DOES_NOT_HAVE_FIELD";
    codes[4083] = "ER_END_IDENTIFIER_DOES_NOT_MATCH";
    codes[4084] = "ER_SEQUENCE_RUN_OUT";
    codes[4085] = "ER_SEQUENCE_INVALID_DATA";
    codes[4086] = "ER_SEQUENCE_INVALID_TABLE_STRUCTURE";
    codes[4087] = "ER_SEQUENCE_ACCESS_ERROR";
    codes[4088] = "ER_SEQUENCE_BINLOG_FORMAT";
    codes[4089] = "ER_NOT_SEQUENCE";
    codes[4090] = "ER_NOT_SEQUENCE2";
    codes[4091] = "ER_UNKNOWN_SEQUENCES";
    codes[4092] = "ER_UNKNOWN_VIEW";
    codes[4093] = "ER_WRONG_INSERT_INTO_SEQUENCE";
    codes[4094] = "ER_SP_STACK_TRACE";
    codes[4095] = "ER_PACKAGE_ROUTINE_IN_SPEC_NOT_DEFINED_IN_BODY";
    codes[4096] = "ER_PACKAGE_ROUTINE_FORWARD_DECLARATION_NOT_DEFINED";
    codes[4097] = "ER_COMPRESSED_COLUMN_USED_AS_KEY";
    codes[4098] = "ER_UNKNOWN_COMPRESSION_METHOD";
    codes[4099] = "ER_WRONG_NUMBER_OF_VALUES_IN_TVC";
    codes[4100] = "ER_FIELD_REFERENCE_IN_TVC";
    codes[4101] = "ER_WRONG_TYPE_FOR_PERCENTILE_FUNC";
    codes[4102] = "ER_ARGUMENT_NOT_CONSTANT";
    codes[4103] = "ER_ARGUMENT_OUT_OF_RANGE";
    codes[4104] = "ER_WRONG_TYPE_OF_ARGUMENT";
    codes[4105] = "ER_NOT_AGGREGATE_FUNCTION";
    codes[4106] = "ER_INVALID_AGGREGATE_FUNCTION";
    codes[4107] = "ER_INVALID_VALUE_TO_LIMIT";
    codes[4108] = "ER_INVISIBLE_NOT_NULL_WITHOUT_DEFAULT";
    codes[4109] = "ER_UPDATE_INFO_WITH_SYSTEM_VERSIONING";
    codes[4110] = "ER_VERS_FIELD_WRONG_TYPE";
    codes[4111] = "ER_VERS_ENGINE_UNSUPPORTED";
    codes[4112] = "ER_UNUSED_23";
    codes[4113] = "ER_PARTITION_WRONG_TYPE";
    codes[4114] = "WARN_VERS_PART_FULL";
    codes[4115] = "WARN_VERS_PARAMETERS";
    codes[4116] = "ER_VERS_DROP_PARTITION_INTERVAL";
    codes[4117] = "ER_UNUSED_25";
    codes[4118] = "WARN_VERS_PART_NON_HISTORICAL";
    codes[4119] = "ER_VERS_ALTER_NOT_ALLOWED";
    codes[4120] = "ER_VERS_ALTER_ENGINE_PROHIBITED";
    codes[4121] = "ER_VERS_RANGE_PROHIBITED";
    codes[4122] = "ER_CONFLICTING_FOR_SYSTEM_TIME";
    codes[4123] = "ER_VERS_TABLE_MUST_HAVE_COLUMNS";
    codes[4124] = "ER_VERS_NOT_VERSIONED";
    codes[4125] = "ER_MISSING";
    codes[4126] = "ER_VERS_PERIOD_COLUMNS";
    codes[4127] = "ER_PART_WRONG_VALUE";
    codes[4128] = "ER_VERS_WRONG_PARTS";
    codes[4129] = "ER_VERS_NO_TRX_ID";
    codes[4130] = "ER_VERS_ALTER_SYSTEM_FIELD";
    codes[4131] = "ER_DROP_VERSIONING_SYSTEM_TIME_PARTITION";
    codes[4132] = "ER_VERS_DB_NOT_SUPPORTED";
    codes[4133] = "ER_VERS_TRT_IS_DISABLED";
    codes[4134] = "ER_VERS_DUPLICATE_ROW_START_END";
    codes[4135] = "ER_VERS_ALREADY_VERSIONED";
    codes[4136] = "ER_UNUSED_24";
    codes[4137] = "ER_VERS_NOT_SUPPORTED";
    codes[4138] = "ER_VERS_TRX_PART_HISTORIC_ROW_NOT_SUPPORTED";
    codes[4139] = "ER_INDEX_FILE_FULL";
    codes[4140] = "ER_UPDATED_COLUMN_ONLY_ONCE";
    codes[4141] = "ER_EMPTY_ROW_IN_TVC";
    codes[4142] = "ER_VERS_QUERY_IN_PARTITION";
    codes[4143] = "ER_KEY_DOESNT_SUPPORT";
    codes[4144] = "ER_ALTER_OPERATION_TABLE_OPTIONS_NEED_REBUILD";
    codes[4145] = "ER_BACKUP_LOCK_IS_ACTIVE";
    codes[4146] = "ER_BACKUP_NOT_RUNNING";
    codes[4147] = "ER_BACKUP_WRONG_STAGE";
    codes[4148] = "ER_BACKUP_STAGE_FAILED";
    codes[4149] = "ER_BACKUP_UNKNOWN_STAGE";
    codes[4150] = "ER_USER_IS_BLOCKED";
    codes[4151] = "ER_ACCOUNT_HAS_BEEN_LOCKED";
    codes[4152] = "ER_PERIOD_TEMPORARY_NOT_ALLOWED";
    codes[4153] = "ER_PERIOD_TYPES_MISMATCH";
    codes[4154] = "ER_MORE_THAN_ONE_PERIOD";
    codes[4155] = "ER_PERIOD_FIELD_WRONG_ATTRIBUTES";
    codes[4156] = "ER_PERIOD_NOT_FOUND";
    codes[4157] = "ER_PERIOD_COLUMNS_UPDATED";
    codes[4158] = "ER_PERIOD_CONSTRAINT_DROP";
    codes[4159] = "ER_TOO_LONG_KEYPART";
    codes[4160] = "ER_TOO_LONG_DATABASE_COMMENT";
    codes[4161] = "ER_UNKNOWN_DATA_TYPE";
    codes[4162] = "ER_UNKNOWN_OPERATOR";
    codes[4163] = "ER_WARN_HISTORY_ROW_START_TIME";
    codes[4164] = "ER_PART_STARTS_BEYOND_INTERVAL";
    codes[4165] = "ER_GALERA_REPLICATION_NOT_SUPPORTED";
    codes[4166] = "ER_LOAD_INFILE_CAPABILITY_DISABLED";
    codes[4167] = "ER_NO_SECURE_TRANSPORTS_CONFIGURED";
    codes[4168] = "ER_SLAVE_IGNORED_SHARED_TABLE";
    codes[4169] = "ER_NO_AUTOINCREMENT_WITH_UNIQUE";
    codes[4170] = "ER_KEY_CONTAINS_PERIOD_FIELDS";
    codes[4171] = "ER_KEY_CANT_HAVE_WITHOUT_OVERLAPS";
    codes[4172] = "ER_NOT_ALLOWED_IN_THIS_CONTEXT";
    codes[4173] = "ER_DATA_WAS_COMMITED_UNDER_ROLLBACK";
    codes[4174] = "ER_PK_INDEX_CANT_BE_IGNORED";
    codes[4175] = "ER_BINLOG_UNSAFE_SKIP_LOCKED";
    codes[4176] = "ER_JSON_TABLE_ERROR_ON_FIELD";
    codes[4177] = "ER_JSON_TABLE_ALIAS_REQUIRED";
    codes[4178] = "ER_JSON_TABLE_SCALAR_EXPECTED";
    codes[4179] = "ER_JSON_TABLE_MULTIPLE_MATCHES";
    codes[4180] = "ER_WITH_TIES_NEEDS_ORDER";
    codes[4181] = "ER_REMOVED_ORPHAN_TRIGGER";
    codes[4182] = "ER_STORAGE_ENGINE_DISABLED";
    codes[4183] = "WARN_SFORMAT_ERROR";
    codes[4184] = "ER_PARTITION_CONVERT_SUBPARTITIONED";
    codes[4185] = "ER_PROVIDER_NOT_LOADED";
    codes[4186] = "ER_JSON_HISTOGRAM_PARSE_FAILED";
    codes[4187] = "ER_SF_OUT_INOUT_ARG_NOT_ALLOWED";
    codes[4188] = "ER_INCONSISTENT_SLAVE_TEMP_TABLE";
    codes[4189] = "ER_VERS_HIST_PART_FAILED";
    module2.exports.codes = codes;
  }
});
var require_errors = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/misc/errors.js"(exports, module2) {
    "use strict";
    var ErrorCodes = require_error_code();
    var SqlError = class extends Error {
      constructor(msg, sql, fatal, info, sqlState, errno, additionalStack, addHeader = void 0, cause) {
        super(
          (addHeader !== false ? `(conn:${info && info.threadId ? info.threadId : -1}, no: ${errno ? errno : -1}, SQLState: ${sqlState}) ` : "") + msg + (sql ? "\nsql: " + sql : ""),
          cause
        );
        this.name = "SqlError";
        this.sqlMessage = msg;
        this.sql = sql;
        this.fatal = fatal;
        this.errno = errno;
        this.sqlState = sqlState;
        if (errno > 45e3 && errno < 46e3) {
          this.code = errByNo[errno] || "UNKNOWN";
        } else {
          this.code = ErrorCodes.codes[this.errno] || "UNKNOWN";
        }
        if (additionalStack) {
          this.stack += "\n From event:\n" + additionalStack.substring(additionalStack.indexOf("\n") + 1);
        }
      }
      get text() {
        return this.sqlMessage;
      }
    };
    module2.exports.createError = function(msg, errno, info = null, sqlState = "HY000", sql = null, fatal = false, additionalStack = void 0, addHeader = void 0, cause = void 0) {
      if (cause) return new SqlError(msg, sql, fatal, info, sqlState, errno, additionalStack, addHeader, { cause });
      return new SqlError(msg, sql, fatal, info, sqlState, errno, additionalStack, addHeader, cause);
    };
    module2.exports.createFatalError = function(msg, errno, info = null, sqlState = "08S01", sql = null, additionalStack = void 0, addHeader = void 0) {
      return new SqlError(msg, sql, true, info, sqlState, errno, additionalStack, addHeader);
    };
    module2.exports.ER_CONNECTION_ALREADY_CLOSED = 45001;
    module2.exports.ER_MYSQL_CHANGE_USER_BUG = 45003;
    module2.exports.ER_CMD_NOT_EXECUTED_DESTROYED = 45004;
    module2.exports.ER_NULL_CHAR_ESCAPEID = 45005;
    module2.exports.ER_NULL_ESCAPEID = 45006;
    module2.exports.ER_NOT_IMPLEMENTED_FORMAT = 45007;
    module2.exports.ER_NODE_NOT_SUPPORTED_TLS = 45008;
    module2.exports.ER_SOCKET_UNEXPECTED_CLOSE = 45009;
    module2.exports.ER_UNEXPECTED_PACKET = 45011;
    module2.exports.ER_CONNECTION_TIMEOUT = 45012;
    module2.exports.ER_CMD_CONNECTION_CLOSED = 45013;
    module2.exports.ER_CHANGE_USER_BAD_PACKET = 45014;
    module2.exports.ER_PING_BAD_PACKET = 45015;
    module2.exports.ER_MISSING_PARAMETER = 45016;
    module2.exports.ER_PARAMETER_UNDEFINED = 45017;
    module2.exports.ER_PLACEHOLDER_UNDEFINED = 45018;
    module2.exports.ER_SOCKET = 45019;
    module2.exports.ER_EOF_EXPECTED = 45020;
    module2.exports.ER_LOCAL_INFILE_DISABLED = 45021;
    module2.exports.ER_LOCAL_INFILE_NOT_READABLE = 45022;
    module2.exports.ER_SERVER_SSL_DISABLED = 45023;
    module2.exports.ER_AUTHENTICATION_BAD_PACKET = 45024;
    module2.exports.ER_AUTHENTICATION_PLUGIN_NOT_SUPPORTED = 45025;
    module2.exports.ER_SOCKET_TIMEOUT = 45026;
    module2.exports.ER_POOL_ALREADY_CLOSED = 45027;
    module2.exports.ER_GET_CONNECTION_TIMEOUT = 45028;
    module2.exports.ER_SETTING_SESSION_ERROR = 45029;
    module2.exports.ER_INITIAL_SQL_ERROR = 45030;
    module2.exports.ER_BATCH_WITH_NO_VALUES = 45031;
    module2.exports.ER_RESET_BAD_PACKET = 45032;
    module2.exports.ER_WRONG_IANA_TIMEZONE = 45033;
    module2.exports.ER_LOCAL_INFILE_WRONG_FILENAME = 45034;
    module2.exports.ER_ADD_CONNECTION_CLOSED_POOL = 45035;
    module2.exports.ER_WRONG_AUTO_TIMEZONE = 45036;
    module2.exports.ER_CLOSING_POOL = 45037;
    module2.exports.ER_TIMEOUT_NOT_SUPPORTED = 45038;
    module2.exports.ER_INITIAL_TIMEOUT_ERROR = 45039;
    module2.exports.ER_DUPLICATE_FIELD = 45040;
    module2.exports.ER_PING_TIMEOUT = 45042;
    module2.exports.ER_BAD_PARAMETER_VALUE = 45043;
    module2.exports.ER_CANNOT_RETRIEVE_RSA_KEY = 45044;
    module2.exports.ER_MINIMUM_NODE_VERSION_REQUIRED = 45045;
    module2.exports.ER_MAX_ALLOWED_PACKET = 45046;
    module2.exports.ER_NOT_SUPPORTED_AUTH_PLUGIN = 45047;
    module2.exports.ER_COMPRESSION_NOT_SUPPORTED = 45048;
    module2.exports.ER_UNDEFINED_SQL = 45049;
    module2.exports.ER_PARSING_PRECISION = 45050;
    module2.exports.ER_PREPARE_CLOSED = 45051;
    module2.exports.ER_MISSING_SQL_PARAMETER = 45052;
    module2.exports.ER_MISSING_SQL_FILE = 45053;
    module2.exports.ER_SQL_FILE_ERROR = 45054;
    module2.exports.ER_MISSING_DATABASE_PARAMETER = 45055;
    module2.exports.ER_SELF_SIGNED = 45056;
    module2.exports.ER_SELF_SIGNED_NO_PWD = 45057;
    var keys = Object.keys(module2.exports);
    var errByNo = {};
    for (let i = 0; i < keys.length; i++) {
      const keyName = keys[i];
      if (keyName !== "createError") {
        errByNo[module2.exports[keyName]] = keyName;
      }
    }
    module2.exports.SqlError = SqlError;
  }
});
var require_packet = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/io/packet.js"(exports, module2) {
    "use strict";
    var Errors = require_errors();
    var Packet = class {
      update(buf, pos, end) {
        this.buf = buf;
        this.pos = pos;
        this.end = end;
        return this;
      }
      skip(n) {
        this.pos += n;
      }
      readGeometry(defaultVal) {
        const geoBuf = this.readBufferLengthEncoded();
        if (geoBuf === null || geoBuf.length === 0) {
          return defaultVal;
        }
        let geoPos = 4;
        return readGeometryObject(false);
        function parseCoordinates(byteOrder) {
          geoPos += 16;
          const x = byteOrder ? geoBuf.readDoubleLE(geoPos - 16) : geoBuf.readDoubleBE(geoPos - 16);
          const y = byteOrder ? geoBuf.readDoubleLE(geoPos - 8) : geoBuf.readDoubleBE(geoPos - 8);
          return [x, y];
        }
        function readGeometryObject(inner) {
          const byteOrder = geoBuf[geoPos++];
          const wkbType = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);
          geoPos += 4;
          switch (wkbType) {
            case 1:
              const coords = parseCoordinates(byteOrder);
              if (inner) return coords;
              return {
                type: "Point",
                coordinates: coords
              };
            case 2:
              const pointNumber = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);
              geoPos += 4;
              let coordinates = [];
              for (let i = 0; i < pointNumber; i++) {
                coordinates.push(parseCoordinates(byteOrder));
              }
              if (inner) return coordinates;
              return {
                type: "LineString",
                coordinates
              };
            case 3:
              let polygonCoordinates = [];
              const numRings = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);
              geoPos += 4;
              for (let ring = 0; ring < numRings; ring++) {
                const pointNumber2 = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);
                geoPos += 4;
                let linesCoordinates = [];
                for (let i = 0; i < pointNumber2; i++) {
                  linesCoordinates.push(parseCoordinates(byteOrder));
                }
                polygonCoordinates.push(linesCoordinates);
              }
              if (inner) return polygonCoordinates;
              return {
                type: "Polygon",
                coordinates: polygonCoordinates
              };
            case 4:
              return {
                type: "MultiPoint",
                coordinates: parseGeomArray(byteOrder, true)
              };
            case 5:
              return {
                type: "MultiLineString",
                coordinates: parseGeomArray(byteOrder, true)
              };
            case 6:
              return {
                type: "MultiPolygon",
                coordinates: parseGeomArray(byteOrder, true)
              };
            case 7:
              return {
                type: "GeometryCollection",
                geometries: parseGeomArray(byteOrder, false)
              };
          }
          return null;
        }
        function parseGeomArray(byteOrder, inner) {
          let coordinates = [];
          const number = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);
          geoPos += 4;
          for (let i = 0; i < number; i++) {
            coordinates.push(readGeometryObject(inner));
          }
          return coordinates;
        }
      }
      peek() {
        return this.buf[this.pos];
      }
      remaining() {
        return this.end - this.pos > 0;
      }
      readInt8() {
        const val = this.buf[this.pos++];
        return val | (val & 2 ** 7) * 33554430;
      }
      readUInt8() {
        return this.buf[this.pos++];
      }
      readInt16() {
        const first = this.buf[this.pos++];
        const last = this.buf[this.pos++];
        const val = first + last * 2 ** 8;
        return val | (val & 2 ** 15) * 131070;
      }
      readUInt16() {
        return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8;
      }
      readInt24() {
        const first = this.buf[this.pos];
        const last = this.buf[this.pos + 2];
        const val = first + this.buf[this.pos + 1] * 2 ** 8 + last * 2 ** 16;
        this.pos += 3;
        return val | (val & 2 ** 23) * 510;
      }
      readUInt24() {
        return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8 + this.buf[this.pos++] * 2 ** 16;
      }
      readUInt32() {
        return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8 + this.buf[this.pos++] * 2 ** 16 + this.buf[this.pos++] * 2 ** 24;
      }
      readInt32() {
        return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8 + this.buf[this.pos++] * 2 ** 16 + (this.buf[this.pos++] << 24);
      }
      readBigInt64() {
        const val = this.buf.readBigInt64LE(this.pos);
        this.pos += 8;
        return val;
      }
      readBigUInt64() {
        const val = this.buf.readBigUInt64LE(this.pos);
        this.pos += 8;
        return val;
      }
      /**
       * Metadata are length encoded, but cannot have length > 256, so simplified readUnsignedLength
       * @returns {number}
       */
      readMetadataLength() {
        const type = this.buf[this.pos++];
        if (type < 251) return type;
        return this.readUInt16();
      }
      readUnsignedLength() {
        const type = this.buf[this.pos++];
        if (type < 251) return type;
        switch (type) {
          case 251:
            return null;
          case 252:
            return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8;
          case 253:
            return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8 + this.buf[this.pos++] * 2 ** 16;
          case 254:
            return Number(this.readBigInt64());
        }
      }
      readBuffer(len) {
        this.pos += len;
        return this.buf.subarray(this.pos - len, this.pos);
      }
      readBufferRemaining() {
        let b = this.buf.subarray(this.pos, this.end);
        this.pos = this.end;
        return b;
      }
      readBufferLengthEncoded() {
        const len = this.readUnsignedLength();
        if (len === null) return null;
        this.pos += len;
        return this.buf.subarray(this.pos - len, this.pos);
      }
      readStringNullEnded() {
        let initialPosition = this.pos;
        let cnt = 0;
        while (this.remaining() > 0 && this.buf[this.pos++] !== 0) {
          cnt++;
        }
        return this.buf.toString(void 0, initialPosition, initialPosition + cnt);
      }
      /**
       * Return unsigned Bigint.
       *
       * Could be used for reading other kind of value than InsertId, if reading possible null value
       * @returns {bigint}
       */
      readInsertId() {
        const type = this.buf[this.pos++];
        if (type < 251) return BigInt(type);
        switch (type) {
          case 252:
            return BigInt(this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8);
          case 253:
            return BigInt(this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8 + this.buf[this.pos++] * 2 ** 16);
          case 254:
            return this.readBigInt64();
        }
      }
      readAsciiStringLengthEncoded() {
        const len = this.readUnsignedLength();
        if (len === null) return null;
        this.pos += len;
        return this.buf.toString("ascii", this.pos - len, this.pos);
      }
      readStringLengthEncoded() {
        throw new Error("code is normally superseded by Node encoder or Iconv depending on charset used");
      }
      readBigIntLengthEncoded() {
        const len = this.buf[this.pos++];
        if (len < 16) {
          return BigInt(this._atoi(len));
        }
        if (len === 251) return null;
        return this.readBigIntFromLen(len);
      }
      readBigIntFromLen(len) {
        let result = 0n;
        let negate = false;
        let begin = this.pos;
        if (len > 0 && this.buf[begin] === 45) {
          negate = true;
          begin++;
        }
        for (; begin < this.pos + len; begin++) {
          result = result * 10n + BigInt(this.buf[begin] - 48);
        }
        this.pos += len;
        return negate ? -1n * result : result;
      }
      readDecimalLengthEncoded() {
        const len = this.buf[this.pos++];
        if (len === 251) return null;
        this.pos += len;
        return this.buf.toString("ascii", this.pos - len, this.pos);
      }
      readDate() {
        const len = this.buf[this.pos++];
        if (len === 251) return null;
        let res = [];
        let value = 0;
        let initPos = this.pos;
        this.pos += len;
        while (initPos < this.pos) {
          const char = this.buf[initPos++];
          if (char === 45) {
            res.push(value);
            value = 0;
          } else {
            value = value * 10 + char - 48;
          }
        }
        res.push(value);
        if (res[0] === 0 && res[1] === 0 && res[2] === 0) return null;
        return new Date(res[0], res[1] - 1, res[2]);
      }
      readBinaryDate(opts) {
        const len = this.buf[this.pos++];
        let year = 0;
        let month = 0;
        let day = 0;
        if (len > 0) {
          year = this.readInt16();
          if (len > 2) {
            month = this.readUInt8() - 1;
            if (len > 3) {
              day = this.readUInt8();
            }
          }
        }
        if (year === 0 && month === 0 && day === 0) return opts.dateStrings ? "0000-00-00" : null;
        if (opts.dateStrings) {
          return `${appendZero(year, 4)}-${appendZero(month + 1, 2)}-${appendZero(day, 2)}`;
        }
        return new Date(year, month, day);
      }
      readDateTime() {
        const len = this.buf[this.pos++];
        if (len === 251) return null;
        this.pos += len;
        const str = this.buf.toString("ascii", this.pos - len, this.pos);
        if (str.startsWith("0000-00-00 00:00:00")) return null;
        return new Date(str);
      }
      readBinaryDateTime() {
        const len = this.buf[this.pos++];
        let year = 0;
        let month = 0;
        let day = 0;
        let hour = 0;
        let min = 0;
        let sec = 0;
        let microSec = 0;
        if (len > 0) {
          year = this.readInt16();
          if (len > 2) {
            month = this.readUInt8();
            if (len > 3) {
              day = this.readUInt8();
              if (len > 4) {
                hour = this.readUInt8();
                min = this.readUInt8();
                sec = this.readUInt8();
                if (len > 7) {
                  microSec = this.readUInt32();
                }
              }
            }
          }
        }
        if (year === 0 && month === 0 && day === 0 && hour === 0 && min === 0 && sec === 0 && microSec === 0) return null;
        return new Date(year, month - 1, day, hour, min, sec, microSec / 1e3);
      }
      readBinaryDateTimeAsString(scale) {
        const len = this.buf[this.pos++];
        let year = 0;
        let month = 0;
        let day = 0;
        let hour = 0;
        let min = 0;
        let sec = 0;
        let microSec = 0;
        if (len > 0) {
          year = this.readInt16();
          if (len > 2) {
            month = this.readUInt8();
            if (len > 3) {
              day = this.readUInt8();
              if (len > 4) {
                hour = this.readUInt8();
                min = this.readUInt8();
                sec = this.readUInt8();
                if (len > 7) {
                  microSec = this.readUInt32();
                }
              }
            }
          }
        }
        if (year === 0 && month === 0 && day === 0 && hour === 0 && min === 0 && sec === 0 && microSec === 0)
          return "0000-00-00 00:00:00" + (scale > 0 ? ".000000".substring(0, scale + 1) : "");
        return appendZero(year, 4) + "-" + appendZero(month, 2) + "-" + appendZero(day, 2) + " " + appendZero(hour, 2) + ":" + appendZero(min, 2) + ":" + appendZero(sec, 2) + (microSec > 0 ? scale > 0 ? "." + appendZero(microSec, 6).substring(0, scale) : "." + appendZero(microSec, 6) : scale > 0 ? "." + appendZero(microSec, 6).substring(0, scale) : "");
      }
      readBinaryTime() {
        const len = this.buf[this.pos++];
        let negate = false;
        let hour = 0;
        let min = 0;
        let sec = 0;
        let microSec = 0;
        if (len > 0) {
          negate = this.buf[this.pos++] === 1;
          hour = this.readUInt32() * 24 + this.readUInt8();
          min = this.readUInt8();
          sec = this.readUInt8();
          if (len > 8) {
            microSec = this.readUInt32();
          }
        }
        let val = appendZero(hour, 2) + ":" + appendZero(min, 2) + ":" + appendZero(sec, 2);
        if (microSec > 0) {
          val += "." + appendZero(microSec, 6);
        }
        if (negate) return "-" + val;
        return val;
      }
      readFloat() {
        const val = this.buf.readFloatLE(this.pos);
        this.pos += 4;
        return val;
      }
      readDouble() {
        const val = this.buf.readDoubleLE(this.pos);
        this.pos += 8;
        return val;
      }
      readIntLengthEncoded() {
        const len = this.buf[this.pos++];
        if (len === 251) return null;
        return this._atoi(len);
      }
      _atoi(len) {
        let result = 0;
        let negate = false;
        let begin = this.pos;
        if (len > 0 && this.buf[begin] === 45) {
          negate = true;
          begin++;
        }
        for (; begin < this.pos + len; begin++) {
          result = result * 10 + (this.buf[begin] - 48);
        }
        this.pos += len;
        return negate ? -1 * result : result;
      }
      readFloatLengthCoded() {
        const len = this.readUnsignedLength();
        if (len === null) return null;
        this.pos += len;
        return +this.buf.toString("ascii", this.pos - len, this.pos);
      }
      skipLengthCodedNumber() {
        const type = this.buf[this.pos++];
        switch (type) {
          case 251:
            return;
          case 252:
            this.pos += 2 + (65535 & this.buf[this.pos] + (this.buf[this.pos + 1] << 8));
            return;
          case 253:
            this.pos += 3 + (16777215 & this.buf[this.pos] + (this.buf[this.pos + 1] << 8) + (this.buf[this.pos + 2] << 16));
            return;
          case 254:
            this.pos += 8 + Number(this.buf.readBigUInt64LE(this.pos));
            return;
          default:
            this.pos += type;
            return;
        }
      }
      length() {
        return this.end - this.pos;
      }
      subPacketLengthEncoded(len) {
      }
      /**
       * Parse ERR_Packet : https://mariadb.com/kb/en/library/err_packet/
       *
       * @param info              current connection info
       * @param sql               command sql
       * @param stack             additional stack trace
       * @returns {Error}
       */
      readError(info, sql, stack) {
        this.skip(1);
        let errno = this.readUInt16();
        let sqlState;
        let msg;
        if (this.peek() === 35) {
          this.skip(6);
          sqlState = this.buf.toString(void 0, this.pos - 5, this.pos);
          msg = this.readStringNullEnded();
        } else {
          sqlState = "HY000";
          msg = this.buf.toString(void 0, this.pos, this.end);
        }
        let fatal = sqlState.startsWith("08") || sqlState === "70100";
        return Errors.createError(msg, errno, info, sqlState, sql, fatal, stack);
      }
    };
    var appendZero = (val, len) => {
      let st = val.toString();
      while (st.length < len) {
        st = "0" + st;
      }
      return st;
    };
    module2.exports = Packet;
  }
});
var require_packet_node_encoded = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/io/packet-node-encoded.js"(exports, module2) {
    "use strict";
    var Packet = require_packet();
    var PacketNodeEncoded = class _PacketNodeEncoded extends Packet {
      constructor(encoding) {
        super();
        this.encoding = encoding === "utf8" ? void 0 : encoding;
      }
      readStringLengthEncoded() {
        const len = this.readUnsignedLength();
        if (len === null) return null;
        this.pos += len;
        return this.buf.toString(this.encoding, this.pos - len, this.pos);
      }
      static readString(encoding, buf, beg, len) {
        return buf.toString(encoding, beg, beg + len);
      }
      subPacketLengthEncoded(len) {
        this.skip(len);
        return new _PacketNodeEncoded(this.encoding).update(this.buf, this.pos - len, this.pos);
      }
      readStringRemaining() {
        const str = this.buf.toString(this.encoding, this.pos, this.end);
        this.pos = this.end;
        return str;
      }
    };
    module2.exports = PacketNodeEncoded;
  }
});
var require_packet_node_iconv = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/io/packet-node-iconv.js"(exports, module2) {
    "use strict";
    var Packet = require_packet();
    var Iconv = (0, import_chunk_LOGAFLCN.require_lib)();
    var PacketIconvEncoded = class _PacketIconvEncoded extends Packet {
      constructor(encoding) {
        super();
        this.encoding = encoding;
      }
      readStringLengthEncoded() {
        const len = this.readUnsignedLength();
        if (len === null) return null;
        this.pos += len;
        return Iconv.decode(this.buf.subarray(this.pos - len, this.pos), this.encoding);
      }
      static readString(encoding, buf, beg, len) {
        return Iconv.decode(buf.subarray(beg, beg + len), encoding);
      }
      subPacketLengthEncoded(len) {
        this.skip(len);
        return new _PacketIconvEncoded(this.encoding).update(this.buf, this.pos - len, this.pos);
      }
      readStringRemaining() {
        const str = Iconv.decode(this.buf.subarray(this.pos, this.end), this.encoding);
        this.pos = this.end;
        return str;
      }
    };
    module2.exports = PacketIconvEncoded;
  }
});
var require_collations = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/const/collations.js"(exports, module2) {
    "use strict";
    var charsets = [];
    var defaultCharsets = [];
    var Collation = class {
      constructor(index, name, charset, maxLength) {
        this.index = index;
        this.name = name;
        this.charset = charset;
        this.maxLength = maxLength;
      }
      static fromCharset(charset) {
        return defaultCharsets[charset === "utf8mb3" ? "utf8" : charset];
      }
      static fromIndex(index) {
        if (index >= charsets.length) return void 0;
        return charsets[index];
      }
      static fromName(name) {
        for (let i = 0; i < charsets.length; i++) {
          let collation = charsets[i];
          if (collation && collation.name === name) {
            return collation;
          }
        }
        const nameWithMb4 = name.replace("UTF8_", "UTF8MB4_");
        for (let i = 0; i < charsets.length; i++) {
          let collation = charsets[i];
          if (collation && collation.name === nameWithMb4) {
            return collation;
          }
        }
        return void 0;
      }
    };
    charsets[1] = new Collation(1, "BIG5_CHINESE_CI", "big5", 2);
    charsets[2] = new Collation(2, "LATIN2_CZECH_CS", "latin2", 1);
    charsets[3] = new Collation(3, "DEC8_SWEDISH_CI", "dec8", 1);
    charsets[4] = new Collation(4, "CP850_GENERAL_CI", "cp850", 1);
    charsets[5] = new Collation(5, "LATIN1_GERMAN1_CI", "latin1", 1);
    charsets[6] = new Collation(6, "HP8_ENGLISH_CI", "hp8", 1);
    charsets[7] = new Collation(7, "KOI8R_GENERAL_CI", "koi8r", 1);
    charsets[8] = new Collation(8, "LATIN1_SWEDISH_CI", "latin1", 1);
    charsets[9] = new Collation(9, "LATIN2_GENERAL_CI", "latin2", 1);
    charsets[10] = new Collation(10, "SWE7_SWEDISH_CI", "swe7", 1);
    charsets[11] = new Collation(11, "ASCII_GENERAL_CI", "ascii", 1);
    charsets[12] = new Collation(12, "UJIS_JAPANESE_CI", "ujis", 3);
    charsets[13] = new Collation(13, "SJIS_JAPANESE_CI", "sjis", 2);
    charsets[14] = new Collation(14, "CP1251_BULGARIAN_CI", "cp1251", 1);
    charsets[15] = new Collation(15, "LATIN1_DANISH_CI", "latin1", 1);
    charsets[16] = new Collation(16, "HEBREW_GENERAL_CI", "hebrew", 1);
    charsets[18] = new Collation(18, "TIS620_THAI_CI", "tis620", 1);
    charsets[19] = new Collation(19, "EUCKR_KOREAN_CI", "euckr", 2);
    charsets[20] = new Collation(20, "LATIN7_ESTONIAN_CS", "latin7", 1);
    charsets[21] = new Collation(21, "LATIN2_HUNGARIAN_CI", "latin2", 1);
    charsets[22] = new Collation(22, "KOI8U_GENERAL_CI", "koi8u", 1);
    charsets[23] = new Collation(23, "CP1251_UKRAINIAN_CI", "cp1251", 1);
    charsets[24] = new Collation(24, "GB2312_CHINESE_CI", "gb2312", 2);
    charsets[25] = new Collation(25, "GREEK_GENERAL_CI", "greek", 1);
    charsets[26] = new Collation(26, "CP1250_GENERAL_CI", "cp1250", 1);
    charsets[27] = new Collation(27, "LATIN2_CROATIAN_CI", "latin2", 1);
    charsets[28] = new Collation(28, "GBK_CHINESE_CI", "gbk", 2);
    charsets[29] = new Collation(29, "CP1257_LITHUANIAN_CI", "cp1257", 1);
    charsets[30] = new Collation(30, "LATIN5_TURKISH_CI", "latin5", 1);
    charsets[31] = new Collation(31, "LATIN1_GERMAN2_CI", "latin1", 1);
    charsets[32] = new Collation(32, "ARMSCII8_GENERAL_CI", "armscii8", 1);
    charsets[33] = new Collation(33, "UTF8MB3_GENERAL_CI", "utf8", 3);
    charsets[34] = new Collation(34, "CP1250_CZECH_CS", "cp1250", 1);
    charsets[35] = new Collation(35, "UCS2_GENERAL_CI", "ucs2", 2);
    charsets[36] = new Collation(36, "CP866_GENERAL_CI", "cp866", 1);
    charsets[37] = new Collation(37, "KEYBCS2_GENERAL_CI", "keybcs2", 1);
    charsets[38] = new Collation(38, "MACCE_GENERAL_CI", "macce", 1);
    charsets[39] = new Collation(39, "MACROMAN_GENERAL_CI", "macroman", 1);
    charsets[40] = new Collation(40, "CP852_GENERAL_CI", "cp852", 1);
    charsets[41] = new Collation(41, "LATIN7_GENERAL_CI", "latin7", 1);
    charsets[42] = new Collation(42, "LATIN7_GENERAL_CS", "latin7", 1);
    charsets[43] = new Collation(43, "MACCE_BIN", "macce", 1);
    charsets[44] = new Collation(44, "CP1250_CROATIAN_CI", "cp1250", 1);
    charsets[45] = new Collation(45, "UTF8MB4_GENERAL_CI", "utf8", 4);
    charsets[46] = new Collation(46, "UTF8MB4_BIN", "utf8", 4);
    charsets[47] = new Collation(47, "LATIN1_BIN", "latin1", 1);
    charsets[48] = new Collation(48, "LATIN1_GENERAL_CI", "latin1", 1);
    charsets[49] = new Collation(49, "LATIN1_GENERAL_CS", "latin1", 1);
    charsets[50] = new Collation(50, "CP1251_BIN", "cp1251", 1);
    charsets[51] = new Collation(51, "CP1251_GENERAL_CI", "cp1251", 1);
    charsets[52] = new Collation(52, "CP1251_GENERAL_CS", "cp1251", 1);
    charsets[53] = new Collation(53, "MACROMAN_BIN", "macroman", 1);
    charsets[54] = new Collation(54, "UTF16_GENERAL_CI", "utf16", 4);
    charsets[55] = new Collation(55, "UTF16_BIN", "utf16", 4);
    charsets[56] = new Collation(56, "UTF16LE_GENERAL_CI", "utf16le", 4);
    charsets[57] = new Collation(57, "CP1256_GENERAL_CI", "cp1256", 1);
    charsets[58] = new Collation(58, "CP1257_BIN", "cp1257", 1);
    charsets[59] = new Collation(59, "CP1257_GENERAL_CI", "cp1257", 1);
    charsets[60] = new Collation(60, "UTF32_GENERAL_CI", "utf32", 4);
    charsets[61] = new Collation(61, "UTF32_BIN", "utf32", 4);
    charsets[62] = new Collation(62, "UTF16LE_BIN", "utf16le", 4);
    charsets[63] = new Collation(63, "BINARY", "binary", 1);
    charsets[64] = new Collation(64, "ARMSCII8_BIN", "armscii8", 1);
    charsets[65] = new Collation(65, "ASCII_BIN", "ascii", 1);
    charsets[66] = new Collation(66, "CP1250_BIN", "cp1250", 1);
    charsets[67] = new Collation(67, "CP1256_BIN", "cp1256", 1);
    charsets[68] = new Collation(68, "CP866_BIN", "cp866", 1);
    charsets[69] = new Collation(69, "DEC8_BIN", "dec8", 1);
    charsets[70] = new Collation(70, "GREEK_BIN", "greek", 1);
    charsets[71] = new Collation(71, "HEBREW_BIN", "hebrew", 1);
    charsets[72] = new Collation(72, "HP8_BIN", "hp8", 1);
    charsets[73] = new Collation(73, "KEYBCS2_BIN", "keybcs2", 1);
    charsets[74] = new Collation(74, "KOI8R_BIN", "koi8r", 1);
    charsets[75] = new Collation(75, "KOI8U_BIN", "koi8u", 1);
    charsets[76] = new Collation(76, "UTF8_TOLOWER_CI", "utf8", 3);
    charsets[77] = new Collation(77, "LATIN2_BIN", "latin2", 1);
    charsets[78] = new Collation(78, "LATIN5_BIN", "latin5", 1);
    charsets[79] = new Collation(79, "LATIN7_BIN", "latin7", 1);
    charsets[80] = new Collation(80, "CP850_BIN", "cp850", 1);
    charsets[81] = new Collation(81, "CP852_BIN", "cp852", 1);
    charsets[82] = new Collation(82, "SWE7_BIN", "swe7", 1);
    charsets[83] = new Collation(83, "UTF8MB3_BIN", "utf8", 3);
    charsets[84] = new Collation(84, "BIG5_BIN", "big5", 2);
    charsets[85] = new Collation(85, "EUCKR_BIN", "euckr", 2);
    charsets[86] = new Collation(86, "GB2312_BIN", "gb2312", 2);
    charsets[87] = new Collation(87, "GBK_BIN", "gbk", 2);
    charsets[88] = new Collation(88, "SJIS_BIN", "sjis", 2);
    charsets[89] = new Collation(89, "TIS620_BIN", "tis620", 1);
    charsets[90] = new Collation(90, "UCS2_BIN", "ucs2", 2);
    charsets[91] = new Collation(91, "UJIS_BIN", "ujis", 3);
    charsets[92] = new Collation(92, "GEOSTD8_GENERAL_CI", "geostd8", 1);
    charsets[93] = new Collation(93, "GEOSTD8_BIN", "geostd8", 1);
    charsets[94] = new Collation(94, "LATIN1_SPANISH_CI", "latin1", 1);
    charsets[95] = new Collation(95, "CP932_JAPANESE_CI", "cp932", 2);
    charsets[96] = new Collation(96, "CP932_BIN", "cp932", 2);
    charsets[97] = new Collation(97, "EUCJPMS_JAPANESE_CI", "eucjpms", 3);
    charsets[98] = new Collation(98, "EUCJPMS_BIN", "eucjpms", 3);
    charsets[99] = new Collation(99, "CP1250_POLISH_CI", "cp1250", 1);
    charsets[101] = new Collation(101, "UTF16_UNICODE_CI", "utf16", 4);
    charsets[102] = new Collation(102, "UTF16_ICELANDIC_CI", "utf16", 4);
    charsets[103] = new Collation(103, "UTF16_LATVIAN_CI", "utf16", 4);
    charsets[104] = new Collation(104, "UTF16_ROMANIAN_CI", "utf16", 4);
    charsets[105] = new Collation(105, "UTF16_SLOVENIAN_CI", "utf16", 4);
    charsets[106] = new Collation(106, "UTF16_POLISH_CI", "utf16", 4);
    charsets[107] = new Collation(107, "UTF16_ESTONIAN_CI", "utf16", 4);
    charsets[108] = new Collation(108, "UTF16_SPANISH_CI", "utf16", 4);
    charsets[109] = new Collation(109, "UTF16_SWEDISH_CI", "utf16", 4);
    charsets[110] = new Collation(110, "UTF16_TURKISH_CI", "utf16", 4);
    charsets[111] = new Collation(111, "UTF16_CZECH_CI", "utf16", 4);
    charsets[112] = new Collation(112, "UTF16_DANISH_CI", "utf16", 4);
    charsets[113] = new Collation(113, "UTF16_LITHUANIAN_CI", "utf16", 4);
    charsets[114] = new Collation(114, "UTF16_SLOVAK_CI", "utf16", 4);
    charsets[115] = new Collation(115, "UTF16_SPANISH2_CI", "utf16", 4);
    charsets[116] = new Collation(116, "UTF16_ROMAN_CI", "utf16", 4);
    charsets[117] = new Collation(117, "UTF16_PERSIAN_CI", "utf16", 4);
    charsets[118] = new Collation(118, "UTF16_ESPERANTO_CI", "utf16", 4);
    charsets[119] = new Collation(119, "UTF16_HUNGARIAN_CI", "utf16", 4);
    charsets[120] = new Collation(120, "UTF16_SINHALA_CI", "utf16", 4);
    charsets[121] = new Collation(121, "UTF16_GERMAN2_CI", "utf16", 4);
    charsets[122] = new Collation(122, "UTF16_CROATIAN_MYSQL561_CI", "utf16", 4);
    charsets[123] = new Collation(123, "UTF16_UNICODE_520_CI", "utf16", 4);
    charsets[124] = new Collation(124, "UTF16_VIETNAMESE_CI", "utf16", 4);
    charsets[128] = new Collation(128, "UCS2_UNICODE_CI", "ucs2", 2);
    charsets[129] = new Collation(129, "UCS2_ICELANDIC_CI", "ucs2", 2);
    charsets[130] = new Collation(130, "UCS2_LATVIAN_CI", "ucs2", 2);
    charsets[131] = new Collation(131, "UCS2_ROMANIAN_CI", "ucs2", 2);
    charsets[132] = new Collation(132, "UCS2_SLOVENIAN_CI", "ucs2", 2);
    charsets[133] = new Collation(133, "UCS2_POLISH_CI", "ucs2", 2);
    charsets[134] = new Collation(134, "UCS2_ESTONIAN_CI", "ucs2", 2);
    charsets[135] = new Collation(135, "UCS2_SPANISH_CI", "ucs2", 2);
    charsets[136] = new Collation(136, "UCS2_SWEDISH_CI", "ucs2", 2);
    charsets[137] = new Collation(137, "UCS2_TURKISH_CI", "ucs2", 2);
    charsets[138] = new Collation(138, "UCS2_CZECH_CI", "ucs2", 2);
    charsets[139] = new Collation(139, "UCS2_DANISH_CI", "ucs2", 2);
    charsets[140] = new Collation(140, "UCS2_LITHUANIAN_CI", "ucs2", 2);
    charsets[141] = new Collation(141, "UCS2_SLOVAK_CI", "ucs2", 2);
    charsets[142] = new Collation(142, "UCS2_SPANISH2_CI", "ucs2", 2);
    charsets[143] = new Collation(143, "UCS2_ROMAN_CI", "ucs2", 2);
    charsets[144] = new Collation(144, "UCS2_PERSIAN_CI", "ucs2", 2);
    charsets[145] = new Collation(145, "UCS2_ESPERANTO_CI", "ucs2", 2);
    charsets[146] = new Collation(146, "UCS2_HUNGARIAN_CI", "ucs2", 2);
    charsets[147] = new Collation(147, "UCS2_SINHALA_CI", "ucs2", 2);
    charsets[148] = new Collation(148, "UCS2_GERMAN2_CI", "ucs2", 2);
    charsets[149] = new Collation(149, "UCS2_CROATIAN_MYSQL561_CI", "ucs2", 2);
    charsets[150] = new Collation(150, "UCS2_UNICODE_520_CI", "ucs2", 2);
    charsets[151] = new Collation(151, "UCS2_VIETNAMESE_CI", "ucs2", 2);
    charsets[159] = new Collation(159, "UCS2_GENERAL_MYSQL500_CI", "ucs2", 2);
    charsets[160] = new Collation(160, "UTF32_UNICODE_CI", "utf32", 4);
    charsets[161] = new Collation(161, "UTF32_ICELANDIC_CI", "utf32", 4);
    charsets[162] = new Collation(162, "UTF32_LATVIAN_CI", "utf32", 4);
    charsets[163] = new Collation(163, "UTF32_ROMANIAN_CI", "utf32", 4);
    charsets[164] = new Collation(164, "UTF32_SLOVENIAN_CI", "utf32", 4);
    charsets[165] = new Collation(165, "UTF32_POLISH_CI", "utf32", 4);
    charsets[166] = new Collation(166, "UTF32_ESTONIAN_CI", "utf32", 4);
    charsets[167] = new Collation(167, "UTF32_SPANISH_CI", "utf32", 4);
    charsets[168] = new Collation(168, "UTF32_SWEDISH_CI", "utf32", 4);
    charsets[169] = new Collation(169, "UTF32_TURKISH_CI", "utf32", 4);
    charsets[170] = new Collation(170, "UTF32_CZECH_CI", "utf32", 4);
    charsets[171] = new Collation(171, "UTF32_DANISH_CI", "utf32", 4);
    charsets[172] = new Collation(172, "UTF32_LITHUANIAN_CI", "utf32", 4);
    charsets[173] = new Collation(173, "UTF32_SLOVAK_CI", "utf32", 4);
    charsets[174] = new Collation(174, "UTF32_SPANISH2_CI", "utf32", 4);
    charsets[175] = new Collation(175, "UTF32_ROMAN_CI", "utf32", 4);
    charsets[176] = new Collation(176, "UTF32_PERSIAN_CI", "utf32", 4);
    charsets[177] = new Collation(177, "UTF32_ESPERANTO_CI", "utf32", 4);
    charsets[178] = new Collation(178, "UTF32_HUNGARIAN_CI", "utf32", 4);
    charsets[179] = new Collation(179, "UTF32_SINHALA_CI", "utf32", 4);
    charsets[180] = new Collation(180, "UTF32_GERMAN2_CI", "utf32", 4);
    charsets[181] = new Collation(181, "UTF32_CROATIAN_MYSQL561_CI", "utf32", 4);
    charsets[182] = new Collation(182, "UTF32_UNICODE_520_CI", "utf32", 4);
    charsets[183] = new Collation(183, "UTF32_VIETNAMESE_CI", "utf32", 4);
    charsets[192] = new Collation(192, "UTF8MB3_UNICODE_CI", "utf8", 3);
    charsets[193] = new Collation(193, "UTF8MB3_ICELANDIC_CI", "utf8", 3);
    charsets[194] = new Collation(194, "UTF8MB3_LATVIAN_CI", "utf8", 3);
    charsets[195] = new Collation(195, "UTF8MB3_ROMANIAN_CI", "utf8", 3);
    charsets[196] = new Collation(196, "UTF8MB3_SLOVENIAN_CI", "utf8", 3);
    charsets[197] = new Collation(197, "UTF8MB3_POLISH_CI", "utf8", 3);
    charsets[198] = new Collation(198, "UTF8MB3_ESTONIAN_CI", "utf8", 3);
    charsets[199] = new Collation(199, "UTF8MB3_SPANISH_CI", "utf8", 3);
    charsets[200] = new Collation(200, "UTF8MB3_SWEDISH_CI", "utf8", 3);
    charsets[201] = new Collation(201, "UTF8MB3_TURKISH_CI", "utf8", 3);
    charsets[202] = new Collation(202, "UTF8MB3_CZECH_CI", "utf8", 3);
    charsets[203] = new Collation(203, "UTF8MB3_DANISH_CI", "utf8", 3);
    charsets[204] = new Collation(204, "UTF8MB3_LITHUANIAN_CI", "utf8", 3);
    charsets[205] = new Collation(205, "UTF8MB3_SLOVAK_CI", "utf8", 3);
    charsets[206] = new Collation(206, "UTF8MB3_SPANISH2_CI", "utf8", 3);
    charsets[207] = new Collation(207, "UTF8MB3_ROMAN_CI", "utf8", 3);
    charsets[208] = new Collation(208, "UTF8MB3_PERSIAN_CI", "utf8", 3);
    charsets[209] = new Collation(209, "UTF8MB3_ESPERANTO_CI", "utf8", 3);
    charsets[210] = new Collation(210, "UTF8MB3_HUNGARIAN_CI", "utf8", 3);
    charsets[211] = new Collation(211, "UTF8MB3_SINHALA_CI", "utf8", 3);
    charsets[212] = new Collation(212, "UTF8MB3_GERMAN2_CI", "utf8", 3);
    charsets[213] = new Collation(213, "UTF8MB3_CROATIAN_MYSQL561_CI", "utf8", 3);
    charsets[214] = new Collation(214, "UTF8MB3_UNICODE_520_CI", "utf8", 3);
    charsets[215] = new Collation(215, "UTF8MB3_VIETNAMESE_CI", "utf8", 3);
    charsets[223] = new Collation(223, "UTF8MB3_GENERAL_MYSQL500_CI", "utf8", 3);
    charsets[224] = new Collation(224, "UTF8MB4_UNICODE_CI", "utf8", 4);
    charsets[225] = new Collation(225, "UTF8MB4_ICELANDIC_CI", "utf8", 4);
    charsets[226] = new Collation(226, "UTF8MB4_LATVIAN_CI", "utf8", 4);
    charsets[227] = new Collation(227, "UTF8MB4_ROMANIAN_CI", "utf8", 4);
    charsets[228] = new Collation(228, "UTF8MB4_SLOVENIAN_CI", "utf8", 4);
    charsets[229] = new Collation(229, "UTF8MB4_POLISH_CI", "utf8", 4);
    charsets[230] = new Collation(230, "UTF8MB4_ESTONIAN_CI", "utf8", 4);
    charsets[231] = new Collation(231, "UTF8MB4_SPANISH_CI", "utf8", 4);
    charsets[232] = new Collation(232, "UTF8MB4_SWEDISH_CI", "utf8", 4);
    charsets[233] = new Collation(233, "UTF8MB4_TURKISH_CI", "utf8", 4);
    charsets[234] = new Collation(234, "UTF8MB4_CZECH_CI", "utf8", 4);
    charsets[235] = new Collation(235, "UTF8MB4_DANISH_CI", "utf8", 4);
    charsets[236] = new Collation(236, "UTF8MB4_LITHUANIAN_CI", "utf8", 4);
    charsets[237] = new Collation(237, "UTF8MB4_SLOVAK_CI", "utf8", 4);
    charsets[238] = new Collation(238, "UTF8MB4_SPANISH2_CI", "utf8", 4);
    charsets[239] = new Collation(239, "UTF8MB4_ROMAN_CI", "utf8", 4);
    charsets[240] = new Collation(240, "UTF8MB4_PERSIAN_CI", "utf8", 4);
    charsets[241] = new Collation(241, "UTF8MB4_ESPERANTO_CI", "utf8", 4);
    charsets[242] = new Collation(242, "UTF8MB4_HUNGARIAN_CI", "utf8", 4);
    charsets[243] = new Collation(243, "UTF8MB4_SINHALA_CI", "utf8", 4);
    charsets[244] = new Collation(244, "UTF8MB4_GERMAN2_CI", "utf8", 4);
    charsets[245] = new Collation(245, "UTF8MB4_CROATIAN_MYSQL561_CI", "utf8", 4);
    charsets[246] = new Collation(246, "UTF8MB4_UNICODE_520_CI", "utf8", 4);
    charsets[247] = new Collation(247, "UTF8MB4_VIETNAMESE_CI", "utf8", 4);
    charsets[248] = new Collation(248, "GB18030_CHINESE_CI", "gb18030", 4);
    charsets[249] = new Collation(249, "GB18030_BIN", "gb18030", 4);
    charsets[250] = new Collation(250, "GB18030_UNICODE_520_CI", "gb18030", 4);
    charsets[255] = new Collation(255, "UTF8MB4_0900_AI_CI", "utf8", 4);
    charsets[256] = new Collation(256, "UTF8MB4_DE_PB_0900_AI_CI", "utf8", 4);
    charsets[257] = new Collation(257, "UTF8MB4_IS_0900_AI_CI", "utf8", 4);
    charsets[258] = new Collation(258, "UTF8MB4_LV_0900_AI_CI", "utf8", 4);
    charsets[259] = new Collation(259, "UTF8MB4_RO_0900_AI_CI", "utf8", 4);
    charsets[260] = new Collation(260, "UTF8MB4_SL_0900_AI_CI", "utf8", 4);
    charsets[261] = new Collation(261, "UTF8MB4_PL_0900_AI_CI", "utf8", 4);
    charsets[262] = new Collation(262, "UTF8MB4_ET_0900_AI_CI", "utf8", 4);
    charsets[263] = new Collation(263, "UTF8MB4_ES_0900_AI_CI", "utf8", 4);
    charsets[264] = new Collation(264, "UTF8MB4_SV_0900_AI_CI", "utf8", 4);
    charsets[265] = new Collation(265, "UTF8MB4_TR_0900_AI_CI", "utf8", 4);
    charsets[266] = new Collation(266, "UTF8MB4_CS_0900_AI_CI", "utf8", 4);
    charsets[267] = new Collation(267, "UTF8MB4_DA_0900_AI_CI", "utf8", 4);
    charsets[268] = new Collation(268, "UTF8MB4_LT_0900_AI_CI", "utf8", 4);
    charsets[269] = new Collation(269, "UTF8MB4_SK_0900_AI_CI", "utf8", 4);
    charsets[270] = new Collation(270, "UTF8MB4_ES_TRAD_0900_AI_CI", "utf8", 4);
    charsets[271] = new Collation(271, "UTF8MB4_LA_0900_AI_CI", "utf8", 4);
    charsets[273] = new Collation(273, "UTF8MB4_EO_0900_AI_CI", "utf8", 4);
    charsets[274] = new Collation(274, "UTF8MB4_HU_0900_AI_CI", "utf8", 4);
    charsets[275] = new Collation(275, "UTF8MB4_HR_0900_AI_CI", "utf8", 4);
    charsets[277] = new Collation(277, "UTF8MB4_VI_0900_AI_CI", "utf8", 4);
    charsets[278] = new Collation(278, "UTF8MB4_0900_AS_CS", "utf8", 4);
    charsets[279] = new Collation(279, "UTF8MB4_DE_PB_0900_AS_CS", "utf8", 4);
    charsets[280] = new Collation(280, "UTF8MB4_IS_0900_AS_CS", "utf8", 4);
    charsets[281] = new Collation(281, "UTF8MB4_LV_0900_AS_CS", "utf8", 4);
    charsets[282] = new Collation(282, "UTF8MB4_RO_0900_AS_CS", "utf8", 4);
    charsets[283] = new Collation(283, "UTF8MB4_SL_0900_AS_CS", "utf8", 4);
    charsets[284] = new Collation(284, "UTF8MB4_PL_0900_AS_CS", "utf8", 4);
    charsets[285] = new Collation(285, "UTF8MB4_ET_0900_AS_CS", "utf8", 4);
    charsets[286] = new Collation(286, "UTF8MB4_ES_0900_AS_CS", "utf8", 4);
    charsets[287] = new Collation(287, "UTF8MB4_SV_0900_AS_CS", "utf8", 4);
    charsets[288] = new Collation(288, "UTF8MB4_TR_0900_AS_CS", "utf8", 4);
    charsets[289] = new Collation(289, "UTF8MB4_CS_0900_AS_CS", "utf8", 4);
    charsets[290] = new Collation(290, "UTF8MB4_DA_0900_AS_CS", "utf8", 4);
    charsets[291] = new Collation(291, "UTF8MB4_LT_0900_AS_CS", "utf8", 4);
    charsets[292] = new Collation(292, "UTF8MB4_SK_0900_AS_CS", "utf8", 4);
    charsets[293] = new Collation(293, "UTF8MB4_ES_TRAD_0900_AS_CS", "utf8", 4);
    charsets[294] = new Collation(294, "UTF8MB4_LA_0900_AS_CS", "utf8", 4);
    charsets[296] = new Collation(296, "UTF8MB4_EO_0900_AS_CS", "utf8", 4);
    charsets[297] = new Collation(297, "UTF8MB4_HU_0900_AS_CS", "utf8", 4);
    charsets[298] = new Collation(298, "UTF8MB4_HR_0900_AS_CS", "utf8", 4);
    charsets[300] = new Collation(300, "UTF8MB4_VI_0900_AS_CS", "utf8", 4);
    charsets[303] = new Collation(303, "UTF8MB4_JA_0900_AS_CS", "utf8", 4);
    charsets[304] = new Collation(304, "UTF8MB4_JA_0900_AS_CS_KS", "utf8", 4);
    charsets[305] = new Collation(305, "UTF8MB4_0900_AS_CI", "utf8", 4);
    charsets[306] = new Collation(306, "UTF8MB4_RU_0900_AI_CI", "utf8", 4);
    charsets[307] = new Collation(307, "UTF8MB4_RU_0900_AS_CS", "utf8", 4);
    charsets[308] = new Collation(308, "UTF8MB4_ZH_0900_AS_CS", "utf8", 4);
    charsets[309] = new Collation(309, "UTF8MB4_0900_BIN", "utf8", 4);
    charsets[576] = new Collation(576, "UTF8MB3_CROATIAN_CI", "utf8", 3);
    charsets[577] = new Collation(577, "UTF8MB3_MYANMAR_CI", "utf8", 3);
    charsets[578] = new Collation(578, "UTF8MB3_THAI_520_W2", "utf8", 3);
    charsets[608] = new Collation(608, "UTF8MB4_CROATIAN_CI", "utf8", 4);
    charsets[609] = new Collation(609, "UTF8MB4_MYANMAR_CI", "utf8", 4);
    charsets[610] = new Collation(610, "UTF8MB4_THAI_520_W2", "utf8", 4);
    charsets[640] = new Collation(640, "UCS2_CROATIAN_CI", "ucs2", 2);
    charsets[641] = new Collation(641, "UCS2_MYANMAR_CI", "ucs2", 2);
    charsets[642] = new Collation(642, "UCS2_THAI_520_W2", "ucs2", 2);
    charsets[672] = new Collation(672, "UTF16_CROATIAN_CI", "utf16", 4);
    charsets[673] = new Collation(673, "UTF16_MYANMAR_CI", "utf16", 4);
    charsets[674] = new Collation(674, "UTF16_THAI_520_W2", "utf16", 4);
    charsets[736] = new Collation(736, "UTF32_CROATIAN_CI", "utf32", 4);
    charsets[737] = new Collation(737, "UTF32_MYANMAR_CI", "utf32", 4);
    charsets[738] = new Collation(738, "UTF32_THAI_520_W2", "utf32", 4);
    charsets[1025] = new Collation(1025, "BIG5_CHINESE_NOPAD_CI", "big5", 2);
    charsets[1027] = new Collation(1027, "DEC8_SWEDISH_NOPAD_CI", "dec8", 1);
    charsets[1028] = new Collation(1028, "CP850_GENERAL_NOPAD_CI", "cp850", 1);
    charsets[1030] = new Collation(1030, "HP8_ENGLISH_NOPAD_CI", "hp8", 1);
    charsets[1031] = new Collation(1031, "KOI8R_GENERAL_NOPAD_CI", "koi8r", 1);
    charsets[1032] = new Collation(1032, "LATIN1_SWEDISH_NOPAD_CI", "latin1", 1);
    charsets[1033] = new Collation(1033, "LATIN2_GENERAL_NOPAD_CI", "latin2", 1);
    charsets[1034] = new Collation(1034, "SWE7_SWEDISH_NOPAD_CI", "swe7", 1);
    charsets[1035] = new Collation(1035, "ASCII_GENERAL_NOPAD_CI", "ascii", 1);
    charsets[1036] = new Collation(1036, "UJIS_JAPANESE_NOPAD_CI", "ujis", 3);
    charsets[1037] = new Collation(1037, "SJIS_JAPANESE_NOPAD_CI", "sjis", 2);
    charsets[1040] = new Collation(1040, "HEBREW_GENERAL_NOPAD_CI", "hebrew", 1);
    charsets[1042] = new Collation(1042, "TIS620_THAI_NOPAD_CI", "tis620", 1);
    charsets[1043] = new Collation(1043, "EUCKR_KOREAN_NOPAD_CI", "euckr", 2);
    charsets[1046] = new Collation(1046, "KOI8U_GENERAL_NOPAD_CI", "koi8u", 1);
    charsets[1048] = new Collation(1048, "GB2312_CHINESE_NOPAD_CI", "gb2312", 2);
    charsets[1049] = new Collation(1049, "GREEK_GENERAL_NOPAD_CI", "greek", 1);
    charsets[1050] = new Collation(1050, "CP1250_GENERAL_NOPAD_CI", "cp1250", 1);
    charsets[1052] = new Collation(1052, "GBK_CHINESE_NOPAD_CI", "gbk", 2);
    charsets[1054] = new Collation(1054, "LATIN5_TURKISH_NOPAD_CI", "latin5", 1);
    charsets[1056] = new Collation(1056, "ARMSCII8_GENERAL_NOPAD_CI", "armscii8", 1);
    charsets[1057] = new Collation(1057, "UTF8MB3_GENERAL_NOPAD_CI", "utf8", 3);
    charsets[1059] = new Collation(1059, "UCS2_GENERAL_NOPAD_CI", "ucs2", 2);
    charsets[1060] = new Collation(1060, "CP866_GENERAL_NOPAD_CI", "cp866", 1);
    charsets[1061] = new Collation(1061, "KEYBCS2_GENERAL_NOPAD_CI", "keybcs2", 1);
    charsets[1062] = new Collation(1062, "MACCE_GENERAL_NOPAD_CI", "macce", 1);
    charsets[1063] = new Collation(1063, "MACROMAN_GENERAL_NOPAD_CI", "macroman", 1);
    charsets[1064] = new Collation(1064, "CP852_GENERAL_NOPAD_CI", "cp852", 1);
    charsets[1065] = new Collation(1065, "LATIN7_GENERAL_NOPAD_CI", "latin7", 1);
    charsets[1067] = new Collation(1067, "MACCE_NOPAD_BIN", "macce", 1);
    charsets[1069] = new Collation(1069, "UTF8MB4_GENERAL_NOPAD_CI", "utf8", 4);
    charsets[1070] = new Collation(1070, "UTF8MB4_NOPAD_BIN", "utf8", 4);
    charsets[1071] = new Collation(1071, "LATIN1_NOPAD_BIN", "latin1", 1);
    charsets[1074] = new Collation(1074, "CP1251_NOPAD_BIN", "cp1251", 1);
    charsets[1075] = new Collation(1075, "CP1251_GENERAL_NOPAD_CI", "cp1251", 1);
    charsets[1077] = new Collation(1077, "MACROMAN_NOPAD_BIN", "macroman", 1);
    charsets[1078] = new Collation(1078, "UTF16_GENERAL_NOPAD_CI", "utf16", 4);
    charsets[1079] = new Collation(1079, "UTF16_NOPAD_BIN", "utf16", 4);
    charsets[1080] = new Collation(1080, "UTF16LE_GENERAL_NOPAD_CI", "utf16le", 4);
    charsets[1081] = new Collation(1081, "CP1256_GENERAL_NOPAD_CI", "cp1256", 1);
    charsets[1082] = new Collation(1082, "CP1257_NOPAD_BIN", "cp1257", 1);
    charsets[1083] = new Collation(1083, "CP1257_GENERAL_NOPAD_CI", "cp1257", 1);
    charsets[1084] = new Collation(1084, "UTF32_GENERAL_NOPAD_CI", "utf32", 4);
    charsets[1085] = new Collation(1085, "UTF32_NOPAD_BIN", "utf32", 4);
    charsets[1086] = new Collation(1086, "UTF16LE_NOPAD_BIN", "utf16le", 4);
    charsets[1088] = new Collation(1088, "ARMSCII8_NOPAD_BIN", "armscii8", 1);
    charsets[1089] = new Collation(1089, "ASCII_NOPAD_BIN", "ascii", 1);
    charsets[1090] = new Collation(1090, "CP1250_NOPAD_BIN", "cp1250", 1);
    charsets[1091] = new Collation(1091, "CP1256_NOPAD_BIN", "cp1256", 1);
    charsets[1092] = new Collation(1092, "CP866_NOPAD_BIN", "cp866", 1);
    charsets[1093] = new Collation(1093, "DEC8_NOPAD_BIN", "dec8", 1);
    charsets[1094] = new Collation(1094, "GREEK_NOPAD_BIN", "greek", 1);
    charsets[1095] = new Collation(1095, "HEBREW_NOPAD_BIN", "hebrew", 1);
    charsets[1096] = new Collation(1096, "HP8_NOPAD_BIN", "hp8", 1);
    charsets[1097] = new Collation(1097, "KEYBCS2_NOPAD_BIN", "keybcs2", 1);
    charsets[1098] = new Collation(1098, "KOI8R_NOPAD_BIN", "koi8r", 1);
    charsets[1099] = new Collation(1099, "KOI8U_NOPAD_BIN", "koi8u", 1);
    charsets[1101] = new Collation(1101, "LATIN2_NOPAD_BIN", "latin2", 1);
    charsets[1102] = new Collation(1102, "LATIN5_NOPAD_BIN", "latin5", 1);
    charsets[1103] = new Collation(1103, "LATIN7_NOPAD_BIN", "latin7", 1);
    charsets[1104] = new Collation(1104, "CP850_NOPAD_BIN", "cp850", 1);
    charsets[1105] = new Collation(1105, "CP852_NOPAD_BIN", "cp852", 1);
    charsets[1106] = new Collation(1106, "SWE7_NOPAD_BIN", "swe7", 1);
    charsets[1107] = new Collation(1107, "UTF8MB3_NOPAD_BIN", "utf8", 3);
    charsets[1108] = new Collation(1108, "BIG5_NOPAD_BIN", "big5", 2);
    charsets[1109] = new Collation(1109, "EUCKR_NOPAD_BIN", "euckr", 2);
    charsets[1110] = new Collation(1110, "GB2312_NOPAD_BIN", "gb2312", 2);
    charsets[1111] = new Collation(1111, "GBK_NOPAD_BIN", "gbk", 2);
    charsets[1112] = new Collation(1112, "SJIS_NOPAD_BIN", "sjis", 2);
    charsets[1113] = new Collation(1113, "TIS620_NOPAD_BIN", "tis620", 1);
    charsets[1114] = new Collation(1114, "UCS2_NOPAD_BIN", "ucs2", 2);
    charsets[1115] = new Collation(1115, "UJIS_NOPAD_BIN", "ujis", 3);
    charsets[1116] = new Collation(1116, "GEOSTD8_GENERAL_NOPAD_CI", "geostd8", 1);
    charsets[1117] = new Collation(1117, "GEOSTD8_NOPAD_BIN", "geostd8", 1);
    charsets[1119] = new Collation(1119, "CP932_JAPANESE_NOPAD_CI", "cp932", 2);
    charsets[1120] = new Collation(1120, "CP932_NOPAD_BIN", "cp932", 2);
    charsets[1121] = new Collation(1121, "EUCJPMS_JAPANESE_NOPAD_CI", "eucjpms", 3);
    charsets[1122] = new Collation(1122, "EUCJPMS_NOPAD_BIN", "eucjpms", 3);
    charsets[1125] = new Collation(1125, "UTF16_UNICODE_NOPAD_CI", "utf16", 4);
    charsets[1147] = new Collation(1147, "UTF16_UNICODE_520_NOPAD_CI", "utf16", 4);
    charsets[1152] = new Collation(1152, "UCS2_UNICODE_NOPAD_CI", "ucs2", 2);
    charsets[1174] = new Collation(1174, "UCS2_UNICODE_520_NOPAD_CI", "ucs2", 2);
    charsets[1184] = new Collation(1184, "UTF32_UNICODE_NOPAD_CI", "utf32", 4);
    charsets[1206] = new Collation(1206, "UTF32_UNICODE_520_NOPAD_CI", "utf32", 4);
    charsets[1216] = new Collation(1216, "UTF8MB3_UNICODE_NOPAD_CI", "utf8", 3);
    charsets[1238] = new Collation(1238, "UTF8MB3_UNICODE_520_NOPAD_CI", "utf8", 3);
    charsets[1248] = new Collation(1248, "UTF8MB4_UNICODE_NOPAD_CI", "utf8", 4);
    charsets[1270] = new Collation(1270, "UTF8MB4_UNICODE_520_NOPAD_CI", "utf8", 4);
    charsets[2048] = new Collation(2048, "UCA1400_AI_CI", "utf8", 3);
    charsets[2049] = new Collation(2049, "UCA1400_AI_CS", "utf8", 3);
    charsets[2050] = new Collation(2050, "UCA1400_AS_CI", "utf8", 3);
    charsets[2051] = new Collation(2051, "UCA1400_AS_CS", "utf8", 3);
    charsets[2052] = new Collation(2052, "UCA1400_NOPAD_AI_CI", "utf8", 3);
    charsets[2053] = new Collation(2053, "UCA1400_NOPAD_AI_CS", "utf8", 3);
    charsets[2054] = new Collation(2054, "UCA1400_NOPAD_AS_CI", "utf8", 3);
    charsets[2055] = new Collation(2055, "UCA1400_NOPAD_AS_CS", "utf8", 3);
    charsets[2056] = new Collation(2056, "UCA1400_ICELANDIC_AI_CI", "utf8", 3);
    charsets[2057] = new Collation(2057, "UCA1400_ICELANDIC_AI_CS", "utf8", 3);
    charsets[2058] = new Collation(2058, "UCA1400_ICELANDIC_AS_CI", "utf8", 3);
    charsets[2059] = new Collation(2059, "UCA1400_ICELANDIC_AS_CS", "utf8", 3);
    charsets[2060] = new Collation(2060, "UCA1400_ICELANDIC_NOPAD_AI_CI", "utf8", 3);
    charsets[2061] = new Collation(2061, "UCA1400_ICELANDIC_NOPAD_AI_CS", "utf8", 3);
    charsets[2062] = new Collation(2062, "UCA1400_ICELANDIC_NOPAD_AS_CI", "utf8", 3);
    charsets[2063] = new Collation(2063, "UCA1400_ICELANDIC_NOPAD_AS_CS", "utf8", 3);
    charsets[2064] = new Collation(2064, "UCA1400_LATVIAN_AI_CI", "utf8", 3);
    charsets[2065] = new Collation(2065, "UCA1400_LATVIAN_AI_CS", "utf8", 3);
    charsets[2066] = new Collation(2066, "UCA1400_LATVIAN_AS_CI", "utf8", 3);
    charsets[2067] = new Collation(2067, "UCA1400_LATVIAN_AS_CS", "utf8", 3);
    charsets[2068] = new Collation(2068, "UCA1400_LATVIAN_NOPAD_AI_CI", "utf8", 3);
    charsets[2069] = new Collation(2069, "UCA1400_LATVIAN_NOPAD_AI_CS", "utf8", 3);
    charsets[2070] = new Collation(2070, "UCA1400_LATVIAN_NOPAD_AS_CI", "utf8", 3);
    charsets[2071] = new Collation(2071, "UCA1400_LATVIAN_NOPAD_AS_CS", "utf8", 3);
    charsets[2072] = new Collation(2072, "UCA1400_ROMANIAN_AI_CI", "utf8", 3);
    charsets[2073] = new Collation(2073, "UCA1400_ROMANIAN_AI_CS", "utf8", 3);
    charsets[2074] = new Collation(2074, "UCA1400_ROMANIAN_AS_CI", "utf8", 3);
    charsets[2075] = new Collation(2075, "UCA1400_ROMANIAN_AS_CS", "utf8", 3);
    charsets[2076] = new Collation(2076, "UCA1400_ROMANIAN_NOPAD_AI_CI", "utf8", 3);
    charsets[2077] = new Collation(2077, "UCA1400_ROMANIAN_NOPAD_AI_CS", "utf8", 3);
    charsets[2078] = new Collation(2078, "UCA1400_ROMANIAN_NOPAD_AS_CI", "utf8", 3);
    charsets[2079] = new Collation(2079, "UCA1400_ROMANIAN_NOPAD_AS_CS", "utf8", 3);
    charsets[2080] = new Collation(2080, "UCA1400_SLOVENIAN_AI_CI", "utf8", 3);
    charsets[2081] = new Collation(2081, "UCA1400_SLOVENIAN_AI_CS", "utf8", 3);
    charsets[2082] = new Collation(2082, "UCA1400_SLOVENIAN_AS_CI", "utf8", 3);
    charsets[2083] = new Collation(2083, "UCA1400_SLOVENIAN_AS_CS", "utf8", 3);
    charsets[2084] = new Collation(2084, "UCA1400_SLOVENIAN_NOPAD_AI_CI", "utf8", 3);
    charsets[2085] = new Collation(2085, "UCA1400_SLOVENIAN_NOPAD_AI_CS", "utf8", 3);
    charsets[2086] = new Collation(2086, "UCA1400_SLOVENIAN_NOPAD_AS_CI", "utf8", 3);
    charsets[2087] = new Collation(2087, "UCA1400_SLOVENIAN_NOPAD_AS_CS", "utf8", 3);
    charsets[2088] = new Collation(2088, "UCA1400_POLISH_AI_CI", "utf8", 3);
    charsets[2089] = new Collation(2089, "UCA1400_POLISH_AI_CS", "utf8", 3);
    charsets[2090] = new Collation(2090, "UCA1400_POLISH_AS_CI", "utf8", 3);
    charsets[2091] = new Collation(2091, "UCA1400_POLISH_AS_CS", "utf8", 3);
    charsets[2092] = new Collation(2092, "UCA1400_POLISH_NOPAD_AI_CI", "utf8", 3);
    charsets[2093] = new Collation(2093, "UCA1400_POLISH_NOPAD_AI_CS", "utf8", 3);
    charsets[2094] = new Collation(2094, "UCA1400_POLISH_NOPAD_AS_CI", "utf8", 3);
    charsets[2095] = new Collation(2095, "UCA1400_POLISH_NOPAD_AS_CS", "utf8", 3);
    charsets[2096] = new Collation(2096, "UCA1400_ESTONIAN_AI_CI", "utf8", 3);
    charsets[2097] = new Collation(2097, "UCA1400_ESTONIAN_AI_CS", "utf8", 3);
    charsets[2098] = new Collation(2098, "UCA1400_ESTONIAN_AS_CI", "utf8", 3);
    charsets[2099] = new Collation(2099, "UCA1400_ESTONIAN_AS_CS", "utf8", 3);
    charsets[2100] = new Collation(2100, "UCA1400_ESTONIAN_NOPAD_AI_CI", "utf8", 3);
    charsets[2101] = new Collation(2101, "UCA1400_ESTONIAN_NOPAD_AI_CS", "utf8", 3);
    charsets[2102] = new Collation(2102, "UCA1400_ESTONIAN_NOPAD_AS_CI", "utf8", 3);
    charsets[2103] = new Collation(2103, "UCA1400_ESTONIAN_NOPAD_AS_CS", "utf8", 3);
    charsets[2104] = new Collation(2104, "UCA1400_SPANISH_AI_CI", "utf8", 3);
    charsets[2105] = new Collation(2105, "UCA1400_SPANISH_AI_CS", "utf8", 3);
    charsets[2106] = new Collation(2106, "UCA1400_SPANISH_AS_CI", "utf8", 3);
    charsets[2107] = new Collation(2107, "UCA1400_SPANISH_AS_CS", "utf8", 3);
    charsets[2108] = new Collation(2108, "UCA1400_SPANISH_NOPAD_AI_CI", "utf8", 3);
    charsets[2109] = new Collation(2109, "UCA1400_SPANISH_NOPAD_AI_CS", "utf8", 3);
    charsets[2110] = new Collation(2110, "UCA1400_SPANISH_NOPAD_AS_CI", "utf8", 3);
    charsets[2111] = new Collation(2111, "UCA1400_SPANISH_NOPAD_AS_CS", "utf8", 3);
    charsets[2112] = new Collation(2112, "UCA1400_SWEDISH_AI_CI", "utf8", 3);
    charsets[2113] = new Collation(2113, "UCA1400_SWEDISH_AI_CS", "utf8", 3);
    charsets[2114] = new Collation(2114, "UCA1400_SWEDISH_AS_CI", "utf8", 3);
    charsets[2115] = new Collation(2115, "UCA1400_SWEDISH_AS_CS", "utf8", 3);
    charsets[2116] = new Collation(2116, "UCA1400_SWEDISH_NOPAD_AI_CI", "utf8", 3);
    charsets[2117] = new Collation(2117, "UCA1400_SWEDISH_NOPAD_AI_CS", "utf8", 3);
    charsets[2118] = new Collation(2118, "UCA1400_SWEDISH_NOPAD_AS_CI", "utf8", 3);
    charsets[2119] = new Collation(2119, "UCA1400_SWEDISH_NOPAD_AS_CS", "utf8", 3);
    charsets[2120] = new Collation(2120, "UCA1400_TURKISH_AI_CI", "utf8", 3);
    charsets[2121] = new Collation(2121, "UCA1400_TURKISH_AI_CS", "utf8", 3);
    charsets[2122] = new Collation(2122, "UCA1400_TURKISH_AS_CI", "utf8", 3);
    charsets[2123] = new Collation(2123, "UCA1400_TURKISH_AS_CS", "utf8", 3);
    charsets[2124] = new Collation(2124, "UCA1400_TURKISH_NOPAD_AI_CI", "utf8", 3);
    charsets[2125] = new Collation(2125, "UCA1400_TURKISH_NOPAD_AI_CS", "utf8", 3);
    charsets[2126] = new Collation(2126, "UCA1400_TURKISH_NOPAD_AS_CI", "utf8", 3);
    charsets[2127] = new Collation(2127, "UCA1400_TURKISH_NOPAD_AS_CS", "utf8", 3);
    charsets[2128] = new Collation(2128, "UCA1400_CZECH_AI_CI", "utf8", 3);
    charsets[2129] = new Collation(2129, "UCA1400_CZECH_AI_CS", "utf8", 3);
    charsets[2130] = new Collation(2130, "UCA1400_CZECH_AS_CI", "utf8", 3);
    charsets[2131] = new Collation(2131, "UCA1400_CZECH_AS_CS", "utf8", 3);
    charsets[2132] = new Collation(2132, "UCA1400_CZECH_NOPAD_AI_CI", "utf8", 3);
    charsets[2133] = new Collation(2133, "UCA1400_CZECH_NOPAD_AI_CS", "utf8", 3);
    charsets[2134] = new Collation(2134, "UCA1400_CZECH_NOPAD_AS_CI", "utf8", 3);
    charsets[2135] = new Collation(2135, "UCA1400_CZECH_NOPAD_AS_CS", "utf8", 3);
    charsets[2136] = new Collation(2136, "UCA1400_DANISH_AI_CI", "utf8", 3);
    charsets[2137] = new Collation(2137, "UCA1400_DANISH_AI_CS", "utf8", 3);
    charsets[2138] = new Collation(2138, "UCA1400_DANISH_AS_CI", "utf8", 3);
    charsets[2139] = new Collation(2139, "UCA1400_DANISH_AS_CS", "utf8", 3);
    charsets[2140] = new Collation(2140, "UCA1400_DANISH_NOPAD_AI_CI", "utf8", 3);
    charsets[2141] = new Collation(2141, "UCA1400_DANISH_NOPAD_AI_CS", "utf8", 3);
    charsets[2142] = new Collation(2142, "UCA1400_DANISH_NOPAD_AS_CI", "utf8", 3);
    charsets[2143] = new Collation(2143, "UCA1400_DANISH_NOPAD_AS_CS", "utf8", 3);
    charsets[2144] = new Collation(2144, "UCA1400_LITHUANIAN_AI_CI", "utf8", 3);
    charsets[2145] = new Collation(2145, "UCA1400_LITHUANIAN_AI_CS", "utf8", 3);
    charsets[2146] = new Collation(2146, "UCA1400_LITHUANIAN_AS_CI", "utf8", 3);
    charsets[2147] = new Collation(2147, "UCA1400_LITHUANIAN_AS_CS", "utf8", 3);
    charsets[2148] = new Collation(2148, "UCA1400_LITHUANIAN_NOPAD_AI_CI", "utf8", 3);
    charsets[2149] = new Collation(2149, "UCA1400_LITHUANIAN_NOPAD_AI_CS", "utf8", 3);
    charsets[2150] = new Collation(2150, "UCA1400_LITHUANIAN_NOPAD_AS_CI", "utf8", 3);
    charsets[2151] = new Collation(2151, "UCA1400_LITHUANIAN_NOPAD_AS_CS", "utf8", 3);
    charsets[2152] = new Collation(2152, "UCA1400_SLOVAK_AI_CI", "utf8", 3);
    charsets[2153] = new Collation(2153, "UCA1400_SLOVAK_AI_CS", "utf8", 3);
    charsets[2154] = new Collation(2154, "UCA1400_SLOVAK_AS_CI", "utf8", 3);
    charsets[2155] = new Collation(2155, "UCA1400_SLOVAK_AS_CS", "utf8", 3);
    charsets[2156] = new Collation(2156, "UCA1400_SLOVAK_NOPAD_AI_CI", "utf8", 3);
    charsets[2157] = new Collation(2157, "UCA1400_SLOVAK_NOPAD_AI_CS", "utf8", 3);
    charsets[2158] = new Collation(2158, "UCA1400_SLOVAK_NOPAD_AS_CI", "utf8", 3);
    charsets[2159] = new Collation(2159, "UCA1400_SLOVAK_NOPAD_AS_CS", "utf8", 3);
    charsets[2160] = new Collation(2160, "UCA1400_SPANISH2_AI_CI", "utf8", 3);
    charsets[2161] = new Collation(2161, "UCA1400_SPANISH2_AI_CS", "utf8", 3);
    charsets[2162] = new Collation(2162, "UCA1400_SPANISH2_AS_CI", "utf8", 3);
    charsets[2163] = new Collation(2163, "UCA1400_SPANISH2_AS_CS", "utf8", 3);
    charsets[2164] = new Collation(2164, "UCA1400_SPANISH2_NOPAD_AI_CI", "utf8", 3);
    charsets[2165] = new Collation(2165, "UCA1400_SPANISH2_NOPAD_AI_CS", "utf8", 3);
    charsets[2166] = new Collation(2166, "UCA1400_SPANISH2_NOPAD_AS_CI", "utf8", 3);
    charsets[2167] = new Collation(2167, "UCA1400_SPANISH2_NOPAD_AS_CS", "utf8", 3);
    charsets[2168] = new Collation(2168, "UCA1400_ROMAN_AI_CI", "utf8", 3);
    charsets[2169] = new Collation(2169, "UCA1400_ROMAN_AI_CS", "utf8", 3);
    charsets[2170] = new Collation(2170, "UCA1400_ROMAN_AS_CI", "utf8", 3);
    charsets[2171] = new Collation(2171, "UCA1400_ROMAN_AS_CS", "utf8", 3);
    charsets[2172] = new Collation(2172, "UCA1400_ROMAN_NOPAD_AI_CI", "utf8", 3);
    charsets[2173] = new Collation(2173, "UCA1400_ROMAN_NOPAD_AI_CS", "utf8", 3);
    charsets[2174] = new Collation(2174, "UCA1400_ROMAN_NOPAD_AS_CI", "utf8", 3);
    charsets[2175] = new Collation(2175, "UCA1400_ROMAN_NOPAD_AS_CS", "utf8", 3);
    charsets[2176] = new Collation(2176, "UCA1400_PERSIAN_AI_CI", "utf8", 3);
    charsets[2177] = new Collation(2177, "UCA1400_PERSIAN_AI_CS", "utf8", 3);
    charsets[2178] = new Collation(2178, "UCA1400_PERSIAN_AS_CI", "utf8", 3);
    charsets[2179] = new Collation(2179, "UCA1400_PERSIAN_AS_CS", "utf8", 3);
    charsets[2180] = new Collation(2180, "UCA1400_PERSIAN_NOPAD_AI_CI", "utf8", 3);
    charsets[2181] = new Collation(2181, "UCA1400_PERSIAN_NOPAD_AI_CS", "utf8", 3);
    charsets[2182] = new Collation(2182, "UCA1400_PERSIAN_NOPAD_AS_CI", "utf8", 3);
    charsets[2183] = new Collation(2183, "UCA1400_PERSIAN_NOPAD_AS_CS", "utf8", 3);
    charsets[2184] = new Collation(2184, "UCA1400_ESPERANTO_AI_CI", "utf8", 3);
    charsets[2185] = new Collation(2185, "UCA1400_ESPERANTO_AI_CS", "utf8", 3);
    charsets[2186] = new Collation(2186, "UCA1400_ESPERANTO_AS_CI", "utf8", 3);
    charsets[2187] = new Collation(2187, "UCA1400_ESPERANTO_AS_CS", "utf8", 3);
    charsets[2188] = new Collation(2188, "UCA1400_ESPERANTO_NOPAD_AI_CI", "utf8", 3);
    charsets[2189] = new Collation(2189, "UCA1400_ESPERANTO_NOPAD_AI_CS", "utf8", 3);
    charsets[2190] = new Collation(2190, "UCA1400_ESPERANTO_NOPAD_AS_CI", "utf8", 3);
    charsets[2191] = new Collation(2191, "UCA1400_ESPERANTO_NOPAD_AS_CS", "utf8", 3);
    charsets[2192] = new Collation(2192, "UCA1400_HUNGARIAN_AI_CI", "utf8", 3);
    charsets[2193] = new Collation(2193, "UCA1400_HUNGARIAN_AI_CS", "utf8", 3);
    charsets[2194] = new Collation(2194, "UCA1400_HUNGARIAN_AS_CI", "utf8", 3);
    charsets[2195] = new Collation(2195, "UCA1400_HUNGARIAN_AS_CS", "utf8", 3);
    charsets[2196] = new Collation(2196, "UCA1400_HUNGARIAN_NOPAD_AI_CI", "utf8", 3);
    charsets[2197] = new Collation(2197, "UCA1400_HUNGARIAN_NOPAD_AI_CS", "utf8", 3);
    charsets[2198] = new Collation(2198, "UCA1400_HUNGARIAN_NOPAD_AS_CI", "utf8", 3);
    charsets[2199] = new Collation(2199, "UCA1400_HUNGARIAN_NOPAD_AS_CS", "utf8", 3);
    charsets[2200] = new Collation(2200, "UCA1400_SINHALA_AI_CI", "utf8", 3);
    charsets[2201] = new Collation(2201, "UCA1400_SINHALA_AI_CS", "utf8", 3);
    charsets[2202] = new Collation(2202, "UCA1400_SINHALA_AS_CI", "utf8", 3);
    charsets[2203] = new Collation(2203, "UCA1400_SINHALA_AS_CS", "utf8", 3);
    charsets[2204] = new Collation(2204, "UCA1400_SINHALA_NOPAD_AI_CI", "utf8", 3);
    charsets[2205] = new Collation(2205, "UCA1400_SINHALA_NOPAD_AI_CS", "utf8", 3);
    charsets[2206] = new Collation(2206, "UCA1400_SINHALA_NOPAD_AS_CI", "utf8", 3);
    charsets[2207] = new Collation(2207, "UCA1400_SINHALA_NOPAD_AS_CS", "utf8", 3);
    charsets[2208] = new Collation(2208, "UCA1400_GERMAN2_AI_CI", "utf8", 3);
    charsets[2209] = new Collation(2209, "UCA1400_GERMAN2_AI_CS", "utf8", 3);
    charsets[2210] = new Collation(2210, "UCA1400_GERMAN2_AS_CI", "utf8", 3);
    charsets[2211] = new Collation(2211, "UCA1400_GERMAN2_AS_CS", "utf8", 3);
    charsets[2212] = new Collation(2212, "UCA1400_GERMAN2_NOPAD_AI_CI", "utf8", 3);
    charsets[2213] = new Collation(2213, "UCA1400_GERMAN2_NOPAD_AI_CS", "utf8", 3);
    charsets[2214] = new Collation(2214, "UCA1400_GERMAN2_NOPAD_AS_CI", "utf8", 3);
    charsets[2215] = new Collation(2215, "UCA1400_GERMAN2_NOPAD_AS_CS", "utf8", 3);
    charsets[2232] = new Collation(2232, "UCA1400_VIETNAMESE_AI_CI", "utf8", 3);
    charsets[2233] = new Collation(2233, "UCA1400_VIETNAMESE_AI_CS", "utf8", 3);
    charsets[2234] = new Collation(2234, "UCA1400_VIETNAMESE_AS_CI", "utf8", 3);
    charsets[2235] = new Collation(2235, "UCA1400_VIETNAMESE_AS_CS", "utf8", 3);
    charsets[2236] = new Collation(2236, "UCA1400_VIETNAMESE_NOPAD_AI_CI", "utf8", 3);
    charsets[2237] = new Collation(2237, "UCA1400_VIETNAMESE_NOPAD_AI_CS", "utf8", 3);
    charsets[2238] = new Collation(2238, "UCA1400_VIETNAMESE_NOPAD_AS_CI", "utf8", 3);
    charsets[2239] = new Collation(2239, "UCA1400_VIETNAMESE_NOPAD_AS_CS", "utf8", 3);
    charsets[2240] = new Collation(2240, "UCA1400_CROATIAN_AI_CI", "utf8", 3);
    charsets[2241] = new Collation(2241, "UCA1400_CROATIAN_AI_CS", "utf8", 3);
    charsets[2242] = new Collation(2242, "UCA1400_CROATIAN_AS_CI", "utf8", 3);
    charsets[2243] = new Collation(2243, "UCA1400_CROATIAN_AS_CS", "utf8", 3);
    charsets[2244] = new Collation(2244, "UCA1400_CROATIAN_NOPAD_AI_CI", "utf8", 3);
    charsets[2245] = new Collation(2245, "UCA1400_CROATIAN_NOPAD_AI_CS", "utf8", 3);
    charsets[2246] = new Collation(2246, "UCA1400_CROATIAN_NOPAD_AS_CI", "utf8", 3);
    charsets[2247] = new Collation(2247, "UCA1400_CROATIAN_NOPAD_AS_CS", "utf8", 3);
    charsets[2304] = new Collation(2304, "UCA1400_AI_CI", "utf8", 4);
    charsets[2305] = new Collation(2305, "UCA1400_AI_CS", "utf8", 4);
    charsets[2306] = new Collation(2306, "UCA1400_AS_CI", "utf8", 4);
    charsets[2307] = new Collation(2307, "UCA1400_AS_CS", "utf8", 4);
    charsets[2308] = new Collation(2308, "UCA1400_NOPAD_AI_CI", "utf8", 4);
    charsets[2309] = new Collation(2309, "UCA1400_NOPAD_AI_CS", "utf8", 4);
    charsets[2310] = new Collation(2310, "UCA1400_NOPAD_AS_CI", "utf8", 4);
    charsets[2311] = new Collation(2311, "UCA1400_NOPAD_AS_CS", "utf8", 4);
    charsets[2312] = new Collation(2312, "UCA1400_ICELANDIC_AI_CI", "utf8", 4);
    charsets[2313] = new Collation(2313, "UCA1400_ICELANDIC_AI_CS", "utf8", 4);
    charsets[2314] = new Collation(2314, "UCA1400_ICELANDIC_AS_CI", "utf8", 4);
    charsets[2315] = new Collation(2315, "UCA1400_ICELANDIC_AS_CS", "utf8", 4);
    charsets[2316] = new Collation(2316, "UCA1400_ICELANDIC_NOPAD_AI_CI", "utf8", 4);
    charsets[2317] = new Collation(2317, "UCA1400_ICELANDIC_NOPAD_AI_CS", "utf8", 4);
    charsets[2318] = new Collation(2318, "UCA1400_ICELANDIC_NOPAD_AS_CI", "utf8", 4);
    charsets[2319] = new Collation(2319, "UCA1400_ICELANDIC_NOPAD_AS_CS", "utf8", 4);
    charsets[2320] = new Collation(2320, "UCA1400_LATVIAN_AI_CI", "utf8", 4);
    charsets[2321] = new Collation(2321, "UCA1400_LATVIAN_AI_CS", "utf8", 4);
    charsets[2322] = new Collation(2322, "UCA1400_LATVIAN_AS_CI", "utf8", 4);
    charsets[2323] = new Collation(2323, "UCA1400_LATVIAN_AS_CS", "utf8", 4);
    charsets[2324] = new Collation(2324, "UCA1400_LATVIAN_NOPAD_AI_CI", "utf8", 4);
    charsets[2325] = new Collation(2325, "UCA1400_LATVIAN_NOPAD_AI_CS", "utf8", 4);
    charsets[2326] = new Collation(2326, "UCA1400_LATVIAN_NOPAD_AS_CI", "utf8", 4);
    charsets[2327] = new Collation(2327, "UCA1400_LATVIAN_NOPAD_AS_CS", "utf8", 4);
    charsets[2328] = new Collation(2328, "UCA1400_ROMANIAN_AI_CI", "utf8", 4);
    charsets[2329] = new Collation(2329, "UCA1400_ROMANIAN_AI_CS", "utf8", 4);
    charsets[2330] = new Collation(2330, "UCA1400_ROMANIAN_AS_CI", "utf8", 4);
    charsets[2331] = new Collation(2331, "UCA1400_ROMANIAN_AS_CS", "utf8", 4);
    charsets[2332] = new Collation(2332, "UCA1400_ROMANIAN_NOPAD_AI_CI", "utf8", 4);
    charsets[2333] = new Collation(2333, "UCA1400_ROMANIAN_NOPAD_AI_CS", "utf8", 4);
    charsets[2334] = new Collation(2334, "UCA1400_ROMANIAN_NOPAD_AS_CI", "utf8", 4);
    charsets[2335] = new Collation(2335, "UCA1400_ROMANIAN_NOPAD_AS_CS", "utf8", 4);
    charsets[2336] = new Collation(2336, "UCA1400_SLOVENIAN_AI_CI", "utf8", 4);
    charsets[2337] = new Collation(2337, "UCA1400_SLOVENIAN_AI_CS", "utf8", 4);
    charsets[2338] = new Collation(2338, "UCA1400_SLOVENIAN_AS_CI", "utf8", 4);
    charsets[2339] = new Collation(2339, "UCA1400_SLOVENIAN_AS_CS", "utf8", 4);
    charsets[2340] = new Collation(2340, "UCA1400_SLOVENIAN_NOPAD_AI_CI", "utf8", 4);
    charsets[2341] = new Collation(2341, "UCA1400_SLOVENIAN_NOPAD_AI_CS", "utf8", 4);
    charsets[2342] = new Collation(2342, "UCA1400_SLOVENIAN_NOPAD_AS_CI", "utf8", 4);
    charsets[2343] = new Collation(2343, "UCA1400_SLOVENIAN_NOPAD_AS_CS", "utf8", 4);
    charsets[2344] = new Collation(2344, "UCA1400_POLISH_AI_CI", "utf8", 4);
    charsets[2345] = new Collation(2345, "UCA1400_POLISH_AI_CS", "utf8", 4);
    charsets[2346] = new Collation(2346, "UCA1400_POLISH_AS_CI", "utf8", 4);
    charsets[2347] = new Collation(2347, "UCA1400_POLISH_AS_CS", "utf8", 4);
    charsets[2348] = new Collation(2348, "UCA1400_POLISH_NOPAD_AI_CI", "utf8", 4);
    charsets[2349] = new Collation(2349, "UCA1400_POLISH_NOPAD_AI_CS", "utf8", 4);
    charsets[2350] = new Collation(2350, "UCA1400_POLISH_NOPAD_AS_CI", "utf8", 4);
    charsets[2351] = new Collation(2351, "UCA1400_POLISH_NOPAD_AS_CS", "utf8", 4);
    charsets[2352] = new Collation(2352, "UCA1400_ESTONIAN_AI_CI", "utf8", 4);
    charsets[2353] = new Collation(2353, "UCA1400_ESTONIAN_AI_CS", "utf8", 4);
    charsets[2354] = new Collation(2354, "UCA1400_ESTONIAN_AS_CI", "utf8", 4);
    charsets[2355] = new Collation(2355, "UCA1400_ESTONIAN_AS_CS", "utf8", 4);
    charsets[2356] = new Collation(2356, "UCA1400_ESTONIAN_NOPAD_AI_CI", "utf8", 4);
    charsets[2357] = new Collation(2357, "UCA1400_ESTONIAN_NOPAD_AI_CS", "utf8", 4);
    charsets[2358] = new Collation(2358, "UCA1400_ESTONIAN_NOPAD_AS_CI", "utf8", 4);
    charsets[2359] = new Collation(2359, "UCA1400_ESTONIAN_NOPAD_AS_CS", "utf8", 4);
    charsets[2360] = new Collation(2360, "UCA1400_SPANISH_AI_CI", "utf8", 4);
    charsets[2361] = new Collation(2361, "UCA1400_SPANISH_AI_CS", "utf8", 4);
    charsets[2362] = new Collation(2362, "UCA1400_SPANISH_AS_CI", "utf8", 4);
    charsets[2363] = new Collation(2363, "UCA1400_SPANISH_AS_CS", "utf8", 4);
    charsets[2364] = new Collation(2364, "UCA1400_SPANISH_NOPAD_AI_CI", "utf8", 4);
    charsets[2365] = new Collation(2365, "UCA1400_SPANISH_NOPAD_AI_CS", "utf8", 4);
    charsets[2366] = new Collation(2366, "UCA1400_SPANISH_NOPAD_AS_CI", "utf8", 4);
    charsets[2367] = new Collation(2367, "UCA1400_SPANISH_NOPAD_AS_CS", "utf8", 4);
    charsets[2368] = new Collation(2368, "UCA1400_SWEDISH_AI_CI", "utf8", 4);
    charsets[2369] = new Collation(2369, "UCA1400_SWEDISH_AI_CS", "utf8", 4);
    charsets[2370] = new Collation(2370, "UCA1400_SWEDISH_AS_CI", "utf8", 4);
    charsets[2371] = new Collation(2371, "UCA1400_SWEDISH_AS_CS", "utf8", 4);
    charsets[2372] = new Collation(2372, "UCA1400_SWEDISH_NOPAD_AI_CI", "utf8", 4);
    charsets[2373] = new Collation(2373, "UCA1400_SWEDISH_NOPAD_AI_CS", "utf8", 4);
    charsets[2374] = new Collation(2374, "UCA1400_SWEDISH_NOPAD_AS_CI", "utf8", 4);
    charsets[2375] = new Collation(2375, "UCA1400_SWEDISH_NOPAD_AS_CS", "utf8", 4);
    charsets[2376] = new Collation(2376, "UCA1400_TURKISH_AI_CI", "utf8", 4);
    charsets[2377] = new Collation(2377, "UCA1400_TURKISH_AI_CS", "utf8", 4);
    charsets[2378] = new Collation(2378, "UCA1400_TURKISH_AS_CI", "utf8", 4);
    charsets[2379] = new Collation(2379, "UCA1400_TURKISH_AS_CS", "utf8", 4);
    charsets[2380] = new Collation(2380, "UCA1400_TURKISH_NOPAD_AI_CI", "utf8", 4);
    charsets[2381] = new Collation(2381, "UCA1400_TURKISH_NOPAD_AI_CS", "utf8", 4);
    charsets[2382] = new Collation(2382, "UCA1400_TURKISH_NOPAD_AS_CI", "utf8", 4);
    charsets[2383] = new Collation(2383, "UCA1400_TURKISH_NOPAD_AS_CS", "utf8", 4);
    charsets[2384] = new Collation(2384, "UCA1400_CZECH_AI_CI", "utf8", 4);
    charsets[2385] = new Collation(2385, "UCA1400_CZECH_AI_CS", "utf8", 4);
    charsets[2386] = new Collation(2386, "UCA1400_CZECH_AS_CI", "utf8", 4);
    charsets[2387] = new Collation(2387, "UCA1400_CZECH_AS_CS", "utf8", 4);
    charsets[2388] = new Collation(2388, "UCA1400_CZECH_NOPAD_AI_CI", "utf8", 4);
    charsets[2389] = new Collation(2389, "UCA1400_CZECH_NOPAD_AI_CS", "utf8", 4);
    charsets[2390] = new Collation(2390, "UCA1400_CZECH_NOPAD_AS_CI", "utf8", 4);
    charsets[2391] = new Collation(2391, "UCA1400_CZECH_NOPAD_AS_CS", "utf8", 4);
    charsets[2392] = new Collation(2392, "UCA1400_DANISH_AI_CI", "utf8", 4);
    charsets[2393] = new Collation(2393, "UCA1400_DANISH_AI_CS", "utf8", 4);
    charsets[2394] = new Collation(2394, "UCA1400_DANISH_AS_CI", "utf8", 4);
    charsets[2395] = new Collation(2395, "UCA1400_DANISH_AS_CS", "utf8", 4);
    charsets[2396] = new Collation(2396, "UCA1400_DANISH_NOPAD_AI_CI", "utf8", 4);
    charsets[2397] = new Collation(2397, "UCA1400_DANISH_NOPAD_AI_CS", "utf8", 4);
    charsets[2398] = new Collation(2398, "UCA1400_DANISH_NOPAD_AS_CI", "utf8", 4);
    charsets[2399] = new Collation(2399, "UCA1400_DANISH_NOPAD_AS_CS", "utf8", 4);
    charsets[2400] = new Collation(2400, "UCA1400_LITHUANIAN_AI_CI", "utf8", 4);
    charsets[2401] = new Collation(2401, "UCA1400_LITHUANIAN_AI_CS", "utf8", 4);
    charsets[2402] = new Collation(2402, "UCA1400_LITHUANIAN_AS_CI", "utf8", 4);
    charsets[2403] = new Collation(2403, "UCA1400_LITHUANIAN_AS_CS", "utf8", 4);
    charsets[2404] = new Collation(2404, "UCA1400_LITHUANIAN_NOPAD_AI_CI", "utf8", 4);
    charsets[2405] = new Collation(2405, "UCA1400_LITHUANIAN_NOPAD_AI_CS", "utf8", 4);
    charsets[2406] = new Collation(2406, "UCA1400_LITHUANIAN_NOPAD_AS_CI", "utf8", 4);
    charsets[2407] = new Collation(2407, "UCA1400_LITHUANIAN_NOPAD_AS_CS", "utf8", 4);
    charsets[2408] = new Collation(2408, "UCA1400_SLOVAK_AI_CI", "utf8", 4);
    charsets[2409] = new Collation(2409, "UCA1400_SLOVAK_AI_CS", "utf8", 4);
    charsets[2410] = new Collation(2410, "UCA1400_SLOVAK_AS_CI", "utf8", 4);
    charsets[2411] = new Collation(2411, "UCA1400_SLOVAK_AS_CS", "utf8", 4);
    charsets[2412] = new Collation(2412, "UCA1400_SLOVAK_NOPAD_AI_CI", "utf8", 4);
    charsets[2413] = new Collation(2413, "UCA1400_SLOVAK_NOPAD_AI_CS", "utf8", 4);
    charsets[2414] = new Collation(2414, "UCA1400_SLOVAK_NOPAD_AS_CI", "utf8", 4);
    charsets[2415] = new Collation(2415, "UCA1400_SLOVAK_NOPAD_AS_CS", "utf8", 4);
    charsets[2416] = new Collation(2416, "UCA1400_SPANISH2_AI_CI", "utf8", 4);
    charsets[2417] = new Collation(2417, "UCA1400_SPANISH2_AI_CS", "utf8", 4);
    charsets[2418] = new Collation(2418, "UCA1400_SPANISH2_AS_CI", "utf8", 4);
    charsets[2419] = new Collation(2419, "UCA1400_SPANISH2_AS_CS", "utf8", 4);
    charsets[2420] = new Collation(2420, "UCA1400_SPANISH2_NOPAD_AI_CI", "utf8", 4);
    charsets[2421] = new Collation(2421, "UCA1400_SPANISH2_NOPAD_AI_CS", "utf8", 4);
    charsets[2422] = new Collation(2422, "UCA1400_SPANISH2_NOPAD_AS_CI", "utf8", 4);
    charsets[2423] = new Collation(2423, "UCA1400_SPANISH2_NOPAD_AS_CS", "utf8", 4);
    charsets[2424] = new Collation(2424, "UCA1400_ROMAN_AI_CI", "utf8", 4);
    charsets[2425] = new Collation(2425, "UCA1400_ROMAN_AI_CS", "utf8", 4);
    charsets[2426] = new Collation(2426, "UCA1400_ROMAN_AS_CI", "utf8", 4);
    charsets[2427] = new Collation(2427, "UCA1400_ROMAN_AS_CS", "utf8", 4);
    charsets[2428] = new Collation(2428, "UCA1400_ROMAN_NOPAD_AI_CI", "utf8", 4);
    charsets[2429] = new Collation(2429, "UCA1400_ROMAN_NOPAD_AI_CS", "utf8", 4);
    charsets[2430] = new Collation(2430, "UCA1400_ROMAN_NOPAD_AS_CI", "utf8", 4);
    charsets[2431] = new Collation(2431, "UCA1400_ROMAN_NOPAD_AS_CS", "utf8", 4);
    charsets[2432] = new Collation(2432, "UCA1400_PERSIAN_AI_CI", "utf8", 4);
    charsets[2433] = new Collation(2433, "UCA1400_PERSIAN_AI_CS", "utf8", 4);
    charsets[2434] = new Collation(2434, "UCA1400_PERSIAN_AS_CI", "utf8", 4);
    charsets[2435] = new Collation(2435, "UCA1400_PERSIAN_AS_CS", "utf8", 4);
    charsets[2436] = new Collation(2436, "UCA1400_PERSIAN_NOPAD_AI_CI", "utf8", 4);
    charsets[2437] = new Collation(2437, "UCA1400_PERSIAN_NOPAD_AI_CS", "utf8", 4);
    charsets[2438] = new Collation(2438, "UCA1400_PERSIAN_NOPAD_AS_CI", "utf8", 4);
    charsets[2439] = new Collation(2439, "UCA1400_PERSIAN_NOPAD_AS_CS", "utf8", 4);
    charsets[2440] = new Collation(2440, "UCA1400_ESPERANTO_AI_CI", "utf8", 4);
    charsets[2441] = new Collation(2441, "UCA1400_ESPERANTO_AI_CS", "utf8", 4);
    charsets[2442] = new Collation(2442, "UCA1400_ESPERANTO_AS_CI", "utf8", 4);
    charsets[2443] = new Collation(2443, "UCA1400_ESPERANTO_AS_CS", "utf8", 4);
    charsets[2444] = new Collation(2444, "UCA1400_ESPERANTO_NOPAD_AI_CI", "utf8", 4);
    charsets[2445] = new Collation(2445, "UCA1400_ESPERANTO_NOPAD_AI_CS", "utf8", 4);
    charsets[2446] = new Collation(2446, "UCA1400_ESPERANTO_NOPAD_AS_CI", "utf8", 4);
    charsets[2447] = new Collation(2447, "UCA1400_ESPERANTO_NOPAD_AS_CS", "utf8", 4);
    charsets[2448] = new Collation(2448, "UCA1400_HUNGARIAN_AI_CI", "utf8", 4);
    charsets[2449] = new Collation(2449, "UCA1400_HUNGARIAN_AI_CS", "utf8", 4);
    charsets[2450] = new Collation(2450, "UCA1400_HUNGARIAN_AS_CI", "utf8", 4);
    charsets[2451] = new Collation(2451, "UCA1400_HUNGARIAN_AS_CS", "utf8", 4);
    charsets[2452] = new Collation(2452, "UCA1400_HUNGARIAN_NOPAD_AI_CI", "utf8", 4);
    charsets[2453] = new Collation(2453, "UCA1400_HUNGARIAN_NOPAD_AI_CS", "utf8", 4);
    charsets[2454] = new Collation(2454, "UCA1400_HUNGARIAN_NOPAD_AS_CI", "utf8", 4);
    charsets[2455] = new Collation(2455, "UCA1400_HUNGARIAN_NOPAD_AS_CS", "utf8", 4);
    charsets[2456] = new Collation(2456, "UCA1400_SINHALA_AI_CI", "utf8", 4);
    charsets[2457] = new Collation(2457, "UCA1400_SINHALA_AI_CS", "utf8", 4);
    charsets[2458] = new Collation(2458, "UCA1400_SINHALA_AS_CI", "utf8", 4);
    charsets[2459] = new Collation(2459, "UCA1400_SINHALA_AS_CS", "utf8", 4);
    charsets[2460] = new Collation(2460, "UCA1400_SINHALA_NOPAD_AI_CI", "utf8", 4);
    charsets[2461] = new Collation(2461, "UCA1400_SINHALA_NOPAD_AI_CS", "utf8", 4);
    charsets[2462] = new Collation(2462, "UCA1400_SINHALA_NOPAD_AS_CI", "utf8", 4);
    charsets[2463] = new Collation(2463, "UCA1400_SINHALA_NOPAD_AS_CS", "utf8", 4);
    charsets[2464] = new Collation(2464, "UCA1400_GERMAN2_AI_CI", "utf8", 4);
    charsets[2465] = new Collation(2465, "UCA1400_GERMAN2_AI_CS", "utf8", 4);
    charsets[2466] = new Collation(2466, "UCA1400_GERMAN2_AS_CI", "utf8", 4);
    charsets[2467] = new Collation(2467, "UCA1400_GERMAN2_AS_CS", "utf8", 4);
    charsets[2468] = new Collation(2468, "UCA1400_GERMAN2_NOPAD_AI_CI", "utf8", 4);
    charsets[2469] = new Collation(2469, "UCA1400_GERMAN2_NOPAD_AI_CS", "utf8", 4);
    charsets[2470] = new Collation(2470, "UCA1400_GERMAN2_NOPAD_AS_CI", "utf8", 4);
    charsets[2471] = new Collation(2471, "UCA1400_GERMAN2_NOPAD_AS_CS", "utf8", 4);
    charsets[2488] = new Collation(2488, "UCA1400_VIETNAMESE_AI_CI", "utf8", 4);
    charsets[2489] = new Collation(2489, "UCA1400_VIETNAMESE_AI_CS", "utf8", 4);
    charsets[2490] = new Collation(2490, "UCA1400_VIETNAMESE_AS_CI", "utf8", 4);
    charsets[2491] = new Collation(2491, "UCA1400_VIETNAMESE_AS_CS", "utf8", 4);
    charsets[2492] = new Collation(2492, "UCA1400_VIETNAMESE_NOPAD_AI_CI", "utf8", 4);
    charsets[2493] = new Collation(2493, "UCA1400_VIETNAMESE_NOPAD_AI_CS", "utf8", 4);
    charsets[2494] = new Collation(2494, "UCA1400_VIETNAMESE_NOPAD_AS_CI", "utf8", 4);
    charsets[2495] = new Collation(2495, "UCA1400_VIETNAMESE_NOPAD_AS_CS", "utf8", 4);
    charsets[2496] = new Collation(2496, "UCA1400_CROATIAN_AI_CI", "utf8", 4);
    charsets[2497] = new Collation(2497, "UCA1400_CROATIAN_AI_CS", "utf8", 4);
    charsets[2498] = new Collation(2498, "UCA1400_CROATIAN_AS_CI", "utf8", 4);
    charsets[2499] = new Collation(2499, "UCA1400_CROATIAN_AS_CS", "utf8", 4);
    charsets[2500] = new Collation(2500, "UCA1400_CROATIAN_NOPAD_AI_CI", "utf8", 4);
    charsets[2501] = new Collation(2501, "UCA1400_CROATIAN_NOPAD_AI_CS", "utf8", 4);
    charsets[2502] = new Collation(2502, "UCA1400_CROATIAN_NOPAD_AS_CI", "utf8", 4);
    charsets[2503] = new Collation(2503, "UCA1400_CROATIAN_NOPAD_AS_CS", "utf8", 4);
    charsets[2560] = new Collation(2560, "UCA1400_AI_CI", "ucs2", 2);
    charsets[2561] = new Collation(2561, "UCA1400_AI_CS", "ucs2", 2);
    charsets[2562] = new Collation(2562, "UCA1400_AS_CI", "ucs2", 2);
    charsets[2563] = new Collation(2563, "UCA1400_AS_CS", "ucs2", 2);
    charsets[2564] = new Collation(2564, "UCA1400_NOPAD_AI_CI", "ucs2", 2);
    charsets[2565] = new Collation(2565, "UCA1400_NOPAD_AI_CS", "ucs2", 2);
    charsets[2566] = new Collation(2566, "UCA1400_NOPAD_AS_CI", "ucs2", 2);
    charsets[2567] = new Collation(2567, "UCA1400_NOPAD_AS_CS", "ucs2", 2);
    charsets[2568] = new Collation(2568, "UCA1400_ICELANDIC_AI_CI", "ucs2", 2);
    charsets[2569] = new Collation(2569, "UCA1400_ICELANDIC_AI_CS", "ucs2", 2);
    charsets[2570] = new Collation(2570, "UCA1400_ICELANDIC_AS_CI", "ucs2", 2);
    charsets[2571] = new Collation(2571, "UCA1400_ICELANDIC_AS_CS", "ucs2", 2);
    charsets[2572] = new Collation(2572, "UCA1400_ICELANDIC_NOPAD_AI_CI", "ucs2", 2);
    charsets[2573] = new Collation(2573, "UCA1400_ICELANDIC_NOPAD_AI_CS", "ucs2", 2);
    charsets[2574] = new Collation(2574, "UCA1400_ICELANDIC_NOPAD_AS_CI", "ucs2", 2);
    charsets[2575] = new Collation(2575, "UCA1400_ICELANDIC_NOPAD_AS_CS", "ucs2", 2);
    charsets[2576] = new Collation(2576, "UCA1400_LATVIAN_AI_CI", "ucs2", 2);
    charsets[2577] = new Collation(2577, "UCA1400_LATVIAN_AI_CS", "ucs2", 2);
    charsets[2578] = new Collation(2578, "UCA1400_LATVIAN_AS_CI", "ucs2", 2);
    charsets[2579] = new Collation(2579, "UCA1400_LATVIAN_AS_CS", "ucs2", 2);
    charsets[2580] = new Collation(2580, "UCA1400_LATVIAN_NOPAD_AI_CI", "ucs2", 2);
    charsets[2581] = new Collation(2581, "UCA1400_LATVIAN_NOPAD_AI_CS", "ucs2", 2);
    charsets[2582] = new Collation(2582, "UCA1400_LATVIAN_NOPAD_AS_CI", "ucs2", 2);
    charsets[2583] = new Collation(2583, "UCA1400_LATVIAN_NOPAD_AS_CS", "ucs2", 2);
    charsets[2584] = new Collation(2584, "UCA1400_ROMANIAN_AI_CI", "ucs2", 2);
    charsets[2585] = new Collation(2585, "UCA1400_ROMANIAN_AI_CS", "ucs2", 2);
    charsets[2586] = new Collation(2586, "UCA1400_ROMANIAN_AS_CI", "ucs2", 2);
    charsets[2587] = new Collation(2587, "UCA1400_ROMANIAN_AS_CS", "ucs2", 2);
    charsets[2588] = new Collation(2588, "UCA1400_ROMANIAN_NOPAD_AI_CI", "ucs2", 2);
    charsets[2589] = new Collation(2589, "UCA1400_ROMANIAN_NOPAD_AI_CS", "ucs2", 2);
    charsets[2590] = new Collation(2590, "UCA1400_ROMANIAN_NOPAD_AS_CI", "ucs2", 2);
    charsets[2591] = new Collation(2591, "UCA1400_ROMANIAN_NOPAD_AS_CS", "ucs2", 2);
    charsets[2592] = new Collation(2592, "UCA1400_SLOVENIAN_AI_CI", "ucs2", 2);
    charsets[2593] = new Collation(2593, "UCA1400_SLOVENIAN_AI_CS", "ucs2", 2);
    charsets[2594] = new Collation(2594, "UCA1400_SLOVENIAN_AS_CI", "ucs2", 2);
    charsets[2595] = new Collation(2595, "UCA1400_SLOVENIAN_AS_CS", "ucs2", 2);
    charsets[2596] = new Collation(2596, "UCA1400_SLOVENIAN_NOPAD_AI_CI", "ucs2", 2);
    charsets[2597] = new Collation(2597, "UCA1400_SLOVENIAN_NOPAD_AI_CS", "ucs2", 2);
    charsets[2598] = new Collation(2598, "UCA1400_SLOVENIAN_NOPAD_AS_CI", "ucs2", 2);
    charsets[2599] = new Collation(2599, "UCA1400_SLOVENIAN_NOPAD_AS_CS", "ucs2", 2);
    charsets[2600] = new Collation(2600, "UCA1400_POLISH_AI_CI", "ucs2", 2);
    charsets[2601] = new Collation(2601, "UCA1400_POLISH_AI_CS", "ucs2", 2);
    charsets[2602] = new Collation(2602, "UCA1400_POLISH_AS_CI", "ucs2", 2);
    charsets[2603] = new Collation(2603, "UCA1400_POLISH_AS_CS", "ucs2", 2);
    charsets[2604] = new Collation(2604, "UCA1400_POLISH_NOPAD_AI_CI", "ucs2", 2);
    charsets[2605] = new Collation(2605, "UCA1400_POLISH_NOPAD_AI_CS", "ucs2", 2);
    charsets[2606] = new Collation(2606, "UCA1400_POLISH_NOPAD_AS_CI", "ucs2", 2);
    charsets[2607] = new Collation(2607, "UCA1400_POLISH_NOPAD_AS_CS", "ucs2", 2);
    charsets[2608] = new Collation(2608, "UCA1400_ESTONIAN_AI_CI", "ucs2", 2);
    charsets[2609] = new Collation(2609, "UCA1400_ESTONIAN_AI_CS", "ucs2", 2);
    charsets[2610] = new Collation(2610, "UCA1400_ESTONIAN_AS_CI", "ucs2", 2);
    charsets[2611] = new Collation(2611, "UCA1400_ESTONIAN_AS_CS", "ucs2", 2);
    charsets[2612] = new Collation(2612, "UCA1400_ESTONIAN_NOPAD_AI_CI", "ucs2", 2);
    charsets[2613] = new Collation(2613, "UCA1400_ESTONIAN_NOPAD_AI_CS", "ucs2", 2);
    charsets[2614] = new Collation(2614, "UCA1400_ESTONIAN_NOPAD_AS_CI", "ucs2", 2);
    charsets[2615] = new Collation(2615, "UCA1400_ESTONIAN_NOPAD_AS_CS", "ucs2", 2);
    charsets[2616] = new Collation(2616, "UCA1400_SPANISH_AI_CI", "ucs2", 2);
    charsets[2617] = new Collation(2617, "UCA1400_SPANISH_AI_CS", "ucs2", 2);
    charsets[2618] = new Collation(2618, "UCA1400_SPANISH_AS_CI", "ucs2", 2);
    charsets[2619] = new Collation(2619, "UCA1400_SPANISH_AS_CS", "ucs2", 2);
    charsets[2620] = new Collation(2620, "UCA1400_SPANISH_NOPAD_AI_CI", "ucs2", 2);
    charsets[2621] = new Collation(2621, "UCA1400_SPANISH_NOPAD_AI_CS", "ucs2", 2);
    charsets[2622] = new Collation(2622, "UCA1400_SPANISH_NOPAD_AS_CI", "ucs2", 2);
    charsets[2623] = new Collation(2623, "UCA1400_SPANISH_NOPAD_AS_CS", "ucs2", 2);
    charsets[2624] = new Collation(2624, "UCA1400_SWEDISH_AI_CI", "ucs2", 2);
    charsets[2625] = new Collation(2625, "UCA1400_SWEDISH_AI_CS", "ucs2", 2);
    charsets[2626] = new Collation(2626, "UCA1400_SWEDISH_AS_CI", "ucs2", 2);
    charsets[2627] = new Collation(2627, "UCA1400_SWEDISH_AS_CS", "ucs2", 2);
    charsets[2628] = new Collation(2628, "UCA1400_SWEDISH_NOPAD_AI_CI", "ucs2", 2);
    charsets[2629] = new Collation(2629, "UCA1400_SWEDISH_NOPAD_AI_CS", "ucs2", 2);
    charsets[2630] = new Collation(2630, "UCA1400_SWEDISH_NOPAD_AS_CI", "ucs2", 2);
    charsets[2631] = new Collation(2631, "UCA1400_SWEDISH_NOPAD_AS_CS", "ucs2", 2);
    charsets[2632] = new Collation(2632, "UCA1400_TURKISH_AI_CI", "ucs2", 2);
    charsets[2633] = new Collation(2633, "UCA1400_TURKISH_AI_CS", "ucs2", 2);
    charsets[2634] = new Collation(2634, "UCA1400_TURKISH_AS_CI", "ucs2", 2);
    charsets[2635] = new Collation(2635, "UCA1400_TURKISH_AS_CS", "ucs2", 2);
    charsets[2636] = new Collation(2636, "UCA1400_TURKISH_NOPAD_AI_CI", "ucs2", 2);
    charsets[2637] = new Collation(2637, "UCA1400_TURKISH_NOPAD_AI_CS", "ucs2", 2);
    charsets[2638] = new Collation(2638, "UCA1400_TURKISH_NOPAD_AS_CI", "ucs2", 2);
    charsets[2639] = new Collation(2639, "UCA1400_TURKISH_NOPAD_AS_CS", "ucs2", 2);
    charsets[2640] = new Collation(2640, "UCA1400_CZECH_AI_CI", "ucs2", 2);
    charsets[2641] = new Collation(2641, "UCA1400_CZECH_AI_CS", "ucs2", 2);
    charsets[2642] = new Collation(2642, "UCA1400_CZECH_AS_CI", "ucs2", 2);
    charsets[2643] = new Collation(2643, "UCA1400_CZECH_AS_CS", "ucs2", 2);
    charsets[2644] = new Collation(2644, "UCA1400_CZECH_NOPAD_AI_CI", "ucs2", 2);
    charsets[2645] = new Collation(2645, "UCA1400_CZECH_NOPAD_AI_CS", "ucs2", 2);
    charsets[2646] = new Collation(2646, "UCA1400_CZECH_NOPAD_AS_CI", "ucs2", 2);
    charsets[2647] = new Collation(2647, "UCA1400_CZECH_NOPAD_AS_CS", "ucs2", 2);
    charsets[2648] = new Collation(2648, "UCA1400_DANISH_AI_CI", "ucs2", 2);
    charsets[2649] = new Collation(2649, "UCA1400_DANISH_AI_CS", "ucs2", 2);
    charsets[2650] = new Collation(2650, "UCA1400_DANISH_AS_CI", "ucs2", 2);
    charsets[2651] = new Collation(2651, "UCA1400_DANISH_AS_CS", "ucs2", 2);
    charsets[2652] = new Collation(2652, "UCA1400_DANISH_NOPAD_AI_CI", "ucs2", 2);
    charsets[2653] = new Collation(2653, "UCA1400_DANISH_NOPAD_AI_CS", "ucs2", 2);
    charsets[2654] = new Collation(2654, "UCA1400_DANISH_NOPAD_AS_CI", "ucs2", 2);
    charsets[2655] = new Collation(2655, "UCA1400_DANISH_NOPAD_AS_CS", "ucs2", 2);
    charsets[2656] = new Collation(2656, "UCA1400_LITHUANIAN_AI_CI", "ucs2", 2);
    charsets[2657] = new Collation(2657, "UCA1400_LITHUANIAN_AI_CS", "ucs2", 2);
    charsets[2658] = new Collation(2658, "UCA1400_LITHUANIAN_AS_CI", "ucs2", 2);
    charsets[2659] = new Collation(2659, "UCA1400_LITHUANIAN_AS_CS", "ucs2", 2);
    charsets[2660] = new Collation(2660, "UCA1400_LITHUANIAN_NOPAD_AI_CI", "ucs2", 2);
    charsets[2661] = new Collation(2661, "UCA1400_LITHUANIAN_NOPAD_AI_CS", "ucs2", 2);
    charsets[2662] = new Collation(2662, "UCA1400_LITHUANIAN_NOPAD_AS_CI", "ucs2", 2);
    charsets[2663] = new Collation(2663, "UCA1400_LITHUANIAN_NOPAD_AS_CS", "ucs2", 2);
    charsets[2664] = new Collation(2664, "UCA1400_SLOVAK_AI_CI", "ucs2", 2);
    charsets[2665] = new Collation(2665, "UCA1400_SLOVAK_AI_CS", "ucs2", 2);
    charsets[2666] = new Collation(2666, "UCA1400_SLOVAK_AS_CI", "ucs2", 2);
    charsets[2667] = new Collation(2667, "UCA1400_SLOVAK_AS_CS", "ucs2", 2);
    charsets[2668] = new Collation(2668, "UCA1400_SLOVAK_NOPAD_AI_CI", "ucs2", 2);
    charsets[2669] = new Collation(2669, "UCA1400_SLOVAK_NOPAD_AI_CS", "ucs2", 2);
    charsets[2670] = new Collation(2670, "UCA1400_SLOVAK_NOPAD_AS_CI", "ucs2", 2);
    charsets[2671] = new Collation(2671, "UCA1400_SLOVAK_NOPAD_AS_CS", "ucs2", 2);
    charsets[2672] = new Collation(2672, "UCA1400_SPANISH2_AI_CI", "ucs2", 2);
    charsets[2673] = new Collation(2673, "UCA1400_SPANISH2_AI_CS", "ucs2", 2);
    charsets[2674] = new Collation(2674, "UCA1400_SPANISH2_AS_CI", "ucs2", 2);
    charsets[2675] = new Collation(2675, "UCA1400_SPANISH2_AS_CS", "ucs2", 2);
    charsets[2676] = new Collation(2676, "UCA1400_SPANISH2_NOPAD_AI_CI", "ucs2", 2);
    charsets[2677] = new Collation(2677, "UCA1400_SPANISH2_NOPAD_AI_CS", "ucs2", 2);
    charsets[2678] = new Collation(2678, "UCA1400_SPANISH2_NOPAD_AS_CI", "ucs2", 2);
    charsets[2679] = new Collation(2679, "UCA1400_SPANISH2_NOPAD_AS_CS", "ucs2", 2);
    charsets[2680] = new Collation(2680, "UCA1400_ROMAN_AI_CI", "ucs2", 2);
    charsets[2681] = new Collation(2681, "UCA1400_ROMAN_AI_CS", "ucs2", 2);
    charsets[2682] = new Collation(2682, "UCA1400_ROMAN_AS_CI", "ucs2", 2);
    charsets[2683] = new Collation(2683, "UCA1400_ROMAN_AS_CS", "ucs2", 2);
    charsets[2684] = new Collation(2684, "UCA1400_ROMAN_NOPAD_AI_CI", "ucs2", 2);
    charsets[2685] = new Collation(2685, "UCA1400_ROMAN_NOPAD_AI_CS", "ucs2", 2);
    charsets[2686] = new Collation(2686, "UCA1400_ROMAN_NOPAD_AS_CI", "ucs2", 2);
    charsets[2687] = new Collation(2687, "UCA1400_ROMAN_NOPAD_AS_CS", "ucs2", 2);
    charsets[2688] = new Collation(2688, "UCA1400_PERSIAN_AI_CI", "ucs2", 2);
    charsets[2689] = new Collation(2689, "UCA1400_PERSIAN_AI_CS", "ucs2", 2);
    charsets[2690] = new Collation(2690, "UCA1400_PERSIAN_AS_CI", "ucs2", 2);
    charsets[2691] = new Collation(2691, "UCA1400_PERSIAN_AS_CS", "ucs2", 2);
    charsets[2692] = new Collation(2692, "UCA1400_PERSIAN_NOPAD_AI_CI", "ucs2", 2);
    charsets[2693] = new Collation(2693, "UCA1400_PERSIAN_NOPAD_AI_CS", "ucs2", 2);
    charsets[2694] = new Collation(2694, "UCA1400_PERSIAN_NOPAD_AS_CI", "ucs2", 2);
    charsets[2695] = new Collation(2695, "UCA1400_PERSIAN_NOPAD_AS_CS", "ucs2", 2);
    charsets[2696] = new Collation(2696, "UCA1400_ESPERANTO_AI_CI", "ucs2", 2);
    charsets[2697] = new Collation(2697, "UCA1400_ESPERANTO_AI_CS", "ucs2", 2);
    charsets[2698] = new Collation(2698, "UCA1400_ESPERANTO_AS_CI", "ucs2", 2);
    charsets[2699] = new Collation(2699, "UCA1400_ESPERANTO_AS_CS", "ucs2", 2);
    charsets[2700] = new Collation(2700, "UCA1400_ESPERANTO_NOPAD_AI_CI", "ucs2", 2);
    charsets[2701] = new Collation(2701, "UCA1400_ESPERANTO_NOPAD_AI_CS", "ucs2", 2);
    charsets[2702] = new Collation(2702, "UCA1400_ESPERANTO_NOPAD_AS_CI", "ucs2", 2);
    charsets[2703] = new Collation(2703, "UCA1400_ESPERANTO_NOPAD_AS_CS", "ucs2", 2);
    charsets[2704] = new Collation(2704, "UCA1400_HUNGARIAN_AI_CI", "ucs2", 2);
    charsets[2705] = new Collation(2705, "UCA1400_HUNGARIAN_AI_CS", "ucs2", 2);
    charsets[2706] = new Collation(2706, "UCA1400_HUNGARIAN_AS_CI", "ucs2", 2);
    charsets[2707] = new Collation(2707, "UCA1400_HUNGARIAN_AS_CS", "ucs2", 2);
    charsets[2708] = new Collation(2708, "UCA1400_HUNGARIAN_NOPAD_AI_CI", "ucs2", 2);
    charsets[2709] = new Collation(2709, "UCA1400_HUNGARIAN_NOPAD_AI_CS", "ucs2", 2);
    charsets[2710] = new Collation(2710, "UCA1400_HUNGARIAN_NOPAD_AS_CI", "ucs2", 2);
    charsets[2711] = new Collation(2711, "UCA1400_HUNGARIAN_NOPAD_AS_CS", "ucs2", 2);
    charsets[2712] = new Collation(2712, "UCA1400_SINHALA_AI_CI", "ucs2", 2);
    charsets[2713] = new Collation(2713, "UCA1400_SINHALA_AI_CS", "ucs2", 2);
    charsets[2714] = new Collation(2714, "UCA1400_SINHALA_AS_CI", "ucs2", 2);
    charsets[2715] = new Collation(2715, "UCA1400_SINHALA_AS_CS", "ucs2", 2);
    charsets[2716] = new Collation(2716, "UCA1400_SINHALA_NOPAD_AI_CI", "ucs2", 2);
    charsets[2717] = new Collation(2717, "UCA1400_SINHALA_NOPAD_AI_CS", "ucs2", 2);
    charsets[2718] = new Collation(2718, "UCA1400_SINHALA_NOPAD_AS_CI", "ucs2", 2);
    charsets[2719] = new Collation(2719, "UCA1400_SINHALA_NOPAD_AS_CS", "ucs2", 2);
    charsets[2720] = new Collation(2720, "UCA1400_GERMAN2_AI_CI", "ucs2", 2);
    charsets[2721] = new Collation(2721, "UCA1400_GERMAN2_AI_CS", "ucs2", 2);
    charsets[2722] = new Collation(2722, "UCA1400_GERMAN2_AS_CI", "ucs2", 2);
    charsets[2723] = new Collation(2723, "UCA1400_GERMAN2_AS_CS", "ucs2", 2);
    charsets[2724] = new Collation(2724, "UCA1400_GERMAN2_NOPAD_AI_CI", "ucs2", 2);
    charsets[2725] = new Collation(2725, "UCA1400_GERMAN2_NOPAD_AI_CS", "ucs2", 2);
    charsets[2726] = new Collation(2726, "UCA1400_GERMAN2_NOPAD_AS_CI", "ucs2", 2);
    charsets[2727] = new Collation(2727, "UCA1400_GERMAN2_NOPAD_AS_CS", "ucs2", 2);
    charsets[2744] = new Collation(2744, "UCA1400_VIETNAMESE_AI_CI", "ucs2", 2);
    charsets[2745] = new Collation(2745, "UCA1400_VIETNAMESE_AI_CS", "ucs2", 2);
    charsets[2746] = new Collation(2746, "UCA1400_VIETNAMESE_AS_CI", "ucs2", 2);
    charsets[2747] = new Collation(2747, "UCA1400_VIETNAMESE_AS_CS", "ucs2", 2);
    charsets[2748] = new Collation(2748, "UCA1400_VIETNAMESE_NOPAD_AI_CI", "ucs2", 2);
    charsets[2749] = new Collation(2749, "UCA1400_VIETNAMESE_NOPAD_AI_CS", "ucs2", 2);
    charsets[2750] = new Collation(2750, "UCA1400_VIETNAMESE_NOPAD_AS_CI", "ucs2", 2);
    charsets[2751] = new Collation(2751, "UCA1400_VIETNAMESE_NOPAD_AS_CS", "ucs2", 2);
    charsets[2752] = new Collation(2752, "UCA1400_CROATIAN_AI_CI", "ucs2", 2);
    charsets[2753] = new Collation(2753, "UCA1400_CROATIAN_AI_CS", "ucs2", 2);
    charsets[2754] = new Collation(2754, "UCA1400_CROATIAN_AS_CI", "ucs2", 2);
    charsets[2755] = new Collation(2755, "UCA1400_CROATIAN_AS_CS", "ucs2", 2);
    charsets[2756] = new Collation(2756, "UCA1400_CROATIAN_NOPAD_AI_CI", "ucs2", 2);
    charsets[2757] = new Collation(2757, "UCA1400_CROATIAN_NOPAD_AI_CS", "ucs2", 2);
    charsets[2758] = new Collation(2758, "UCA1400_CROATIAN_NOPAD_AS_CI", "ucs2", 2);
    charsets[2759] = new Collation(2759, "UCA1400_CROATIAN_NOPAD_AS_CS", "ucs2", 2);
    charsets[2816] = new Collation(2816, "UCA1400_AI_CI", "utf16", 4);
    charsets[2817] = new Collation(2817, "UCA1400_AI_CS", "utf16", 4);
    charsets[2818] = new Collation(2818, "UCA1400_AS_CI", "utf16", 4);
    charsets[2819] = new Collation(2819, "UCA1400_AS_CS", "utf16", 4);
    charsets[2820] = new Collation(2820, "UCA1400_NOPAD_AI_CI", "utf16", 4);
    charsets[2821] = new Collation(2821, "UCA1400_NOPAD_AI_CS", "utf16", 4);
    charsets[2822] = new Collation(2822, "UCA1400_NOPAD_AS_CI", "utf16", 4);
    charsets[2823] = new Collation(2823, "UCA1400_NOPAD_AS_CS", "utf16", 4);
    charsets[2824] = new Collation(2824, "UCA1400_ICELANDIC_AI_CI", "utf16", 4);
    charsets[2825] = new Collation(2825, "UCA1400_ICELANDIC_AI_CS", "utf16", 4);
    charsets[2826] = new Collation(2826, "UCA1400_ICELANDIC_AS_CI", "utf16", 4);
    charsets[2827] = new Collation(2827, "UCA1400_ICELANDIC_AS_CS", "utf16", 4);
    charsets[2828] = new Collation(2828, "UCA1400_ICELANDIC_NOPAD_AI_CI", "utf16", 4);
    charsets[2829] = new Collation(2829, "UCA1400_ICELANDIC_NOPAD_AI_CS", "utf16", 4);
    charsets[2830] = new Collation(2830, "UCA1400_ICELANDIC_NOPAD_AS_CI", "utf16", 4);
    charsets[2831] = new Collation(2831, "UCA1400_ICELANDIC_NOPAD_AS_CS", "utf16", 4);
    charsets[2832] = new Collation(2832, "UCA1400_LATVIAN_AI_CI", "utf16", 4);
    charsets[2833] = new Collation(2833, "UCA1400_LATVIAN_AI_CS", "utf16", 4);
    charsets[2834] = new Collation(2834, "UCA1400_LATVIAN_AS_CI", "utf16", 4);
    charsets[2835] = new Collation(2835, "UCA1400_LATVIAN_AS_CS", "utf16", 4);
    charsets[2836] = new Collation(2836, "UCA1400_LATVIAN_NOPAD_AI_CI", "utf16", 4);
    charsets[2837] = new Collation(2837, "UCA1400_LATVIAN_NOPAD_AI_CS", "utf16", 4);
    charsets[2838] = new Collation(2838, "UCA1400_LATVIAN_NOPAD_AS_CI", "utf16", 4);
    charsets[2839] = new Collation(2839, "UCA1400_LATVIAN_NOPAD_AS_CS", "utf16", 4);
    charsets[2840] = new Collation(2840, "UCA1400_ROMANIAN_AI_CI", "utf16", 4);
    charsets[2841] = new Collation(2841, "UCA1400_ROMANIAN_AI_CS", "utf16", 4);
    charsets[2842] = new Collation(2842, "UCA1400_ROMANIAN_AS_CI", "utf16", 4);
    charsets[2843] = new Collation(2843, "UCA1400_ROMANIAN_AS_CS", "utf16", 4);
    charsets[2844] = new Collation(2844, "UCA1400_ROMANIAN_NOPAD_AI_CI", "utf16", 4);
    charsets[2845] = new Collation(2845, "UCA1400_ROMANIAN_NOPAD_AI_CS", "utf16", 4);
    charsets[2846] = new Collation(2846, "UCA1400_ROMANIAN_NOPAD_AS_CI", "utf16", 4);
    charsets[2847] = new Collation(2847, "UCA1400_ROMANIAN_NOPAD_AS_CS", "utf16", 4);
    charsets[2848] = new Collation(2848, "UCA1400_SLOVENIAN_AI_CI", "utf16", 4);
    charsets[2849] = new Collation(2849, "UCA1400_SLOVENIAN_AI_CS", "utf16", 4);
    charsets[2850] = new Collation(2850, "UCA1400_SLOVENIAN_AS_CI", "utf16", 4);
    charsets[2851] = new Collation(2851, "UCA1400_SLOVENIAN_AS_CS", "utf16", 4);
    charsets[2852] = new Collation(2852, "UCA1400_SLOVENIAN_NOPAD_AI_CI", "utf16", 4);
    charsets[2853] = new Collation(2853, "UCA1400_SLOVENIAN_NOPAD_AI_CS", "utf16", 4);
    charsets[2854] = new Collation(2854, "UCA1400_SLOVENIAN_NOPAD_AS_CI", "utf16", 4);
    charsets[2855] = new Collation(2855, "UCA1400_SLOVENIAN_NOPAD_AS_CS", "utf16", 4);
    charsets[2856] = new Collation(2856, "UCA1400_POLISH_AI_CI", "utf16", 4);
    charsets[2857] = new Collation(2857, "UCA1400_POLISH_AI_CS", "utf16", 4);
    charsets[2858] = new Collation(2858, "UCA1400_POLISH_AS_CI", "utf16", 4);
    charsets[2859] = new Collation(2859, "UCA1400_POLISH_AS_CS", "utf16", 4);
    charsets[2860] = new Collation(2860, "UCA1400_POLISH_NOPAD_AI_CI", "utf16", 4);
    charsets[2861] = new Collation(2861, "UCA1400_POLISH_NOPAD_AI_CS", "utf16", 4);
    charsets[2862] = new Collation(2862, "UCA1400_POLISH_NOPAD_AS_CI", "utf16", 4);
    charsets[2863] = new Collation(2863, "UCA1400_POLISH_NOPAD_AS_CS", "utf16", 4);
    charsets[2864] = new Collation(2864, "UCA1400_ESTONIAN_AI_CI", "utf16", 4);
    charsets[2865] = new Collation(2865, "UCA1400_ESTONIAN_AI_CS", "utf16", 4);
    charsets[2866] = new Collation(2866, "UCA1400_ESTONIAN_AS_CI", "utf16", 4);
    charsets[2867] = new Collation(2867, "UCA1400_ESTONIAN_AS_CS", "utf16", 4);
    charsets[2868] = new Collation(2868, "UCA1400_ESTONIAN_NOPAD_AI_CI", "utf16", 4);
    charsets[2869] = new Collation(2869, "UCA1400_ESTONIAN_NOPAD_AI_CS", "utf16", 4);
    charsets[2870] = new Collation(2870, "UCA1400_ESTONIAN_NOPAD_AS_CI", "utf16", 4);
    charsets[2871] = new Collation(2871, "UCA1400_ESTONIAN_NOPAD_AS_CS", "utf16", 4);
    charsets[2872] = new Collation(2872, "UCA1400_SPANISH_AI_CI", "utf16", 4);
    charsets[2873] = new Collation(2873, "UCA1400_SPANISH_AI_CS", "utf16", 4);
    charsets[2874] = new Collation(2874, "UCA1400_SPANISH_AS_CI", "utf16", 4);
    charsets[2875] = new Collation(2875, "UCA1400_SPANISH_AS_CS", "utf16", 4);
    charsets[2876] = new Collation(2876, "UCA1400_SPANISH_NOPAD_AI_CI", "utf16", 4);
    charsets[2877] = new Collation(2877, "UCA1400_SPANISH_NOPAD_AI_CS", "utf16", 4);
    charsets[2878] = new Collation(2878, "UCA1400_SPANISH_NOPAD_AS_CI", "utf16", 4);
    charsets[2879] = new Collation(2879, "UCA1400_SPANISH_NOPAD_AS_CS", "utf16", 4);
    charsets[2880] = new Collation(2880, "UCA1400_SWEDISH_AI_CI", "utf16", 4);
    charsets[2881] = new Collation(2881, "UCA1400_SWEDISH_AI_CS", "utf16", 4);
    charsets[2882] = new Collation(2882, "UCA1400_SWEDISH_AS_CI", "utf16", 4);
    charsets[2883] = new Collation(2883, "UCA1400_SWEDISH_AS_CS", "utf16", 4);
    charsets[2884] = new Collation(2884, "UCA1400_SWEDISH_NOPAD_AI_CI", "utf16", 4);
    charsets[2885] = new Collation(2885, "UCA1400_SWEDISH_NOPAD_AI_CS", "utf16", 4);
    charsets[2886] = new Collation(2886, "UCA1400_SWEDISH_NOPAD_AS_CI", "utf16", 4);
    charsets[2887] = new Collation(2887, "UCA1400_SWEDISH_NOPAD_AS_CS", "utf16", 4);
    charsets[2888] = new Collation(2888, "UCA1400_TURKISH_AI_CI", "utf16", 4);
    charsets[2889] = new Collation(2889, "UCA1400_TURKISH_AI_CS", "utf16", 4);
    charsets[2890] = new Collation(2890, "UCA1400_TURKISH_AS_CI", "utf16", 4);
    charsets[2891] = new Collation(2891, "UCA1400_TURKISH_AS_CS", "utf16", 4);
    charsets[2892] = new Collation(2892, "UCA1400_TURKISH_NOPAD_AI_CI", "utf16", 4);
    charsets[2893] = new Collation(2893, "UCA1400_TURKISH_NOPAD_AI_CS", "utf16", 4);
    charsets[2894] = new Collation(2894, "UCA1400_TURKISH_NOPAD_AS_CI", "utf16", 4);
    charsets[2895] = new Collation(2895, "UCA1400_TURKISH_NOPAD_AS_CS", "utf16", 4);
    charsets[2896] = new Collation(2896, "UCA1400_CZECH_AI_CI", "utf16", 4);
    charsets[2897] = new Collation(2897, "UCA1400_CZECH_AI_CS", "utf16", 4);
    charsets[2898] = new Collation(2898, "UCA1400_CZECH_AS_CI", "utf16", 4);
    charsets[2899] = new Collation(2899, "UCA1400_CZECH_AS_CS", "utf16", 4);
    charsets[2900] = new Collation(2900, "UCA1400_CZECH_NOPAD_AI_CI", "utf16", 4);
    charsets[2901] = new Collation(2901, "UCA1400_CZECH_NOPAD_AI_CS", "utf16", 4);
    charsets[2902] = new Collation(2902, "UCA1400_CZECH_NOPAD_AS_CI", "utf16", 4);
    charsets[2903] = new Collation(2903, "UCA1400_CZECH_NOPAD_AS_CS", "utf16", 4);
    charsets[2904] = new Collation(2904, "UCA1400_DANISH_AI_CI", "utf16", 4);
    charsets[2905] = new Collation(2905, "UCA1400_DANISH_AI_CS", "utf16", 4);
    charsets[2906] = new Collation(2906, "UCA1400_DANISH_AS_CI", "utf16", 4);
    charsets[2907] = new Collation(2907, "UCA1400_DANISH_AS_CS", "utf16", 4);
    charsets[2908] = new Collation(2908, "UCA1400_DANISH_NOPAD_AI_CI", "utf16", 4);
    charsets[2909] = new Collation(2909, "UCA1400_DANISH_NOPAD_AI_CS", "utf16", 4);
    charsets[2910] = new Collation(2910, "UCA1400_DANISH_NOPAD_AS_CI", "utf16", 4);
    charsets[2911] = new Collation(2911, "UCA1400_DANISH_NOPAD_AS_CS", "utf16", 4);
    charsets[2912] = new Collation(2912, "UCA1400_LITHUANIAN_AI_CI", "utf16", 4);
    charsets[2913] = new Collation(2913, "UCA1400_LITHUANIAN_AI_CS", "utf16", 4);
    charsets[2914] = new Collation(2914, "UCA1400_LITHUANIAN_AS_CI", "utf16", 4);
    charsets[2915] = new Collation(2915, "UCA1400_LITHUANIAN_AS_CS", "utf16", 4);
    charsets[2916] = new Collation(2916, "UCA1400_LITHUANIAN_NOPAD_AI_CI", "utf16", 4);
    charsets[2917] = new Collation(2917, "UCA1400_LITHUANIAN_NOPAD_AI_CS", "utf16", 4);
    charsets[2918] = new Collation(2918, "UCA1400_LITHUANIAN_NOPAD_AS_CI", "utf16", 4);
    charsets[2919] = new Collation(2919, "UCA1400_LITHUANIAN_NOPAD_AS_CS", "utf16", 4);
    charsets[2920] = new Collation(2920, "UCA1400_SLOVAK_AI_CI", "utf16", 4);
    charsets[2921] = new Collation(2921, "UCA1400_SLOVAK_AI_CS", "utf16", 4);
    charsets[2922] = new Collation(2922, "UCA1400_SLOVAK_AS_CI", "utf16", 4);
    charsets[2923] = new Collation(2923, "UCA1400_SLOVAK_AS_CS", "utf16", 4);
    charsets[2924] = new Collation(2924, "UCA1400_SLOVAK_NOPAD_AI_CI", "utf16", 4);
    charsets[2925] = new Collation(2925, "UCA1400_SLOVAK_NOPAD_AI_CS", "utf16", 4);
    charsets[2926] = new Collation(2926, "UCA1400_SLOVAK_NOPAD_AS_CI", "utf16", 4);
    charsets[2927] = new Collation(2927, "UCA1400_SLOVAK_NOPAD_AS_CS", "utf16", 4);
    charsets[2928] = new Collation(2928, "UCA1400_SPANISH2_AI_CI", "utf16", 4);
    charsets[2929] = new Collation(2929, "UCA1400_SPANISH2_AI_CS", "utf16", 4);
    charsets[2930] = new Collation(2930, "UCA1400_SPANISH2_AS_CI", "utf16", 4);
    charsets[2931] = new Collation(2931, "UCA1400_SPANISH2_AS_CS", "utf16", 4);
    charsets[2932] = new Collation(2932, "UCA1400_SPANISH2_NOPAD_AI_CI", "utf16", 4);
    charsets[2933] = new Collation(2933, "UCA1400_SPANISH2_NOPAD_AI_CS", "utf16", 4);
    charsets[2934] = new Collation(2934, "UCA1400_SPANISH2_NOPAD_AS_CI", "utf16", 4);
    charsets[2935] = new Collation(2935, "UCA1400_SPANISH2_NOPAD_AS_CS", "utf16", 4);
    charsets[2936] = new Collation(2936, "UCA1400_ROMAN_AI_CI", "utf16", 4);
    charsets[2937] = new Collation(2937, "UCA1400_ROMAN_AI_CS", "utf16", 4);
    charsets[2938] = new Collation(2938, "UCA1400_ROMAN_AS_CI", "utf16", 4);
    charsets[2939] = new Collation(2939, "UCA1400_ROMAN_AS_CS", "utf16", 4);
    charsets[2940] = new Collation(2940, "UCA1400_ROMAN_NOPAD_AI_CI", "utf16", 4);
    charsets[2941] = new Collation(2941, "UCA1400_ROMAN_NOPAD_AI_CS", "utf16", 4);
    charsets[2942] = new Collation(2942, "UCA1400_ROMAN_NOPAD_AS_CI", "utf16", 4);
    charsets[2943] = new Collation(2943, "UCA1400_ROMAN_NOPAD_AS_CS", "utf16", 4);
    charsets[2944] = new Collation(2944, "UCA1400_PERSIAN_AI_CI", "utf16", 4);
    charsets[2945] = new Collation(2945, "UCA1400_PERSIAN_AI_CS", "utf16", 4);
    charsets[2946] = new Collation(2946, "UCA1400_PERSIAN_AS_CI", "utf16", 4);
    charsets[2947] = new Collation(2947, "UCA1400_PERSIAN_AS_CS", "utf16", 4);
    charsets[2948] = new Collation(2948, "UCA1400_PERSIAN_NOPAD_AI_CI", "utf16", 4);
    charsets[2949] = new Collation(2949, "UCA1400_PERSIAN_NOPAD_AI_CS", "utf16", 4);
    charsets[2950] = new Collation(2950, "UCA1400_PERSIAN_NOPAD_AS_CI", "utf16", 4);
    charsets[2951] = new Collation(2951, "UCA1400_PERSIAN_NOPAD_AS_CS", "utf16", 4);
    charsets[2952] = new Collation(2952, "UCA1400_ESPERANTO_AI_CI", "utf16", 4);
    charsets[2953] = new Collation(2953, "UCA1400_ESPERANTO_AI_CS", "utf16", 4);
    charsets[2954] = new Collation(2954, "UCA1400_ESPERANTO_AS_CI", "utf16", 4);
    charsets[2955] = new Collation(2955, "UCA1400_ESPERANTO_AS_CS", "utf16", 4);
    charsets[2956] = new Collation(2956, "UCA1400_ESPERANTO_NOPAD_AI_CI", "utf16", 4);
    charsets[2957] = new Collation(2957, "UCA1400_ESPERANTO_NOPAD_AI_CS", "utf16", 4);
    charsets[2958] = new Collation(2958, "UCA1400_ESPERANTO_NOPAD_AS_CI", "utf16", 4);
    charsets[2959] = new Collation(2959, "UCA1400_ESPERANTO_NOPAD_AS_CS", "utf16", 4);
    charsets[2960] = new Collation(2960, "UCA1400_HUNGARIAN_AI_CI", "utf16", 4);
    charsets[2961] = new Collation(2961, "UCA1400_HUNGARIAN_AI_CS", "utf16", 4);
    charsets[2962] = new Collation(2962, "UCA1400_HUNGARIAN_AS_CI", "utf16", 4);
    charsets[2963] = new Collation(2963, "UCA1400_HUNGARIAN_AS_CS", "utf16", 4);
    charsets[2964] = new Collation(2964, "UCA1400_HUNGARIAN_NOPAD_AI_CI", "utf16", 4);
    charsets[2965] = new Collation(2965, "UCA1400_HUNGARIAN_NOPAD_AI_CS", "utf16", 4);
    charsets[2966] = new Collation(2966, "UCA1400_HUNGARIAN_NOPAD_AS_CI", "utf16", 4);
    charsets[2967] = new Collation(2967, "UCA1400_HUNGARIAN_NOPAD_AS_CS", "utf16", 4);
    charsets[2968] = new Collation(2968, "UCA1400_SINHALA_AI_CI", "utf16", 4);
    charsets[2969] = new Collation(2969, "UCA1400_SINHALA_AI_CS", "utf16", 4);
    charsets[2970] = new Collation(2970, "UCA1400_SINHALA_AS_CI", "utf16", 4);
    charsets[2971] = new Collation(2971, "UCA1400_SINHALA_AS_CS", "utf16", 4);
    charsets[2972] = new Collation(2972, "UCA1400_SINHALA_NOPAD_AI_CI", "utf16", 4);
    charsets[2973] = new Collation(2973, "UCA1400_SINHALA_NOPAD_AI_CS", "utf16", 4);
    charsets[2974] = new Collation(2974, "UCA1400_SINHALA_NOPAD_AS_CI", "utf16", 4);
    charsets[2975] = new Collation(2975, "UCA1400_SINHALA_NOPAD_AS_CS", "utf16", 4);
    charsets[2976] = new Collation(2976, "UCA1400_GERMAN2_AI_CI", "utf16", 4);
    charsets[2977] = new Collation(2977, "UCA1400_GERMAN2_AI_CS", "utf16", 4);
    charsets[2978] = new Collation(2978, "UCA1400_GERMAN2_AS_CI", "utf16", 4);
    charsets[2979] = new Collation(2979, "UCA1400_GERMAN2_AS_CS", "utf16", 4);
    charsets[2980] = new Collation(2980, "UCA1400_GERMAN2_NOPAD_AI_CI", "utf16", 4);
    charsets[2981] = new Collation(2981, "UCA1400_GERMAN2_NOPAD_AI_CS", "utf16", 4);
    charsets[2982] = new Collation(2982, "UCA1400_GERMAN2_NOPAD_AS_CI", "utf16", 4);
    charsets[2983] = new Collation(2983, "UCA1400_GERMAN2_NOPAD_AS_CS", "utf16", 4);
    charsets[3e3] = new Collation(3e3, "UCA1400_VIETNAMESE_AI_CI", "utf16", 4);
    charsets[3001] = new Collation(3001, "UCA1400_VIETNAMESE_AI_CS", "utf16", 4);
    charsets[3002] = new Collation(3002, "UCA1400_VIETNAMESE_AS_CI", "utf16", 4);
    charsets[3003] = new Collation(3003, "UCA1400_VIETNAMESE_AS_CS", "utf16", 4);
    charsets[3004] = new Collation(3004, "UCA1400_VIETNAMESE_NOPAD_AI_CI", "utf16", 4);
    charsets[3005] = new Collation(3005, "UCA1400_VIETNAMESE_NOPAD_AI_CS", "utf16", 4);
    charsets[3006] = new Collation(3006, "UCA1400_VIETNAMESE_NOPAD_AS_CI", "utf16", 4);
    charsets[3007] = new Collation(3007, "UCA1400_VIETNAMESE_NOPAD_AS_CS", "utf16", 4);
    charsets[3008] = new Collation(3008, "UCA1400_CROATIAN_AI_CI", "utf16", 4);
    charsets[3009] = new Collation(3009, "UCA1400_CROATIAN_AI_CS", "utf16", 4);
    charsets[3010] = new Collation(3010, "UCA1400_CROATIAN_AS_CI", "utf16", 4);
    charsets[3011] = new Collation(3011, "UCA1400_CROATIAN_AS_CS", "utf16", 4);
    charsets[3012] = new Collation(3012, "UCA1400_CROATIAN_NOPAD_AI_CI", "utf16", 4);
    charsets[3013] = new Collation(3013, "UCA1400_CROATIAN_NOPAD_AI_CS", "utf16", 4);
    charsets[3014] = new Collation(3014, "UCA1400_CROATIAN_NOPAD_AS_CI", "utf16", 4);
    charsets[3015] = new Collation(3015, "UCA1400_CROATIAN_NOPAD_AS_CS", "utf16", 4);
    charsets[3072] = new Collation(3072, "UCA1400_AI_CI", "utf32", 4);
    charsets[3073] = new Collation(3073, "UCA1400_AI_CS", "utf32", 4);
    charsets[3074] = new Collation(3074, "UCA1400_AS_CI", "utf32", 4);
    charsets[3075] = new Collation(3075, "UCA1400_AS_CS", "utf32", 4);
    charsets[3076] = new Collation(3076, "UCA1400_NOPAD_AI_CI", "utf32", 4);
    charsets[3077] = new Collation(3077, "UCA1400_NOPAD_AI_CS", "utf32", 4);
    charsets[3078] = new Collation(3078, "UCA1400_NOPAD_AS_CI", "utf32", 4);
    charsets[3079] = new Collation(3079, "UCA1400_NOPAD_AS_CS", "utf32", 4);
    charsets[3080] = new Collation(3080, "UCA1400_ICELANDIC_AI_CI", "utf32", 4);
    charsets[3081] = new Collation(3081, "UCA1400_ICELANDIC_AI_CS", "utf32", 4);
    charsets[3082] = new Collation(3082, "UCA1400_ICELANDIC_AS_CI", "utf32", 4);
    charsets[3083] = new Collation(3083, "UCA1400_ICELANDIC_AS_CS", "utf32", 4);
    charsets[3084] = new Collation(3084, "UCA1400_ICELANDIC_NOPAD_AI_CI", "utf32", 4);
    charsets[3085] = new Collation(3085, "UCA1400_ICELANDIC_NOPAD_AI_CS", "utf32", 4);
    charsets[3086] = new Collation(3086, "UCA1400_ICELANDIC_NOPAD_AS_CI", "utf32", 4);
    charsets[3087] = new Collation(3087, "UCA1400_ICELANDIC_NOPAD_AS_CS", "utf32", 4);
    charsets[3088] = new Collation(3088, "UCA1400_LATVIAN_AI_CI", "utf32", 4);
    charsets[3089] = new Collation(3089, "UCA1400_LATVIAN_AI_CS", "utf32", 4);
    charsets[3090] = new Collation(3090, "UCA1400_LATVIAN_AS_CI", "utf32", 4);
    charsets[3091] = new Collation(3091, "UCA1400_LATVIAN_AS_CS", "utf32", 4);
    charsets[3092] = new Collation(3092, "UCA1400_LATVIAN_NOPAD_AI_CI", "utf32", 4);
    charsets[3093] = new Collation(3093, "UCA1400_LATVIAN_NOPAD_AI_CS", "utf32", 4);
    charsets[3094] = new Collation(3094, "UCA1400_LATVIAN_NOPAD_AS_CI", "utf32", 4);
    charsets[3095] = new Collation(3095, "UCA1400_LATVIAN_NOPAD_AS_CS", "utf32", 4);
    charsets[3096] = new Collation(3096, "UCA1400_ROMANIAN_AI_CI", "utf32", 4);
    charsets[3097] = new Collation(3097, "UCA1400_ROMANIAN_AI_CS", "utf32", 4);
    charsets[3098] = new Collation(3098, "UCA1400_ROMANIAN_AS_CI", "utf32", 4);
    charsets[3099] = new Collation(3099, "UCA1400_ROMANIAN_AS_CS", "utf32", 4);
    charsets[3100] = new Collation(3100, "UCA1400_ROMANIAN_NOPAD_AI_CI", "utf32", 4);
    charsets[3101] = new Collation(3101, "UCA1400_ROMANIAN_NOPAD_AI_CS", "utf32", 4);
    charsets[3102] = new Collation(3102, "UCA1400_ROMANIAN_NOPAD_AS_CI", "utf32", 4);
    charsets[3103] = new Collation(3103, "UCA1400_ROMANIAN_NOPAD_AS_CS", "utf32", 4);
    charsets[3104] = new Collation(3104, "UCA1400_SLOVENIAN_AI_CI", "utf32", 4);
    charsets[3105] = new Collation(3105, "UCA1400_SLOVENIAN_AI_CS", "utf32", 4);
    charsets[3106] = new Collation(3106, "UCA1400_SLOVENIAN_AS_CI", "utf32", 4);
    charsets[3107] = new Collation(3107, "UCA1400_SLOVENIAN_AS_CS", "utf32", 4);
    charsets[3108] = new Collation(3108, "UCA1400_SLOVENIAN_NOPAD_AI_CI", "utf32", 4);
    charsets[3109] = new Collation(3109, "UCA1400_SLOVENIAN_NOPAD_AI_CS", "utf32", 4);
    charsets[3110] = new Collation(3110, "UCA1400_SLOVENIAN_NOPAD_AS_CI", "utf32", 4);
    charsets[3111] = new Collation(3111, "UCA1400_SLOVENIAN_NOPAD_AS_CS", "utf32", 4);
    charsets[3112] = new Collation(3112, "UCA1400_POLISH_AI_CI", "utf32", 4);
    charsets[3113] = new Collation(3113, "UCA1400_POLISH_AI_CS", "utf32", 4);
    charsets[3114] = new Collation(3114, "UCA1400_POLISH_AS_CI", "utf32", 4);
    charsets[3115] = new Collation(3115, "UCA1400_POLISH_AS_CS", "utf32", 4);
    charsets[3116] = new Collation(3116, "UCA1400_POLISH_NOPAD_AI_CI", "utf32", 4);
    charsets[3117] = new Collation(3117, "UCA1400_POLISH_NOPAD_AI_CS", "utf32", 4);
    charsets[3118] = new Collation(3118, "UCA1400_POLISH_NOPAD_AS_CI", "utf32", 4);
    charsets[3119] = new Collation(3119, "UCA1400_POLISH_NOPAD_AS_CS", "utf32", 4);
    charsets[3120] = new Collation(3120, "UCA1400_ESTONIAN_AI_CI", "utf32", 4);
    charsets[3121] = new Collation(3121, "UCA1400_ESTONIAN_AI_CS", "utf32", 4);
    charsets[3122] = new Collation(3122, "UCA1400_ESTONIAN_AS_CI", "utf32", 4);
    charsets[3123] = new Collation(3123, "UCA1400_ESTONIAN_AS_CS", "utf32", 4);
    charsets[3124] = new Collation(3124, "UCA1400_ESTONIAN_NOPAD_AI_CI", "utf32", 4);
    charsets[3125] = new Collation(3125, "UCA1400_ESTONIAN_NOPAD_AI_CS", "utf32", 4);
    charsets[3126] = new Collation(3126, "UCA1400_ESTONIAN_NOPAD_AS_CI", "utf32", 4);
    charsets[3127] = new Collation(3127, "UCA1400_ESTONIAN_NOPAD_AS_CS", "utf32", 4);
    charsets[3128] = new Collation(3128, "UCA1400_SPANISH_AI_CI", "utf32", 4);
    charsets[3129] = new Collation(3129, "UCA1400_SPANISH_AI_CS", "utf32", 4);
    charsets[3130] = new Collation(3130, "UCA1400_SPANISH_AS_CI", "utf32", 4);
    charsets[3131] = new Collation(3131, "UCA1400_SPANISH_AS_CS", "utf32", 4);
    charsets[3132] = new Collation(3132, "UCA1400_SPANISH_NOPAD_AI_CI", "utf32", 4);
    charsets[3133] = new Collation(3133, "UCA1400_SPANISH_NOPAD_AI_CS", "utf32", 4);
    charsets[3134] = new Collation(3134, "UCA1400_SPANISH_NOPAD_AS_CI", "utf32", 4);
    charsets[3135] = new Collation(3135, "UCA1400_SPANISH_NOPAD_AS_CS", "utf32", 4);
    charsets[3136] = new Collation(3136, "UCA1400_SWEDISH_AI_CI", "utf32", 4);
    charsets[3137] = new Collation(3137, "UCA1400_SWEDISH_AI_CS", "utf32", 4);
    charsets[3138] = new Collation(3138, "UCA1400_SWEDISH_AS_CI", "utf32", 4);
    charsets[3139] = new Collation(3139, "UCA1400_SWEDISH_AS_CS", "utf32", 4);
    charsets[3140] = new Collation(3140, "UCA1400_SWEDISH_NOPAD_AI_CI", "utf32", 4);
    charsets[3141] = new Collation(3141, "UCA1400_SWEDISH_NOPAD_AI_CS", "utf32", 4);
    charsets[3142] = new Collation(3142, "UCA1400_SWEDISH_NOPAD_AS_CI", "utf32", 4);
    charsets[3143] = new Collation(3143, "UCA1400_SWEDISH_NOPAD_AS_CS", "utf32", 4);
    charsets[3144] = new Collation(3144, "UCA1400_TURKISH_AI_CI", "utf32", 4);
    charsets[3145] = new Collation(3145, "UCA1400_TURKISH_AI_CS", "utf32", 4);
    charsets[3146] = new Collation(3146, "UCA1400_TURKISH_AS_CI", "utf32", 4);
    charsets[3147] = new Collation(3147, "UCA1400_TURKISH_AS_CS", "utf32", 4);
    charsets[3148] = new Collation(3148, "UCA1400_TURKISH_NOPAD_AI_CI", "utf32", 4);
    charsets[3149] = new Collation(3149, "UCA1400_TURKISH_NOPAD_AI_CS", "utf32", 4);
    charsets[3150] = new Collation(3150, "UCA1400_TURKISH_NOPAD_AS_CI", "utf32", 4);
    charsets[3151] = new Collation(3151, "UCA1400_TURKISH_NOPAD_AS_CS", "utf32", 4);
    charsets[3152] = new Collation(3152, "UCA1400_CZECH_AI_CI", "utf32", 4);
    charsets[3153] = new Collation(3153, "UCA1400_CZECH_AI_CS", "utf32", 4);
    charsets[3154] = new Collation(3154, "UCA1400_CZECH_AS_CI", "utf32", 4);
    charsets[3155] = new Collation(3155, "UCA1400_CZECH_AS_CS", "utf32", 4);
    charsets[3156] = new Collation(3156, "UCA1400_CZECH_NOPAD_AI_CI", "utf32", 4);
    charsets[3157] = new Collation(3157, "UCA1400_CZECH_NOPAD_AI_CS", "utf32", 4);
    charsets[3158] = new Collation(3158, "UCA1400_CZECH_NOPAD_AS_CI", "utf32", 4);
    charsets[3159] = new Collation(3159, "UCA1400_CZECH_NOPAD_AS_CS", "utf32", 4);
    charsets[3160] = new Collation(3160, "UCA1400_DANISH_AI_CI", "utf32", 4);
    charsets[3161] = new Collation(3161, "UCA1400_DANISH_AI_CS", "utf32", 4);
    charsets[3162] = new Collation(3162, "UCA1400_DANISH_AS_CI", "utf32", 4);
    charsets[3163] = new Collation(3163, "UCA1400_DANISH_AS_CS", "utf32", 4);
    charsets[3164] = new Collation(3164, "UCA1400_DANISH_NOPAD_AI_CI", "utf32", 4);
    charsets[3165] = new Collation(3165, "UCA1400_DANISH_NOPAD_AI_CS", "utf32", 4);
    charsets[3166] = new Collation(3166, "UCA1400_DANISH_NOPAD_AS_CI", "utf32", 4);
    charsets[3167] = new Collation(3167, "UCA1400_DANISH_NOPAD_AS_CS", "utf32", 4);
    charsets[3168] = new Collation(3168, "UCA1400_LITHUANIAN_AI_CI", "utf32", 4);
    charsets[3169] = new Collation(3169, "UCA1400_LITHUANIAN_AI_CS", "utf32", 4);
    charsets[3170] = new Collation(3170, "UCA1400_LITHUANIAN_AS_CI", "utf32", 4);
    charsets[3171] = new Collation(3171, "UCA1400_LITHUANIAN_AS_CS", "utf32", 4);
    charsets[3172] = new Collation(3172, "UCA1400_LITHUANIAN_NOPAD_AI_CI", "utf32", 4);
    charsets[3173] = new Collation(3173, "UCA1400_LITHUANIAN_NOPAD_AI_CS", "utf32", 4);
    charsets[3174] = new Collation(3174, "UCA1400_LITHUANIAN_NOPAD_AS_CI", "utf32", 4);
    charsets[3175] = new Collation(3175, "UCA1400_LITHUANIAN_NOPAD_AS_CS", "utf32", 4);
    charsets[3176] = new Collation(3176, "UCA1400_SLOVAK_AI_CI", "utf32", 4);
    charsets[3177] = new Collation(3177, "UCA1400_SLOVAK_AI_CS", "utf32", 4);
    charsets[3178] = new Collation(3178, "UCA1400_SLOVAK_AS_CI", "utf32", 4);
    charsets[3179] = new Collation(3179, "UCA1400_SLOVAK_AS_CS", "utf32", 4);
    charsets[3180] = new Collation(3180, "UCA1400_SLOVAK_NOPAD_AI_CI", "utf32", 4);
    charsets[3181] = new Collation(3181, "UCA1400_SLOVAK_NOPAD_AI_CS", "utf32", 4);
    charsets[3182] = new Collation(3182, "UCA1400_SLOVAK_NOPAD_AS_CI", "utf32", 4);
    charsets[3183] = new Collation(3183, "UCA1400_SLOVAK_NOPAD_AS_CS", "utf32", 4);
    charsets[3184] = new Collation(3184, "UCA1400_SPANISH2_AI_CI", "utf32", 4);
    charsets[3185] = new Collation(3185, "UCA1400_SPANISH2_AI_CS", "utf32", 4);
    charsets[3186] = new Collation(3186, "UCA1400_SPANISH2_AS_CI", "utf32", 4);
    charsets[3187] = new Collation(3187, "UCA1400_SPANISH2_AS_CS", "utf32", 4);
    charsets[3188] = new Collation(3188, "UCA1400_SPANISH2_NOPAD_AI_CI", "utf32", 4);
    charsets[3189] = new Collation(3189, "UCA1400_SPANISH2_NOPAD_AI_CS", "utf32", 4);
    charsets[3190] = new Collation(3190, "UCA1400_SPANISH2_NOPAD_AS_CI", "utf32", 4);
    charsets[3191] = new Collation(3191, "UCA1400_SPANISH2_NOPAD_AS_CS", "utf32", 4);
    charsets[3192] = new Collation(3192, "UCA1400_ROMAN_AI_CI", "utf32", 4);
    charsets[3193] = new Collation(3193, "UCA1400_ROMAN_AI_CS", "utf32", 4);
    charsets[3194] = new Collation(3194, "UCA1400_ROMAN_AS_CI", "utf32", 4);
    charsets[3195] = new Collation(3195, "UCA1400_ROMAN_AS_CS", "utf32", 4);
    charsets[3196] = new Collation(3196, "UCA1400_ROMAN_NOPAD_AI_CI", "utf32", 4);
    charsets[3197] = new Collation(3197, "UCA1400_ROMAN_NOPAD_AI_CS", "utf32", 4);
    charsets[3198] = new Collation(3198, "UCA1400_ROMAN_NOPAD_AS_CI", "utf32", 4);
    charsets[3199] = new Collation(3199, "UCA1400_ROMAN_NOPAD_AS_CS", "utf32", 4);
    charsets[3200] = new Collation(3200, "UCA1400_PERSIAN_AI_CI", "utf32", 4);
    charsets[3201] = new Collation(3201, "UCA1400_PERSIAN_AI_CS", "utf32", 4);
    charsets[3202] = new Collation(3202, "UCA1400_PERSIAN_AS_CI", "utf32", 4);
    charsets[3203] = new Collation(3203, "UCA1400_PERSIAN_AS_CS", "utf32", 4);
    charsets[3204] = new Collation(3204, "UCA1400_PERSIAN_NOPAD_AI_CI", "utf32", 4);
    charsets[3205] = new Collation(3205, "UCA1400_PERSIAN_NOPAD_AI_CS", "utf32", 4);
    charsets[3206] = new Collation(3206, "UCA1400_PERSIAN_NOPAD_AS_CI", "utf32", 4);
    charsets[3207] = new Collation(3207, "UCA1400_PERSIAN_NOPAD_AS_CS", "utf32", 4);
    charsets[3208] = new Collation(3208, "UCA1400_ESPERANTO_AI_CI", "utf32", 4);
    charsets[3209] = new Collation(3209, "UCA1400_ESPERANTO_AI_CS", "utf32", 4);
    charsets[3210] = new Collation(3210, "UCA1400_ESPERANTO_AS_CI", "utf32", 4);
    charsets[3211] = new Collation(3211, "UCA1400_ESPERANTO_AS_CS", "utf32", 4);
    charsets[3212] = new Collation(3212, "UCA1400_ESPERANTO_NOPAD_AI_CI", "utf32", 4);
    charsets[3213] = new Collation(3213, "UCA1400_ESPERANTO_NOPAD_AI_CS", "utf32", 4);
    charsets[3214] = new Collation(3214, "UCA1400_ESPERANTO_NOPAD_AS_CI", "utf32", 4);
    charsets[3215] = new Collation(3215, "UCA1400_ESPERANTO_NOPAD_AS_CS", "utf32", 4);
    charsets[3216] = new Collation(3216, "UCA1400_HUNGARIAN_AI_CI", "utf32", 4);
    charsets[3217] = new Collation(3217, "UCA1400_HUNGARIAN_AI_CS", "utf32", 4);
    charsets[3218] = new Collation(3218, "UCA1400_HUNGARIAN_AS_CI", "utf32", 4);
    charsets[3219] = new Collation(3219, "UCA1400_HUNGARIAN_AS_CS", "utf32", 4);
    charsets[3220] = new Collation(3220, "UCA1400_HUNGARIAN_NOPAD_AI_CI", "utf32", 4);
    charsets[3221] = new Collation(3221, "UCA1400_HUNGARIAN_NOPAD_AI_CS", "utf32", 4);
    charsets[3222] = new Collation(3222, "UCA1400_HUNGARIAN_NOPAD_AS_CI", "utf32", 4);
    charsets[3223] = new Collation(3223, "UCA1400_HUNGARIAN_NOPAD_AS_CS", "utf32", 4);
    charsets[3224] = new Collation(3224, "UCA1400_SINHALA_AI_CI", "utf32", 4);
    charsets[3225] = new Collation(3225, "UCA1400_SINHALA_AI_CS", "utf32", 4);
    charsets[3226] = new Collation(3226, "UCA1400_SINHALA_AS_CI", "utf32", 4);
    charsets[3227] = new Collation(3227, "UCA1400_SINHALA_AS_CS", "utf32", 4);
    charsets[3228] = new Collation(3228, "UCA1400_SINHALA_NOPAD_AI_CI", "utf32", 4);
    charsets[3229] = new Collation(3229, "UCA1400_SINHALA_NOPAD_AI_CS", "utf32", 4);
    charsets[3230] = new Collation(3230, "UCA1400_SINHALA_NOPAD_AS_CI", "utf32", 4);
    charsets[3231] = new Collation(3231, "UCA1400_SINHALA_NOPAD_AS_CS", "utf32", 4);
    charsets[3232] = new Collation(3232, "UCA1400_GERMAN2_AI_CI", "utf32", 4);
    charsets[3233] = new Collation(3233, "UCA1400_GERMAN2_AI_CS", "utf32", 4);
    charsets[3234] = new Collation(3234, "UCA1400_GERMAN2_AS_CI", "utf32", 4);
    charsets[3235] = new Collation(3235, "UCA1400_GERMAN2_AS_CS", "utf32", 4);
    charsets[3236] = new Collation(3236, "UCA1400_GERMAN2_NOPAD_AI_CI", "utf32", 4);
    charsets[3237] = new Collation(3237, "UCA1400_GERMAN2_NOPAD_AI_CS", "utf32", 4);
    charsets[3238] = new Collation(3238, "UCA1400_GERMAN2_NOPAD_AS_CI", "utf32", 4);
    charsets[3239] = new Collation(3239, "UCA1400_GERMAN2_NOPAD_AS_CS", "utf32", 4);
    charsets[3256] = new Collation(3256, "UCA1400_VIETNAMESE_AI_CI", "utf32", 4);
    charsets[3257] = new Collation(3257, "UCA1400_VIETNAMESE_AI_CS", "utf32", 4);
    charsets[3258] = new Collation(3258, "UCA1400_VIETNAMESE_AS_CI", "utf32", 4);
    charsets[3259] = new Collation(3259, "UCA1400_VIETNAMESE_AS_CS", "utf32", 4);
    charsets[3260] = new Collation(3260, "UCA1400_VIETNAMESE_NOPAD_AI_CI", "utf32", 4);
    charsets[3261] = new Collation(3261, "UCA1400_VIETNAMESE_NOPAD_AI_CS", "utf32", 4);
    charsets[3262] = new Collation(3262, "UCA1400_VIETNAMESE_NOPAD_AS_CI", "utf32", 4);
    charsets[3263] = new Collation(3263, "UCA1400_VIETNAMESE_NOPAD_AS_CS", "utf32", 4);
    charsets[3264] = new Collation(3264, "UCA1400_CROATIAN_AI_CI", "utf32", 4);
    charsets[3265] = new Collation(3265, "UCA1400_CROATIAN_AI_CS", "utf32", 4);
    charsets[3266] = new Collation(3266, "UCA1400_CROATIAN_AS_CI", "utf32", 4);
    charsets[3267] = new Collation(3267, "UCA1400_CROATIAN_AS_CS", "utf32", 4);
    charsets[3268] = new Collation(3268, "UCA1400_CROATIAN_NOPAD_AI_CI", "utf32", 4);
    charsets[3269] = new Collation(3269, "UCA1400_CROATIAN_NOPAD_AI_CS", "utf32", 4);
    charsets[3270] = new Collation(3270, "UCA1400_CROATIAN_NOPAD_AS_CI", "utf32", 4);
    charsets[3271] = new Collation(3271, "UCA1400_CROATIAN_NOPAD_AS_CS", "utf32", 4);
    for (let i = 0; i < charsets.length; i++) {
      let collation = charsets[i];
      if (collation) {
        Collation.prototype[collation.name] = collation;
      }
    }
    defaultCharsets["big5"] = charsets[1];
    defaultCharsets["dec8"] = charsets[3];
    defaultCharsets["cp850"] = charsets[4];
    defaultCharsets["hp8"] = charsets[6];
    defaultCharsets["koi8r"] = charsets[7];
    defaultCharsets["latin1"] = charsets[8];
    defaultCharsets["latin2"] = charsets[9];
    defaultCharsets["swe7"] = charsets[10];
    defaultCharsets["ascii"] = charsets[11];
    defaultCharsets["ujis"] = charsets[12];
    defaultCharsets["sjis"] = charsets[13];
    defaultCharsets["hebrew"] = charsets[16];
    defaultCharsets["tis620"] = charsets[18];
    defaultCharsets["euckr"] = charsets[19];
    defaultCharsets["koi8u"] = charsets[22];
    defaultCharsets["gb2312"] = charsets[24];
    defaultCharsets["greek"] = charsets[25];
    defaultCharsets["cp1250"] = charsets[26];
    defaultCharsets["gbk"] = charsets[28];
    defaultCharsets["latin5"] = charsets[30];
    defaultCharsets["armscii8"] = charsets[32];
    defaultCharsets["utf8"] = charsets[33];
    defaultCharsets["ucs2"] = charsets[35];
    defaultCharsets["cp866"] = charsets[36];
    defaultCharsets["keybcs2"] = charsets[37];
    defaultCharsets["macce"] = charsets[38];
    defaultCharsets["macroman"] = charsets[39];
    defaultCharsets["cp852"] = charsets[40];
    defaultCharsets["latin7"] = charsets[41];
    defaultCharsets["utf8mb4"] = charsets[45];
    defaultCharsets["cp1251"] = charsets[51];
    defaultCharsets["utf16"] = charsets[54];
    defaultCharsets["utf16le"] = charsets[56];
    defaultCharsets["cp1256"] = charsets[57];
    defaultCharsets["cp1257"] = charsets[59];
    defaultCharsets["utf32"] = charsets[60];
    defaultCharsets["binary"] = charsets[63];
    defaultCharsets["geostd8"] = charsets[92];
    defaultCharsets["cp932"] = charsets[95];
    defaultCharsets["eucjpms"] = charsets[97];
    defaultCharsets["gb18030"] = charsets[248];
    module2.exports = Collation;
  }
});
var require_text_encoder = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/encoder/text-encoder.js"(exports, module2) {
    "use strict";
    var QUOTE = 39;
    var formatDigit = function(val, significantDigit) {
      let res = `${val}`;
      while (res.length < significantDigit) res = "0" + res;
      return res;
    };
    var TextEncoder = class _TextEncoder {
      /**
       * Write (and escape) current parameter value to output writer
       *
       * @param out     output writer
       * @param value   current parameter. Expected to be non-null
       * @param opts    connection options
       * @param info    connection information
       */
      static writeParam(out, value, opts, info) {
        switch (typeof value) {
          case "boolean":
            out.writeStringAscii(value ? "true" : "false");
            break;
          case "bigint":
          case "number":
            out.writeStringAscii(`${value}`);
            break;
          case "string":
            out.writeStringEscapeQuote(value);
            break;
          case "object":
            if (Object.prototype.toString.call(value) === "[object Date]") {
              out.writeStringAscii(_TextEncoder.getLocalDate(value));
            } else if (Buffer.isBuffer(value)) {
              out.writeStringAscii("_BINARY '");
              out.writeBufferEscape(value);
              out.writeInt8(QUOTE);
            } else if (typeof value.toSqlString === "function") {
              out.writeStringEscapeQuote(String(value.toSqlString()));
            } else if (Array.isArray(value)) {
              if (opts.arrayParenthesis) {
                out.writeStringAscii("(");
              }
              for (let i = 0; i < value.length; i++) {
                if (i !== 0) out.writeStringAscii(",");
                if (value[i] == null) {
                  out.writeStringAscii("NULL");
                } else _TextEncoder.writeParam(out, value[i], opts, info);
              }
              if (opts.arrayParenthesis) {
                out.writeStringAscii(")");
              }
            } else {
              if (value.type != null && [
                "Point",
                "LineString",
                "Polygon",
                "MultiPoint",
                "MultiLineString",
                "MultiPolygon",
                "GeometryCollection"
              ].includes(value.type)) {
                let prefix = info.isMariaDB() && info.hasMinVersion(10, 1, 4) || !info.isMariaDB() && info.hasMinVersion(5, 7, 6) ? "ST_" : "";
                switch (value.type) {
                  case "Point":
                    out.writeStringAscii(
                      prefix + "PointFromText('POINT(" + _TextEncoder.geoPointToString(value.coordinates) + ")')"
                    );
                    break;
                  case "LineString":
                    out.writeStringAscii(
                      prefix + "LineFromText('LINESTRING(" + _TextEncoder.geoArrayPointToString(value.coordinates) + ")')"
                    );
                    break;
                  case "Polygon":
                    out.writeStringAscii(
                      prefix + "PolygonFromText('POLYGON(" + _TextEncoder.geoMultiArrayPointToString(value.coordinates) + ")')"
                    );
                    break;
                  case "MultiPoint":
                    out.writeStringAscii(
                      prefix + "MULTIPOINTFROMTEXT('MULTIPOINT(" + _TextEncoder.geoArrayPointToString(value.coordinates) + ")')"
                    );
                    break;
                  case "MultiLineString":
                    out.writeStringAscii(
                      prefix + "MLineFromText('MULTILINESTRING(" + _TextEncoder.geoMultiArrayPointToString(value.coordinates) + ")')"
                    );
                    break;
                  case "MultiPolygon":
                    out.writeStringAscii(
                      prefix + "MPolyFromText('MULTIPOLYGON(" + _TextEncoder.geoMultiPolygonToString(value.coordinates) + ")')"
                    );
                    break;
                  case "GeometryCollection":
                    out.writeStringAscii(
                      prefix + "GeomCollFromText('GEOMETRYCOLLECTION(" + _TextEncoder.geometricCollectionToString(value.geometries) + ")')"
                    );
                    break;
                }
              } else if (String === value.constructor) {
                out.writeStringEscapeQuote(value);
                break;
              } else {
                if (opts.permitSetMultiParamEntries) {
                  let first = true;
                  for (let key in value) {
                    const val = value[key];
                    if (typeof val === "function") continue;
                    if (first) {
                      first = false;
                    } else {
                      out.writeStringAscii(",");
                    }
                    out.writeString("`" + key + "`");
                    if (val == null) {
                      out.writeStringAscii("=NULL");
                    } else {
                      out.writeStringAscii("=");
                      _TextEncoder.writeParam(out, val, opts, info);
                    }
                  }
                  if (first) out.writeStringEscapeQuote(JSON.stringify(value));
                } else {
                  out.writeStringEscapeQuote(JSON.stringify(value));
                }
              }
            }
            break;
        }
      }
      static geometricCollectionToString(geo) {
        if (!geo) return "";
        let st = "";
        for (let i = 0; i < geo.length; i++) {
          st += i !== 0 ? "," : "";
          switch (geo[i].type) {
            case "Point":
              st += `POINT(${_TextEncoder.geoPointToString(geo[i].coordinates)})`;
              break;
            case "LineString":
              st += `LINESTRING(${_TextEncoder.geoArrayPointToString(geo[i].coordinates)})`;
              break;
            case "Polygon":
              st += `POLYGON(${_TextEncoder.geoMultiArrayPointToString(geo[i].coordinates)})`;
              break;
            case "MultiPoint":
              st += `MULTIPOINT(${_TextEncoder.geoArrayPointToString(geo[i].coordinates)})`;
              break;
            case "MultiLineString":
              st += `MULTILINESTRING(${_TextEncoder.geoMultiArrayPointToString(geo[i].coordinates)})`;
              break;
            case "MultiPolygon":
              st += `MULTIPOLYGON(${_TextEncoder.geoMultiPolygonToString(geo[i].coordinates)})`;
              break;
          }
        }
        return st;
      }
      static geoMultiPolygonToString(coords) {
        if (!coords) return "";
        let st = "";
        for (let i = 0; i < coords.length; i++) {
          st += (i !== 0 ? ",(" : "(") + _TextEncoder.geoMultiArrayPointToString(coords[i]) + ")";
        }
        return st;
      }
      static geoMultiArrayPointToString(coords) {
        if (!coords) return "";
        let st = "";
        for (let i = 0; i < coords.length; i++) {
          st += (i !== 0 ? ",(" : "(") + _TextEncoder.geoArrayPointToString(coords[i]) + ")";
        }
        return st;
      }
      static geoArrayPointToString(coords) {
        if (!coords) return "";
        let st = "";
        for (let i = 0; i < coords.length; i++) {
          st += (i !== 0 ? "," : "") + _TextEncoder.geoPointToString(coords[i]);
        }
        return st;
      }
      static geoPointToString(coords) {
        if (!coords) return "";
        return (isNaN(coords[0]) ? "" : coords[0]) + " " + (isNaN(coords[1]) ? "" : coords[1]);
      }
      static getLocalDate(date) {
        const ms = date.getMilliseconds();
        let d = "'" + date.getFullYear() + "-" + (date.getMonth() + 1) + "-" + date.getDate() + " " + date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds();
        if (ms === 0) return d + "'";
        let res = `${ms}`;
        while (res.length < 3) res = "0" + res;
        return d + "." + res + "'";
      }
      static getFixedFormatDate(date) {
        const year = date.getFullYear();
        const mon = date.getMonth() + 1;
        const day = date.getDate();
        const hour = date.getHours();
        const min = date.getMinutes();
        const sec = date.getSeconds();
        const ms = date.getMilliseconds();
        return "'" + formatDigit(year, 4) + "-" + formatDigit(mon, 2) + "-" + formatDigit(day, 2) + " " + formatDigit(hour, 2) + ":" + formatDigit(min, 2) + ":" + formatDigit(sec, 2) + (ms > 0 ? "." + formatDigit(ms, 3) : "") + "'";
      }
    };
    module2.exports = TextEncoder;
  }
});
var require_utils = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/misc/utils.js"(exports, module2) {
    "use strict";
    var hexArray = "0123456789ABCDEF".split("");
    var Errors = require_errors();
    var Iconv = (0, import_chunk_LOGAFLCN.require_lib)();
    var TextEncoder = require_text_encoder();
    module2.exports.log = function(opts, buf, off, end, header) {
      let out = [];
      if (!buf) return "";
      if (off === void 0 || off === null) off = 0;
      if (end === void 0 || end === null) end = buf.length;
      let asciiValue = new Array(16);
      asciiValue[8] = " ";
      let useHeader = header !== void 0;
      let offset = off || 0;
      const maxLgh = Math.min(useHeader ? opts.debugLen - header.length : opts.debugLen, end - offset);
      const isLimited = end - offset > maxLgh;
      let byteValue;
      let posHexa = 0;
      let pos = 0;
      out.push(
        "+--------------------------------------------------+\n|  0  1  2  3  4  5  6  7   8  9  a  b  c  d  e  f |\n+--------------------------------------------------+------------------+\n"
      );
      if (useHeader) {
        while (pos < header.length) {
          if (posHexa === 0) out.push("| ");
          byteValue = header[pos++] & 255;
          out.push(hexArray[byteValue >>> 4], hexArray[byteValue & 15], " ");
          asciiValue[posHexa++] = byteValue > 31 && byteValue < 127 ? String.fromCharCode(byteValue) : ".";
          if (posHexa === 8) out.push(" ");
        }
      }
      pos = offset;
      while (pos < maxLgh + offset) {
        if (posHexa === 0) out.push("| ");
        byteValue = buf[pos] & 255;
        out.push(hexArray[byteValue >>> 4], hexArray[byteValue & 15], " ");
        asciiValue[posHexa++] = byteValue > 31 && byteValue < 127 ? String.fromCharCode(byteValue) : ".";
        if (posHexa === 8) out.push(" ");
        if (posHexa === 16) {
          out.push("| ", asciiValue.join(""), " |\n");
          posHexa = 0;
        }
        pos++;
      }
      let remaining = posHexa;
      if (remaining > 0) {
        if (remaining < 8) {
          for (; remaining < 8; remaining++) {
            out.push("   ");
            asciiValue[posHexa++] = " ";
          }
          out.push(" ");
        }
        for (; remaining < 16; remaining++) {
          out.push("   ");
          asciiValue[posHexa++] = " ";
        }
        out.push("| ", asciiValue.join(""), isLimited ? " |...\n" : " |\n");
      } else if (isLimited) {
        out[out.length - 1] = " |...\n";
      }
      out.push("+--------------------------------------------------+------------------+\n");
      return out.join("");
    };
    module2.exports.toHexString = (bytes) => {
      return Array.from(bytes, (byte) => {
        return ("0" + (byte & 255).toString(16)).slice(-2);
      }).join("");
    };
    module2.exports.escapeId = (opts, info, value) => {
      if (!value || value === "") {
        throw Errors.createError("Cannot escape empty ID value", Errors.ER_NULL_ESCAPEID, info, "0A000");
      }
      if (value.includes("\0")) {
        throw Errors.createError(
          "Cannot escape ID with null character (u0000)",
          Errors.ER_NULL_CHAR_ESCAPEID,
          info,
          "0A000"
        );
      }
      return "`" + value.replace(/`/g, "``") + "`";
    };
    var escapeParameters = (opts, info, value) => {
      if (value == null) return "NULL";
      switch (typeof value) {
        case "boolean":
          return value ? "true" : "false";
        case "bigint":
        case "number":
          return `${value}`;
        case "object":
          if (Object.prototype.toString.call(value) === "[object Date]") {
            return TextEncoder.getFixedFormatDate(value);
          } else if (Buffer.isBuffer(value)) {
            let stValue;
            if (Buffer.isEncoding(info.collation.charset)) {
              stValue = value.toString(info.collation.charset, 0, value.length);
            } else {
              stValue = Iconv.decode(value, info.collation.charset);
            }
            return "_binary'" + escapeString(stValue) + "'";
          } else if (typeof value.toSqlString === "function") {
            return "'" + escapeString(String(value.toSqlString())) + "'";
          } else if (Array.isArray(value)) {
            let out = opts.arrayParenthesis ? "(" : "";
            for (let i = 0; i < value.length; i++) {
              if (i !== 0) out += ",";
              out += escapeParameters(opts, info, value[i]);
            }
            if (opts.arrayParenthesis) out += ")";
            return out;
          } else {
            if (value.type != null && [
              "Point",
              "LineString",
              "Polygon",
              "MultiPoint",
              "MultiLineString",
              "MultiPolygon",
              "GeometryCollection"
            ].includes(value.type)) {
              let prefix = info && (info.isMariaDB() && info.hasMinVersion(10, 1, 4) || !info.isMariaDB() && info.hasMinVersion(5, 7, 6)) ? "ST_" : "";
              switch (value.type) {
                case "Point":
                  return prefix + "PointFromText('POINT(" + TextEncoder.geoPointToString(value.coordinates) + ")')";
                case "LineString":
                  return prefix + "LineFromText('LINESTRING(" + TextEncoder.geoArrayPointToString(value.coordinates) + ")')";
                case "Polygon":
                  return prefix + "PolygonFromText('POLYGON(" + TextEncoder.geoMultiArrayPointToString(value.coordinates) + ")')";
                case "MultiPoint":
                  return prefix + "MULTIPOINTFROMTEXT('MULTIPOINT(" + TextEncoder.geoArrayPointToString(value.coordinates) + ")')";
                case "MultiLineString":
                  return prefix + "MLineFromText('MULTILINESTRING(" + TextEncoder.geoMultiArrayPointToString(value.coordinates) + ")')";
                case "MultiPolygon":
                  return prefix + "MPolyFromText('MULTIPOLYGON(" + TextEncoder.geoMultiPolygonToString(value.coordinates) + ")')";
                case "GeometryCollection":
                  return prefix + "GeomCollFromText('GEOMETRYCOLLECTION(" + TextEncoder.geometricCollectionToString(value.geometries) + ")')";
              }
            } else {
              if (opts.permitSetMultiParamEntries) {
                let out = "";
                let first = true;
                for (let key in value) {
                  const val = value[key];
                  if (typeof val === "function") continue;
                  if (first) {
                    first = false;
                  } else {
                    out += ",";
                  }
                  out += "`" + key + "`=";
                  out += exports.escape(opts, info, val);
                }
                if (out === "") return "'" + escapeString(JSON.stringify(value)) + "'";
                return out;
              } else {
                return "'" + escapeString(JSON.stringify(value)) + "'";
              }
            }
          }
        default:
          return "'" + escapeString(value) + "'";
      }
    };
    var LITTERAL_ESCAPE = {
      "\0": "\\0",
      "'": "\\'",
      '"': '\\"',
      "\b": "\\b",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "": "\\Z",
      "\\": "\\\\"
    };
    var CHARS_GLOBAL_REGEXP = /[\000\032"'\\\b\n\r\t]/g;
    var escapeString = (val) => {
      let offset = 0;
      let escaped = "";
      let match;
      while (match = CHARS_GLOBAL_REGEXP.exec(val)) {
        escaped += val.substring(offset, match.index);
        escaped += LITTERAL_ESCAPE[match[0]];
        offset = CHARS_GLOBAL_REGEXP.lastIndex;
      }
      if (offset === 0) {
        return val;
      }
      if (offset < val.length) {
        escaped += val.substring(offset);
      }
      return escaped;
    };
    module2.exports.escape = escapeParameters;
  }
});
var require_packet_input_stream = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/io/packet-input-stream.js"(exports, module2) {
    "use strict";
    var PacketNodeEncoded = require_packet_node_encoded();
    var PacketIconvEncoded = require_packet_node_iconv();
    var Collations = require_collations();
    var Utils = require_utils();
    var PacketInputStream = class {
      constructor(unexpectedPacket, receiveQueue, out, opts, info) {
        this.unexpectedPacket = unexpectedPacket;
        this.opts = opts;
        this.receiveQueue = receiveQueue;
        this.info = info;
        this.out = out;
        this.header = Buffer.allocUnsafe(4);
        this.headerLen = 0;
        this.packetLen = null;
        this.remainingLen = null;
        this.parts = null;
        this.partsTotalLen = 0;
        this.changeEncoding(this.opts.collation ? this.opts.collation : Collations.fromIndex(224));
        this.changeDebug(this.opts.debug);
        this.opts.on("collation", this.changeEncoding.bind(this));
        this.opts.on("debug", this.changeDebug.bind(this));
      }
      changeEncoding(collation) {
        this.encoding = collation.charset;
        this.packet = Buffer.isEncoding(this.encoding) ? new PacketNodeEncoded(this.encoding) : new PacketIconvEncoded(this.encoding);
      }
      changeDebug(debug) {
        this.receivePacket = debug ? this.receivePacketDebug : this.receivePacketBasic;
      }
      receivePacketDebug(packet) {
        let cmd = this.currentCmd();
        this.header[0] = this.packetLen;
        this.header[1] = this.packetLen >> 8;
        this.header[2] = this.packetLen >> 16;
        this.header[3] = this.sequenceNo;
        if (packet) {
          this.opts.logger.network(
            `<== conn:${this.info.threadId ? this.info.threadId : -1} ${cmd ? cmd.onPacketReceive ? cmd.constructor.name + "." + cmd.onPacketReceive.name : cmd.constructor.name : "no command"} (${packet.pos},${packet.end})
${Utils.log(this.opts, packet.buf, packet.pos, packet.end, this.header)}`
          );
        }
        if (!cmd) {
          this.unexpectedPacket(packet);
          return;
        }
        cmd.sequenceNo = this.sequenceNo;
        cmd.onPacketReceive(packet, this.out, this.opts, this.info);
        if (!cmd.onPacketReceive) {
          this.receiveQueue.shift();
        }
      }
      receivePacketBasic(packet) {
        let cmd = this.currentCmd();
        if (!cmd) {
          this.unexpectedPacket(packet);
          return;
        }
        cmd.sequenceNo = this.sequenceNo;
        cmd.onPacketReceive(packet, this.out, this.opts, this.info);
        if (!cmd.onPacketReceive) this.receiveQueue.shift();
      }
      resetHeader() {
        this.remainingLen = null;
        this.headerLen = 0;
      }
      currentCmd() {
        let cmd;
        while (cmd = this.receiveQueue.peek()) {
          if (cmd.onPacketReceive) return cmd;
          this.receiveQueue.shift();
        }
        return null;
      }
      onData(chunk) {
        let pos = 0;
        let length;
        const chunkLen = chunk.length;
        do {
          if (this.remainingLen) {
            length = this.remainingLen;
          } else if (this.headerLen === 0 && chunkLen - pos >= 4) {
            this.packetLen = chunk[pos] + (chunk[pos + 1] << 8) + (chunk[pos + 2] << 16);
            this.sequenceNo = chunk[pos + 3];
            pos += 4;
            length = this.packetLen;
          } else {
            length = null;
            while (chunkLen - pos > 0) {
              this.header[this.headerLen++] = chunk[pos++];
              if (this.headerLen === 4) {
                this.packetLen = this.header[0] + (this.header[1] << 8) + (this.header[2] << 16);
                this.sequenceNo = this.header[3];
                length = this.packetLen;
                break;
              }
            }
          }
          if (length) {
            if (chunkLen - pos >= length) {
              pos += length;
              if (!this.parts) {
                if (this.packetLen < 16777215) {
                  this.receivePacket(this.packet.update(chunk, pos - length, pos));
                  while (pos + 4 < chunkLen) {
                    this.packetLen = chunk[pos] + (chunk[pos + 1] << 8) + (chunk[pos + 2] << 16);
                    this.sequenceNo = chunk[pos + 3];
                    pos += 4;
                    if (chunkLen - pos >= this.packetLen) {
                      pos += this.packetLen;
                      if (this.packetLen < 16777215) {
                        this.receivePacket(this.packet.update(chunk, pos - this.packetLen, pos));
                      } else {
                        this.parts = [chunk.subarray(pos - this.packetLen, pos)];
                        this.partsTotalLen = this.packetLen;
                        break;
                      }
                    } else {
                      const buf = chunk.subarray(pos, chunkLen);
                      if (!this.parts) {
                        this.parts = [buf];
                        this.partsTotalLen = chunkLen - pos;
                      } else {
                        this.parts.push(buf);
                        this.partsTotalLen += chunkLen - pos;
                      }
                      this.remainingLen = this.packetLen - (chunkLen - pos);
                      return;
                    }
                  }
                } else {
                  this.parts = [chunk.subarray(pos - length, pos)];
                  this.partsTotalLen = length;
                }
              } else {
                this.parts.push(chunk.subarray(pos - length, pos));
                this.partsTotalLen += length;
                if (this.packetLen < 16777215) {
                  let buf = Buffer.concat(this.parts, this.partsTotalLen);
                  this.parts = null;
                  this.receivePacket(this.packet.update(buf, 0, this.partsTotalLen));
                }
              }
              this.resetHeader();
            } else {
              const buf = chunk.subarray(pos, chunkLen);
              if (!this.parts) {
                this.parts = [buf];
                this.partsTotalLen = chunkLen - pos;
              } else {
                this.parts.push(buf);
                this.partsTotalLen += chunkLen - pos;
              }
              this.remainingLen = length - (chunkLen - pos);
              return;
            }
          }
        } while (pos < chunkLen);
      }
    };
    module2.exports = PacketInputStream;
  }
});
var require_packet_output_stream = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/io/packet-output-stream.js"(exports, module2) {
    "use strict";
    var Iconv = (0, import_chunk_LOGAFLCN.require_lib)();
    var Utils = require_utils();
    var Errors = require_errors();
    var Collations = require_collations();
    var QUOTE = 39;
    var DBL_QUOTE = 34;
    var ZERO_BYTE = 0;
    var SLASH = 92;
    var SMALL_BUFFER_SIZE = 256;
    var MEDIUM_BUFFER_SIZE = 16384;
    var LARGE_BUFFER_SIZE = 131072;
    var BIG_BUFFER_SIZE = 1048576;
    var MAX_BUFFER_SIZE = 16777219;
    var CHARS_GLOBAL_REGEXP = /[\000\032"'\\\n\r\t]/g;
    var PacketOutputStream = class {
      constructor(opts, info) {
        this.opts = opts;
        this.info = info;
        this.pos = 4;
        this.markPos = -1;
        this.bufContainDataAfterMark = false;
        this.cmdLength = 0;
        this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);
        this.maxAllowedPacket = opts.maxAllowedPacket || 16777216;
        this.maxPacketLength = Math.min(MAX_BUFFER_SIZE, this.maxAllowedPacket + 4);
        this.changeEncoding(this.opts.collation ? this.opts.collation : Collations.fromIndex(224));
        this.changeDebug(this.opts.debug);
        this.opts.on("collation", this.changeEncoding.bind(this));
        this.opts.on("debug", this.changeDebug.bind(this));
      }
      changeEncoding(collation) {
        this.encoding = collation.charset;
        if (this.encoding === "utf8") {
          this.writeString = this.writeDefaultBufferString;
          this.encodeString = this.encodeNodeString;
          this.writeLengthEncodedString = this.writeDefaultBufferLengthEncodedString;
          this.writeStringEscapeQuote = this.writeUtf8StringEscapeQuote;
        } else if (Buffer.isEncoding(this.encoding)) {
          this.writeString = this.writeDefaultBufferString;
          this.encodeString = this.encodeNodeString;
          this.writeLengthEncodedString = this.writeDefaultBufferLengthEncodedString;
          this.writeStringEscapeQuote = this.writeDefaultStringEscapeQuote;
        } else {
          this.writeString = this.writeDefaultIconvString;
          this.encodeString = this.encodeIconvString;
          this.writeLengthEncodedString = this.writeDefaultIconvLengthEncodedString;
          this.writeStringEscapeQuote = this.writeDefaultStringEscapeQuote;
        }
      }
      changeDebug(debug) {
        this.debug = debug;
        this.flushBuffer = debug ? this.flushBufferDebug : this.flushBufferBasic;
        this.fastFlush = debug ? this.fastFlushDebug : this.fastFlushBasic;
      }
      setStream(stream) {
        this.stream = stream;
      }
      growBuffer(len) {
        let newCapacity;
        if (len + this.pos < MEDIUM_BUFFER_SIZE) {
          newCapacity = MEDIUM_BUFFER_SIZE;
        } else if (len + this.pos < LARGE_BUFFER_SIZE) {
          newCapacity = LARGE_BUFFER_SIZE;
        } else if (len + this.pos < BIG_BUFFER_SIZE) {
          newCapacity = BIG_BUFFER_SIZE;
        } else if (this.bufContainDataAfterMark) {
          newCapacity = len + this.pos;
        } else {
          newCapacity = MAX_BUFFER_SIZE;
        }
        if (len + this.pos > newCapacity) {
          if (this.markPos !== -1) {
            this.flushBufferStopAtMark();
            if (len + this.pos <= this.buf.length) {
              return;
            }
            return this.growBuffer(len);
          }
        }
        let newBuf = Buffer.allocUnsafe(newCapacity);
        this.buf.copy(newBuf, 0, 0, this.pos);
        this.buf = newBuf;
      }
      mark() {
        this.markPos = this.pos;
      }
      isMarked() {
        return this.markPos !== -1;
      }
      hasFlushed() {
        return this.cmd.sequenceNo !== -1;
      }
      bufIsDataAfterMark() {
        return this.bufContainDataAfterMark;
      }
      bufIsAfterMaxPacketLength() {
        return this.pos > this.maxPacketLength;
      }
      /**
       * Reset mark flag and send bytes after mark flag.
       *
       * @return buffer after mark flag
       */
      resetMark() {
        this.pos = this.markPos;
        this.markPos = -1;
        if (this.bufContainDataAfterMark) {
          const data = Buffer.allocUnsafe(this.pos - 4);
          this.buf.copy(data, 0, 4, this.pos);
          this.cmd.sequenceNo = -1;
          this.cmd.compressSequenceNo = -1;
          this.bufContainDataAfterMark = false;
          return data;
        }
        return null;
      }
      /**
       * Send packet to socket.
       *
       * @throws IOException if socket error occur.
       */
      flush() {
        this.flushBuffer(true, 0);
        this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);
        this.cmd.sequenceNo = -1;
        this.cmd.compressSequenceNo = -1;
        this.cmdLength = 0;
        this.markPos = -1;
      }
      flushPacket() {
        this.flushBuffer(false, 0);
        this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);
        this.cmdLength = 0;
        this.markPos = -1;
      }
      startPacket(cmd) {
        this.cmd = cmd;
        this.pos = 4;
      }
      writeInt8(value) {
        if (this.pos + 1 >= this.buf.length) {
          if (this.pos >= MAX_BUFFER_SIZE && !this.bufContainDataAfterMark) {
            this.flushBuffer(false, 1);
          } else this.growBuffer(1);
        }
        this.buf[this.pos++] = value;
      }
      writeInt16(value) {
        if (this.pos + 2 >= this.buf.length) {
          let b = Buffer.allocUnsafe(2);
          b[0] = value;
          b[1] = value >>> 8;
          this.writeBuffer(b, 0, 2);
          return;
        }
        this.buf[this.pos] = value;
        this.buf[this.pos + 1] = value >> 8;
        this.pos += 2;
      }
      writeInt16AtPos(initPos) {
        this.buf[initPos] = this.pos - initPos - 2;
        this.buf[initPos + 1] = this.pos - initPos - 2 >> 8;
      }
      writeInt24(value) {
        if (this.pos + 3 >= this.buf.length) {
          let arr = Buffer.allocUnsafe(3);
          arr[0] = value;
          arr[1] = value >> 8;
          arr[2] = value >> 16;
          this.writeBuffer(arr, 0, 3);
          return;
        }
        this.buf[this.pos] = value;
        this.buf[this.pos + 1] = value >> 8;
        this.buf[this.pos + 2] = value >> 16;
        this.pos += 3;
      }
      writeInt32(value) {
        if (this.pos + 4 >= this.buf.length) {
          let arr = Buffer.allocUnsafe(4);
          arr.writeInt32LE(value, 0);
          this.writeBuffer(arr, 0, 4);
          return;
        }
        this.buf[this.pos] = value;
        this.buf[this.pos + 1] = value >> 8;
        this.buf[this.pos + 2] = value >> 16;
        this.buf[this.pos + 3] = value >> 24;
        this.pos += 4;
      }
      writeBigInt(value) {
        if (this.pos + 8 >= this.buf.length) {
          let arr = Buffer.allocUnsafe(8);
          arr.writeBigInt64LE(value, 0);
          this.writeBuffer(arr, 0, 8);
          return;
        }
        this.buf.writeBigInt64LE(value, this.pos);
        this.pos += 8;
      }
      writeDouble(value) {
        if (this.pos + 8 >= this.buf.length) {
          let arr = Buffer.allocUnsafe(8);
          arr.writeDoubleLE(value, 0);
          this.writeBuffer(arr, 0, 8);
          return;
        }
        this.buf.writeDoubleLE(value, this.pos);
        this.pos += 8;
      }
      writeLengthCoded(len) {
        if (len < 251) {
          this.writeInt8(len);
          return;
        }
        if (len < 65536) {
          this.writeInt8(252);
          this.writeInt16(len);
        } else if (len < 16777216) {
          this.writeInt8(253);
          this.writeInt24(len);
        } else {
          this.writeInt8(254);
          this.writeBigInt(BigInt(len));
        }
      }
      writeBuffer(arr, off, len) {
        if (len > this.buf.length - this.pos) {
          if (this.buf.length !== MAX_BUFFER_SIZE) {
            this.growBuffer(len);
          }
          if (len > this.buf.length - this.pos) {
            if (this.markPos !== -1) {
              this.growBuffer(len);
              if (this.markPos !== -1) {
                this.flushBufferStopAtMark();
              }
            }
            if (len > this.buf.length - this.pos) {
              let remainingLen = len;
              while (true) {
                let lenToFillBuffer = Math.min(MAX_BUFFER_SIZE - this.pos, remainingLen);
                arr.copy(this.buf, this.pos, off, off + lenToFillBuffer);
                remainingLen -= lenToFillBuffer;
                off += lenToFillBuffer;
                this.pos += lenToFillBuffer;
                if (remainingLen === 0) return;
                this.flushBuffer(false, remainingLen);
              }
            }
          }
        }
        if (len > 50) {
          arr.copy(this.buf, this.pos, off, off + len);
          this.pos += len;
        } else {
          for (let i = 0; i < len; ) {
            this.buf[this.pos++] = arr[off + i++];
          }
        }
      }
      /**
       * Write ascii string to socket (no escaping)
       *
       * @param str                string
       */
      writeStringAscii(str) {
        let len = str.length;
        if (len >= this.buf.length - this.pos) {
          let strBuf = Buffer.from(str, "ascii");
          this.writeBuffer(strBuf, 0, strBuf.length);
          return;
        }
        for (let off = 0; off < len; ) {
          this.buf[this.pos++] = str.charCodeAt(off++);
        }
      }
      writeLengthEncodedBuffer(buffer) {
        const len = buffer.length;
        this.writeLengthCoded(len);
        this.writeBuffer(buffer, 0, len);
      }
      writeUtf8StringEscapeQuote(str) {
        const charsLength = str.length;
        if (charsLength * 3 + 2 >= this.buf.length - this.pos) {
          const arr = Buffer.from(str, "utf8");
          this.writeInt8(QUOTE);
          this.writeBufferEscape(arr);
          this.writeInt8(QUOTE);
          return;
        }
        let charsOffset = 0;
        let currChar;
        this.buf[this.pos++] = QUOTE;
        for (; charsOffset < charsLength && (currChar = str.charCodeAt(charsOffset)) < 128; charsOffset++) {
          if (currChar === SLASH || currChar === QUOTE || currChar === ZERO_BYTE || currChar === DBL_QUOTE) {
            this.buf[this.pos++] = SLASH;
          }
          this.buf[this.pos++] = currChar;
        }
        while (charsOffset < charsLength) {
          currChar = str.charCodeAt(charsOffset++);
          if (currChar < 128) {
            if (currChar === SLASH || currChar === QUOTE || currChar === ZERO_BYTE || currChar === DBL_QUOTE) {
              this.buf[this.pos++] = SLASH;
            }
            this.buf[this.pos++] = currChar;
          } else if (currChar < 2048) {
            this.buf[this.pos++] = 192 | currChar >> 6;
            this.buf[this.pos++] = 128 | currChar & 63;
          } else if (currChar >= 55296 && currChar < 57344) {
            if (currChar < 56320) {
              if (charsOffset + 1 > charsLength) {
                this.buf[this.pos++] = 63;
              } else {
                const nextChar = str.charCodeAt(charsOffset);
                if (nextChar >= 56320 && nextChar < 57344) {
                  const surrogatePairs = (currChar << 10) + nextChar + (65536 - (55296 << 10) - 56320);
                  this.buf[this.pos++] = 240 | surrogatePairs >> 18;
                  this.buf[this.pos++] = 128 | surrogatePairs >> 12 & 63;
                  this.buf[this.pos++] = 128 | surrogatePairs >> 6 & 63;
                  this.buf[this.pos++] = 128 | surrogatePairs & 63;
                  charsOffset++;
                } else {
                  this.buf[this.pos++] = 63;
                }
              }
            } else {
              this.buf[this.pos++] = 63;
            }
          } else {
            this.buf[this.pos++] = 224 | currChar >> 12;
            this.buf[this.pos++] = 128 | currChar >> 6 & 63;
            this.buf[this.pos++] = 128 | currChar & 63;
          }
        }
        this.buf[this.pos++] = QUOTE;
      }
      encodeIconvString(str) {
        return Iconv.encode(str, this.encoding);
      }
      encodeNodeString(str) {
        return Buffer.from(str, this.encoding);
      }
      writeDefaultBufferString(str) {
        if (str.length * 3 < this.buf.length - this.pos) {
          this.pos += this.buf.write(str, this.pos, this.encoding);
          return;
        }
        let byteLength = Buffer.byteLength(str, this.encoding);
        if (byteLength > this.buf.length - this.pos) {
          if (this.buf.length < MAX_BUFFER_SIZE) {
            this.growBuffer(byteLength);
          }
          if (byteLength > this.buf.length - this.pos) {
            let strBuf = Buffer.from(str, this.encoding);
            this.writeBuffer(strBuf, 0, strBuf.length);
            return;
          }
        }
        this.pos += this.buf.write(str, this.pos, this.encoding);
      }
      writeDefaultBufferLengthEncodedString(str) {
        let byteLength = Buffer.byteLength(str, this.encoding);
        this.writeLengthCoded(byteLength);
        if (byteLength > this.buf.length - this.pos) {
          if (this.buf.length < MAX_BUFFER_SIZE) {
            this.growBuffer(byteLength);
          }
          if (byteLength > this.buf.length - this.pos) {
            let strBuf = Buffer.from(str, this.encoding);
            this.writeBuffer(strBuf, 0, strBuf.length);
            return;
          }
        }
        this.pos += this.buf.write(str, this.pos, this.encoding);
      }
      writeDefaultIconvString(str) {
        let buf = Iconv.encode(str, this.encoding);
        this.writeBuffer(buf, 0, buf.length);
      }
      writeDefaultIconvLengthEncodedString(str) {
        let buf = Iconv.encode(str, this.encoding);
        this.writeLengthCoded(buf.length);
        this.writeBuffer(buf, 0, buf.length);
      }
      /**
       * Parameters need to be properly escaped :
       * following characters are to be escaped by "\" :
       * - \0
       * - \\
       * - \'
       * - \"
       * - \032
       * regex split part of string writing part, and escaping special char.
       * Those chars are <= 7f meaning that this will work even with multibyte encoding
       *
       * @param str string to escape.
       */
      writeDefaultStringEscapeQuote(str) {
        this.writeInt8(QUOTE);
        let match;
        let lastIndex = 0;
        while ((match = CHARS_GLOBAL_REGEXP.exec(str)) !== null) {
          this.writeString(str.slice(lastIndex, match.index));
          this.writeInt8(SLASH);
          this.writeInt8(match[0].charCodeAt(0));
          lastIndex = CHARS_GLOBAL_REGEXP.lastIndex;
        }
        if (lastIndex === 0) {
          this.writeString(str);
          this.writeInt8(QUOTE);
          return;
        }
        if (lastIndex < str.length) {
          this.writeString(str.slice(lastIndex));
        }
        this.writeInt8(QUOTE);
      }
      writeBinaryDate(date) {
        const year = date.getFullYear();
        const mon = date.getMonth() + 1;
        const day = date.getDate();
        const hour = date.getHours();
        const min = date.getMinutes();
        const sec = date.getSeconds();
        const ms = date.getMilliseconds();
        let len = ms === 0 ? 7 : 11;
        if (len + 1 > this.buf.length - this.pos) {
          let tmpBuf = Buffer.allocUnsafe(len + 1);
          tmpBuf[0] = len;
          tmpBuf[1] = year;
          tmpBuf[2] = year >>> 8;
          tmpBuf[3] = mon;
          tmpBuf[4] = day;
          tmpBuf[5] = hour;
          tmpBuf[6] = min;
          tmpBuf[7] = sec;
          if (ms !== 0) {
            const micro = ms * 1e3;
            tmpBuf[8] = micro;
            tmpBuf[9] = micro >>> 8;
            tmpBuf[10] = micro >>> 16;
            tmpBuf[11] = micro >>> 24;
          }
          this.writeBuffer(tmpBuf, 0, len + 1);
          return;
        }
        this.buf[this.pos] = len;
        this.buf[this.pos + 1] = year;
        this.buf[this.pos + 2] = year >>> 8;
        this.buf[this.pos + 3] = mon;
        this.buf[this.pos + 4] = day;
        this.buf[this.pos + 5] = hour;
        this.buf[this.pos + 6] = min;
        this.buf[this.pos + 7] = sec;
        if (ms !== 0) {
          const micro = ms * 1e3;
          this.buf[this.pos + 8] = micro;
          this.buf[this.pos + 9] = micro >>> 8;
          this.buf[this.pos + 10] = micro >>> 16;
          this.buf[this.pos + 11] = micro >>> 24;
        }
        this.pos += len + 1;
      }
      writeBufferEscape(val) {
        let valLen = val.length;
        if (valLen * 2 > this.buf.length - this.pos) {
          if (this.buf.length !== MAX_BUFFER_SIZE) this.growBuffer(valLen * 2);
          if (valLen * 2 > this.buf.length - this.pos) {
            for (let i = 0; i < valLen; i++) {
              switch (val[i]) {
                case QUOTE:
                case SLASH:
                case DBL_QUOTE:
                case ZERO_BYTE:
                  if (this.pos >= this.buf.length) this.flushBuffer(false, (valLen - i) * 2);
                  this.buf[this.pos++] = SLASH;
              }
              if (this.pos >= this.buf.length) this.flushBuffer(false, (valLen - i) * 2);
              this.buf[this.pos++] = val[i];
            }
            return;
          }
        }
        for (let i = 0; i < valLen; i++) {
          switch (val[i]) {
            case QUOTE:
            case SLASH:
            case DBL_QUOTE:
            case ZERO_BYTE:
              this.buf[this.pos++] = SLASH;
          }
          this.buf[this.pos++] = val[i];
        }
      }
      /**
       * Count query size. If query size is greater than max_allowed_packet and nothing has been already
       * send, throw an exception to avoid having the connection closed.
       *
       * @param length additional length to query size
       * @param info current connection information
       * @throws Error if query has not to be sent.
       */
      checkMaxAllowedLength(length, info) {
        if (this.opts.maxAllowedPacket && this.cmdLength + length >= this.maxAllowedPacket) {
          return Errors.createError(
            `query size (${this.cmdLength + length}) is >= to max_allowed_packet (${this.maxAllowedPacket})`,
            Errors.ER_MAX_ALLOWED_PACKET,
            info
          );
        }
        return null;
      }
      /**
       * Indicate if buffer contain any data.
       * @returns {boolean}
       */
      isEmpty() {
        return this.pos <= 4;
      }
      /**
       * Flush the internal buffer.
       */
      flushBufferDebug(commandEnd, remainingLen) {
        if (this.pos > 4) {
          this.buf[0] = this.pos - 4;
          this.buf[1] = this.pos - 4 >>> 8;
          this.buf[2] = this.pos - 4 >>> 16;
          this.buf[3] = ++this.cmd.sequenceNo;
          this.stream.writeBuf(this.buf.subarray(0, this.pos), this.cmd);
          this.stream.flush(true, this.cmd);
          this.cmdLength += this.pos - 4;
          this.opts.logger.network(
            `==> conn:${this.info.threadId ? this.info.threadId : -1} ${this.cmd.constructor.name + "(0," + this.pos + ")"}
${Utils.log(this.opts, this.buf, 0, this.pos)}`
          );
          if (commandEnd && this.pos === MAX_BUFFER_SIZE) {
            this.writeEmptyPacket();
          }
          this.buf = this.createBufferWithMinSize(remainingLen);
          this.pos = 4;
        }
      }
      /**
       * Flush to last mark.
       */
      flushBufferStopAtMark() {
        const end = this.pos;
        this.pos = this.markPos;
        const tmpBuf = Buffer.allocUnsafe(Math.max(SMALL_BUFFER_SIZE, end + 4 - this.pos));
        this.buf.copy(tmpBuf, 4, this.markPos, end);
        this.flushBuffer(true, end - this.pos);
        this.cmdLength = 0;
        this.buf = tmpBuf;
        this.pos = 4 + end - this.markPos;
        this.markPos = -1;
        this.bufContainDataAfterMark = true;
      }
      flushBufferBasic(commandEnd, remainingLen) {
        this.buf[0] = this.pos - 4;
        this.buf[1] = this.pos - 4 >>> 8;
        this.buf[2] = this.pos - 4 >>> 16;
        this.buf[3] = ++this.cmd.sequenceNo;
        this.stream.writeBuf(this.buf.subarray(0, this.pos), this.cmd);
        this.stream.flush(true, this.cmd);
        this.cmdLength += this.pos - 4;
        if (commandEnd && this.pos === MAX_BUFFER_SIZE) {
          this.writeEmptyPacket();
        }
        this.buf = this.createBufferWithMinSize(remainingLen);
        this.pos = 4;
      }
      createBufferWithMinSize(remainingLen) {
        let newCapacity;
        if (remainingLen + 4 < SMALL_BUFFER_SIZE) {
          newCapacity = SMALL_BUFFER_SIZE;
        } else if (remainingLen + 4 < MEDIUM_BUFFER_SIZE) {
          newCapacity = MEDIUM_BUFFER_SIZE;
        } else if (remainingLen + 4 < LARGE_BUFFER_SIZE) {
          newCapacity = LARGE_BUFFER_SIZE;
        } else if (remainingLen + 4 < BIG_BUFFER_SIZE) {
          newCapacity = BIG_BUFFER_SIZE;
        } else {
          newCapacity = MAX_BUFFER_SIZE;
        }
        return Buffer.allocUnsafe(newCapacity);
      }
      fastFlushDebug(cmd, packet) {
        this.stream.writeBuf(packet, cmd);
        this.stream.flush(true, cmd);
        this.cmdLength += packet.length;
        this.opts.logger.network(
          `==> conn:${this.info.threadId ? this.info.threadId : -1} ${cmd.constructor.name + "(0," + packet.length + ")"}
${Utils.log(this.opts, packet, 0, packet.length)}`
        );
        this.cmdLength = 0;
        this.markPos = -1;
      }
      fastFlushBasic(cmd, packet) {
        this.stream.writeBuf(packet, cmd);
        this.stream.flush(true, cmd);
        this.cmdLength = 0;
        this.markPos = -1;
      }
      writeEmptyPacket() {
        const emptyBuf = Buffer.from([0, 0, 0, ++this.cmd.sequenceNo]);
        if (this.debug) {
          this.opts.logger.network(
            `==> conn:${this.info.threadId ? this.info.threadId : -1} ${this.cmd.constructor.name}(0,4)
${Utils.log(
              this.opts,
              emptyBuf,
              0,
              4
            )}`
          );
        }
        this.stream.writeBuf(emptyBuf, this.cmd);
        this.stream.flush(true, this.cmd);
        this.cmdLength = 0;
      }
    };
    module2.exports = PacketOutputStream;
  }
});
var require_compression_input_stream = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/io/compression-input-stream.js"(exports, module2) {
    "use strict";
    var ZLib = (0, import_chunk_WWAWV7DQ.__require)("zlib");
    var Utils = require_utils();
    var CompressionInputStream = class {
      constructor(reader, receiveQueue, opts, info) {
        this.reader = reader;
        this.receiveQueue = receiveQueue;
        this.info = info;
        this.opts = opts;
        this.header = Buffer.allocUnsafe(7);
        this.headerLen = 0;
        this.compressPacketLen = null;
        this.packetLen = null;
        this.remainingLen = null;
        this.parts = null;
        this.partsTotalLen = 0;
      }
      receivePacket(chunk) {
        let cmd = this.currentCmd();
        if (this.opts.debugCompress) {
          this.opts.logger.network(
            `<== conn:${this.info.threadId ? this.info.threadId : -1} ${cmd ? cmd.onPacketReceive ? cmd.constructor.name + "." + cmd.onPacketReceive.name : cmd.constructor.name : "no command"} (compress)
${Utils.log(this.opts, chunk, 0, chunk.length, this.header)}`
          );
        }
        if (cmd) cmd.compressSequenceNo = this.header[3];
        const unCompressLen = this.header[4] | this.header[5] << 8 | this.header[6] << 16;
        if (unCompressLen === 0) {
          this.reader.onData(chunk);
        } else {
          const unCompressChunk = ZLib.inflateSync(chunk);
          this.reader.onData(unCompressChunk);
        }
      }
      currentCmd() {
        let cmd;
        while (cmd = this.receiveQueue.peek()) {
          if (cmd.onPacketReceive) return cmd;
          this.receiveQueue.shift();
        }
        return null;
      }
      resetHeader() {
        this.remainingLen = null;
        this.headerLen = 0;
      }
      onData(chunk) {
        let pos = 0;
        let length;
        const chunkLen = chunk.length;
        do {
          if (this.remainingLen) {
            length = this.remainingLen;
          } else if (this.headerLen === 0 && chunkLen - pos >= 7) {
            this.header[0] = chunk[pos];
            this.header[1] = chunk[pos + 1];
            this.header[2] = chunk[pos + 2];
            this.header[3] = chunk[pos + 3];
            this.header[4] = chunk[pos + 4];
            this.header[5] = chunk[pos + 5];
            this.header[6] = chunk[pos + 6];
            this.headerLen = 7;
            pos += 7;
            this.compressPacketLen = this.header[0] + (this.header[1] << 8) + (this.header[2] << 16);
            this.packetLen = this.header[4] | this.header[5] << 8 | this.header[6] << 16;
            if (this.packetLen === 0) this.packetLen = this.compressPacketLen;
            length = this.compressPacketLen;
          } else {
            length = null;
            while (chunkLen - pos > 0) {
              this.header[this.headerLen++] = chunk[pos++];
              if (this.headerLen === 7) {
                this.compressPacketLen = this.header[0] + (this.header[1] << 8) + (this.header[2] << 16);
                this.packetLen = this.header[4] | this.header[5] << 8 | this.header[6] << 16;
                if (this.packetLen === 0) this.packetLen = this.compressPacketLen;
                length = this.compressPacketLen;
                break;
              }
            }
          }
          if (length) {
            if (chunkLen - pos >= length) {
              const buf = chunk.subarray(pos, pos + length);
              pos += length;
              if (this.parts) {
                this.parts.push(buf);
                this.partsTotalLen += length;
                if (this.compressPacketLen < 16777215) {
                  let buf2 = Buffer.concat(this.parts, this.partsTotalLen);
                  this.parts = null;
                  this.receivePacket(buf2);
                }
              } else {
                if (this.compressPacketLen < 16777215) {
                  this.receivePacket(buf);
                } else {
                  this.parts = [buf];
                  this.partsTotalLen = length;
                }
              }
              this.resetHeader();
            } else {
              const buf = chunk.subarray(pos, chunkLen);
              if (!this.parts) {
                this.parts = [buf];
                this.partsTotalLen = chunkLen - pos;
              } else {
                this.parts.push(buf);
                this.partsTotalLen += chunkLen - pos;
              }
              this.remainingLen = length - (chunkLen - pos);
              return;
            }
          }
        } while (pos < chunkLen);
      }
    };
    module2.exports = CompressionInputStream;
  }
});
var require_compression_output_stream = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/io/compression-output-stream.js"(exports, module2) {
    "use strict";
    var Utils = require_utils();
    var ZLib = (0, import_chunk_WWAWV7DQ.__require)("zlib");
    var SMALL_BUFFER_SIZE = 2048;
    var MEDIUM_BUFFER_SIZE = 131072;
    var LARGE_BUFFER_SIZE = 1048576;
    var MAX_BUFFER_SIZE = 16777222;
    var CompressionOutputStream = class _CompressionOutputStream {
      /**
       * Constructor
       *
       * @param socket    current socket
       * @param opts      current connection options
       * @param info      current connection information
       * @constructor
       */
      constructor(socket, opts, info) {
        this.info = info;
        this.opts = opts;
        this.pos = 7;
        this.header = Buffer.allocUnsafe(7);
        this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);
        this.writer = (buffer) => {
          socket.write(buffer);
        };
      }
      growBuffer(len) {
        let newCapacity;
        if (len + this.pos < MEDIUM_BUFFER_SIZE) {
          newCapacity = MEDIUM_BUFFER_SIZE;
        } else if (len + this.pos < LARGE_BUFFER_SIZE) {
          newCapacity = LARGE_BUFFER_SIZE;
        } else newCapacity = MAX_BUFFER_SIZE;
        let newBuf = Buffer.allocUnsafe(newCapacity);
        this.buf.copy(newBuf, 0, 0, this.pos);
        this.buf = newBuf;
      }
      writeBuf(arr, cmd) {
        let off = 0, len = arr.length;
        if (arr instanceof Uint8Array) {
          arr = Buffer.from(arr);
        }
        if (len > this.buf.length - this.pos) {
          if (this.buf.length !== MAX_BUFFER_SIZE) {
            this.growBuffer(len);
          }
          if (len > this.buf.length - this.pos) {
            let remainingLen = len;
            while (true) {
              let lenToFillBuffer = Math.min(MAX_BUFFER_SIZE - this.pos, remainingLen);
              arr.copy(this.buf, this.pos, off, off + lenToFillBuffer);
              remainingLen -= lenToFillBuffer;
              off += lenToFillBuffer;
              this.pos += lenToFillBuffer;
              if (remainingLen === 0) return;
              this.flush(false, cmd, remainingLen);
            }
          }
        }
        arr.copy(this.buf, this.pos, off, off + len);
        this.pos += len;
      }
      /**
       * Flush the internal buffer.
       */
      flush(cmdEnd, cmd, remainingLen) {
        if (this.pos < 1536) {
          this.buf[0] = this.pos - 7;
          this.buf[1] = this.pos - 7 >>> 8;
          this.buf[2] = this.pos - 7 >>> 16;
          this.buf[3] = ++cmd.compressSequenceNo;
          this.buf[4] = 0;
          this.buf[5] = 0;
          this.buf[6] = 0;
          if (this.opts.debugCompress) {
            this.opts.logger.network(
              `==> conn:${this.info.threadId ? this.info.threadId : -1} ${cmd ? cmd.constructor.name + "(0," + this.pos + ")" : "unknown"} (compress)
${Utils.log(this.opts, this.buf, 0, this.pos)}`
            );
          }
          this.writer(this.buf.subarray(0, this.pos));
        } else {
          const compressChunk = ZLib.deflateSync(this.buf.subarray(7, this.pos));
          const compressChunkLen = compressChunk.length;
          this.header[0] = compressChunkLen;
          this.header[1] = compressChunkLen >>> 8;
          this.header[2] = compressChunkLen >>> 16;
          this.header[3] = ++cmd.compressSequenceNo;
          this.header[4] = this.pos - 7;
          this.header[5] = this.pos - 7 >>> 8;
          this.header[6] = this.pos - 7 >>> 16;
          if (this.opts.debugCompress) {
            this.opts.logger.network(
              `==> conn:${this.info.threadId ? this.info.threadId : -1} ${cmd ? cmd.constructor.name + "(0," + this.pos + "=>" + compressChunkLen + ")" : "unknown"} (compress)
${Utils.log(this.opts, compressChunk, 0, compressChunkLen, this.header)}`
            );
          }
          this.writer(this.header);
          this.writer(compressChunk);
          if (cmdEnd && compressChunkLen === MAX_BUFFER_SIZE) this.writeEmptyPacket(cmd);
          this.header = Buffer.allocUnsafe(7);
        }
        this.buf = remainingLen ? _CompressionOutputStream.allocateBuffer(remainingLen) : Buffer.allocUnsafe(SMALL_BUFFER_SIZE);
        this.pos = 7;
      }
      static allocateBuffer(len) {
        if (len + 4 < SMALL_BUFFER_SIZE) {
          return Buffer.allocUnsafe(SMALL_BUFFER_SIZE);
        } else if (len + 4 < MEDIUM_BUFFER_SIZE) {
          return Buffer.allocUnsafe(MEDIUM_BUFFER_SIZE);
        } else if (len + 4 < LARGE_BUFFER_SIZE) {
          return Buffer.allocUnsafe(LARGE_BUFFER_SIZE);
        }
        return Buffer.allocUnsafe(MAX_BUFFER_SIZE);
      }
      writeEmptyPacket(cmd) {
        const emptyBuf = Buffer.from([0, 0, 0, cmd.compressSequenceNo, 0, 0, 0]);
        if (this.opts.debugCompress) {
          this.opts.logger.network(
            `==> conn:${this.info.threadId ? this.info.threadId : -1} ${cmd ? cmd.constructor.name + "(0," + this.pos + ")" : "unknown"} (compress)
${Utils.log(this.opts, emptyBuf, 0, 7)}`
          );
        }
        this.writer(emptyBuf);
      }
    };
    module2.exports = CompressionOutputStream;
  }
});
var require_server_status = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/const/server-status.js"(exports, module2) {
    "use strict";
    module2.exports.STATUS_IN_TRANS = 1;
    module2.exports.STATUS_AUTOCOMMIT = 2;
    module2.exports.MORE_RESULTS_EXISTS = 8;
    module2.exports.QUERY_NO_GOOD_INDEX_USED = 16;
    module2.exports.QUERY_NO_INDEX_USED = 32;
    module2.exports.STATUS_CURSOR_EXISTS = 64;
    module2.exports.STATUS_LAST_ROW_SENT = 128;
    module2.exports.STATUS_DB_DROPPED = 1 << 8;
    module2.exports.STATUS_NO_BACKSLASH_ESCAPES = 1 << 9;
    module2.exports.STATUS_METADATA_CHANGED = 1 << 10;
    module2.exports.QUERY_WAS_SLOW = 1 << 11;
    module2.exports.PS_OUT_PARAMS = 1 << 12;
    module2.exports.STATUS_IN_TRANS_READONLY = 1 << 13;
    module2.exports.SESSION_STATE_CHANGED = 1 << 14;
  }
});
var require_connection_information = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/misc/connection-information.js"(exports, module2) {
    "use strict";
    var _redirectFct;
    var ConnectionInformation = class {
      constructor(opts, redirectFct) {
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _redirectFct);
        this.threadId = -1;
        this.status = null;
        this.serverVersion = null;
        this.serverCapabilities = null;
        this.database = opts.database;
        this.port = opts.port;
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _redirectFct, redirectFct);
        this.redirectRequest = null;
      }
      hasMinVersion(major, minor, patch) {
        if (!this.serverVersion) throw new Error("cannot know if server version until connection is established");
        if (!major) throw new Error("a major version must be set");
        if (!minor) minor = 0;
        if (!patch) patch = 0;
        let ver = this.serverVersion;
        return ver.major > major || ver.major === major && ver.minor > minor || ver.major === major && ver.minor === minor && ver.patch >= patch;
      }
      redirect(value, resolve) {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _redirectFct).call(this, value, resolve);
      }
      isMariaDB() {
        if (!this.serverVersion) throw new Error("cannot know if server is MariaDB until connection is established");
        return this.serverVersion.mariaDb;
      }
      /**
       * Parse raw info to set server major/minor/patch values
       * @param info
       */
      static parseVersionString(info) {
        let car;
        let offset = 0;
        let type = 0;
        let val = 0;
        for (; offset < info.serverVersion.raw.length; offset++) {
          car = info.serverVersion.raw.charCodeAt(offset);
          if (car < 48 || car > 57) {
            switch (type) {
              case 0:
                info.serverVersion.major = val;
                break;
              case 1:
                info.serverVersion.minor = val;
                break;
              case 2:
                info.serverVersion.patch = val;
                return;
            }
            type++;
            val = 0;
          } else {
            val = val * 10 + car - 48;
          }
        }
        if (type === 2) info.serverVersion.patch = val;
      }
    };
    _redirectFct = /* @__PURE__ */ new WeakMap();
    module2.exports = ConnectionInformation;
  }
});
var require_capabilities = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/const/capabilities.js"(exports, module2) {
    "use strict";
    module2.exports.MYSQL = 1n;
    module2.exports.FOUND_ROWS = 2n;
    module2.exports.LONG_FLAG = 4n;
    module2.exports.CONNECT_WITH_DB = 8n;
    module2.exports.NO_SCHEMA = 1n << 4n;
    module2.exports.COMPRESS = 1n << 5n;
    module2.exports.ODBC = 1n << 6n;
    module2.exports.LOCAL_FILES = 1n << 7n;
    module2.exports.IGNORE_SPACE = 1n << 8n;
    module2.exports.PROTOCOL_41 = 1n << 9n;
    module2.exports.INTERACTIVE = 1n << 10n;
    module2.exports.SSL = 1n << 11n;
    module2.exports.IGNORE_SIGPIPE = 1n << 12n;
    module2.exports.TRANSACTIONS = 1n << 13n;
    module2.exports.RESERVED = 1n << 14n;
    module2.exports.SECURE_CONNECTION = 1n << 15n;
    module2.exports.MULTI_STATEMENTS = 1n << 16n;
    module2.exports.MULTI_RESULTS = 1n << 17n;
    module2.exports.PS_MULTI_RESULTS = 1n << 18n;
    module2.exports.PLUGIN_AUTH = 1n << 19n;
    module2.exports.CONNECT_ATTRS = 1n << 20n;
    module2.exports.PLUGIN_AUTH_LENENC_CLIENT_DATA = 1n << 21n;
    module2.exports.CAN_HANDLE_EXPIRED_PASSWORDS = 1n << 22n;
    module2.exports.SESSION_TRACK = 1n << 23n;
    module2.exports.DEPRECATE_EOF = 1n << 24n;
    module2.exports.SSL_VERIFY_SERVER_CERT = 1n << 30n;
    module2.exports.MARIADB_CLIENT_STMT_BULK_OPERATIONS = 1n << 34n;
    module2.exports.MARIADB_CLIENT_EXTENDED_TYPE_INFO = 1n << 35n;
    module2.exports.MARIADB_CLIENT_CACHE_METADATA = 1n << 36n;
  }
});
var require_connection_options = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/config/connection-options.js"(exports, module2) {
    "use strict";
    var Collations = require_collations();
    var urlFormat = /mariadb:\/\/(([^/@:]+)?(:([^/]+))?@)?(([^/:]+)(:([0-9]+))?)\/([^?]+)(\?(.*))?$/;
    var ConnectionOptions = class _ConnectionOptions {
      constructor(opts) {
        if (typeof opts === "string") {
          opts = _ConnectionOptions.parse(opts);
        }
        if (!opts) opts = {};
        this.host = opts.host || "localhost";
        this.port = opts.port || 3306;
        this.keepEof = opts.keepEof || false;
        this.user = opts.user || process.env.USERNAME;
        this.password = opts.password;
        this.database = opts.database;
        this.stream = opts.stream;
        this.debug = opts.debug || false;
        this.debugCompress = opts.debugCompress || false;
        this.debugLen = opts.debugLen || 256;
        this.logParam = opts.logParam === void 0 ? true : opts.logParam === true;
        if (opts.logger) {
          if (typeof opts.logger === "function") {
            this.logger = {
              network: opts.logger,
              query: opts.logger,
              error: opts.logger,
              warning: opts.logger
            };
          } else {
            this.logger = {
              network: opts.logger.network,
              query: opts.logger.query,
              error: opts.logger.error,
              warning: opts.logger.warning || console.log
            };
            if (opts.logger.logParam !== void 0) this.logParam = opts.logger.logParam;
          }
        } else {
          this.logger = {
            network: this.debug || this.debugCompress ? console.log : null,
            query: null,
            error: null,
            warning: console.log
          };
        }
        this.debug = !!this.logger.network;
        if (opts.charset && typeof opts.charset === "string") {
          this.collation = Collations.fromCharset(opts.charset.toLowerCase());
          if (this.collation === void 0) {
            this.collation = Collations.fromName(opts.charset.toUpperCase());
            if (this.collation !== void 0) {
              this.logger.warning(
                "warning: please use option 'collation' in replacement of 'charset' when using a collation name ('" + opts.charset + "')\n(collation looks like 'UTF8MB4_UNICODE_CI', charset like 'utf8')."
              );
            } else {
              this.charset = opts.charset;
            }
          }
        } else if (opts.collation && typeof opts.collation === "string") {
          this.collation = Collations.fromName(opts.collation.toUpperCase());
          if (this.collation === void 0) throw new RangeError("Unknown collation '" + opts.collation + "'");
        } else {
          this.collation = opts.charsetNumber ? Collations.fromIndex(opts.charsetNumber) : void 0;
        }
        this.permitRedirect = opts.permitRedirect === void 0 ? true : opts.permitRedirect;
        this.initSql = opts.initSql;
        this.connectTimeout = opts.connectTimeout === void 0 ? 1e3 : opts.connectTimeout;
        this.connectAttributes = opts.connectAttributes || false;
        this.compress = opts.compress || false;
        this.rsaPublicKey = opts.rsaPublicKey;
        this.cachingRsaPublicKey = opts.cachingRsaPublicKey;
        this.allowPublicKeyRetrieval = opts.allowPublicKeyRetrieval || false;
        this.forceVersionCheck = opts.forceVersionCheck || false;
        this.maxAllowedPacket = opts.maxAllowedPacket;
        this.permitConnectionWhenExpired = opts.permitConnectionWhenExpired || false;
        this.pipelining = opts.pipelining;
        this.timezone = opts.timezone || "local";
        this.socketPath = opts.socketPath;
        this.sessionVariables = opts.sessionVariables;
        this.infileStreamFactory = opts.infileStreamFactory;
        this.ssl = opts.ssl;
        if (opts.ssl) {
          if (typeof opts.ssl !== "boolean" && typeof opts.ssl !== "string") {
            this.ssl.rejectUnauthorized = opts.ssl.rejectUnauthorized !== false;
          }
        }
        this.queryTimeout = opts.queryTimeout === void 0 ? 0 : opts.queryTimeout;
        this.socketTimeout = opts.socketTimeout === void 0 ? 0 : opts.socketTimeout;
        this.keepAliveDelay = opts.keepAliveDelay === void 0 ? 0 : opts.keepAliveDelay;
        this.trace = opts.trace || false;
        this.checkDuplicate = opts.checkDuplicate === void 0 ? true : opts.checkDuplicate;
        this.dateStrings = opts.dateStrings || false;
        this.foundRows = opts.foundRows === void 0 || opts.foundRows;
        this.metaAsArray = opts.metaAsArray || false;
        this.metaEnumerable = opts.metaEnumerable || false;
        this.multipleStatements = opts.multipleStatements || false;
        this.namedPlaceholders = opts.namedPlaceholders || false;
        this.nestTables = opts.nestTables;
        this.autoJsonMap = opts.autoJsonMap === void 0 ? true : opts.autoJsonMap;
        this.bitOneIsBoolean = opts.bitOneIsBoolean === void 0 ? true : opts.bitOneIsBoolean;
        this.arrayParenthesis = opts.arrayParenthesis || false;
        this.permitSetMultiParamEntries = opts.permitSetMultiParamEntries || false;
        this.rowsAsArray = opts.rowsAsArray || false;
        this.typeCast = opts.typeCast;
        if (this.typeCast !== void 0 && typeof this.typeCast !== "function") {
          this.typeCast = void 0;
        }
        this.bulk = opts.bulk === void 0 || opts.bulk;
        this.checkNumberRange = opts.checkNumberRange || false;
        if (opts.pipelining === void 0) {
          this.permitLocalInfile = opts.permitLocalInfile || false;
          this.pipelining = !this.permitLocalInfile;
        } else {
          this.pipelining = opts.pipelining;
          if (opts.permitLocalInfile === true && this.pipelining) {
            throw new Error(
              "enabling options `permitLocalInfile` and `pipelining` is not possible, options are incompatible."
            );
          }
          this.permitLocalInfile = this.pipelining ? false : opts.permitLocalInfile || false;
        }
        this.prepareCacheLength = opts.prepareCacheLength === void 0 ? 256 : opts.prepareCacheLength;
        this.restrictedAuth = opts.restrictedAuth;
        if (this.restrictedAuth != null) {
          if (!Array.isArray(this.restrictedAuth)) {
            this.restrictedAuth = this.restrictedAuth.split(",");
          }
        }
        this.bigIntAsNumber = opts.bigIntAsNumber || false;
        this.insertIdAsNumber = opts.insertIdAsNumber || false;
        this.decimalAsNumber = opts.decimalAsNumber || false;
        this.supportBigNumbers = opts.supportBigNumbers || false;
        this.bigNumberStrings = opts.bigNumberStrings || false;
        if (this.maxAllowedPacket && !Number.isInteger(this.maxAllowedPacket)) {
          throw new RangeError("maxAllowedPacket must be an integer. was '" + this.maxAllowedPacket + "'");
        }
      }
      /**
       * When parsing from String, correcting type.
       *
       * @param opts options
       * @return {opts}
       */
      static parseOptionDataType(opts) {
        if (opts.bulk) opts.bulk = opts.bulk === "true";
        if (opts.allowPublicKeyRetrieval) opts.allowPublicKeyRetrieval = opts.allowPublicKeyRetrieval === "true";
        if (opts.insertIdAsNumber) opts.insertIdAsNumber = opts.insertIdAsNumber === "true";
        if (opts.decimalAsNumber) opts.decimalAsNumber = opts.decimalAsNumber === "true";
        if (opts.bigIntAsNumber) opts.bigIntAsNumber = opts.bigIntAsNumber === "true";
        if (opts.charsetNumber && !isNaN(Number.parseInt(opts.charsetNumber))) {
          opts.charsetNumber = Number.parseInt(opts.charsetNumber);
        }
        if (opts.permitRedirect) opts.permitRedirect = opts.permitRedirect === "true";
        if (opts.logParam) opts.logParam = opts.logParam === "true";
        if (opts.compress) opts.compress = opts.compress === "true";
        if (opts.connectAttributes) opts.connectAttributes = JSON.parse(opts.connectAttributes);
        if (opts.connectTimeout) opts.connectTimeout = parseInt(opts.connectTimeout);
        if (opts.keepAliveDelay) opts.keepAliveDelay = parseInt(opts.keepAliveDelay);
        if (opts.socketTimeout) opts.socketTimeout = parseInt(opts.socketTimeout);
        if (opts.dateStrings) opts.dateStrings = opts.dateStrings === "true";
        if (opts.debug) opts.debug = opts.debug === "true";
        if (opts.autoJsonMap) opts.autoJsonMap = opts.autoJsonMap === "true";
        if (opts.arrayParenthesis) opts.arrayParenthesis = opts.arrayParenthesis === "true";
        if (opts.checkDuplicate) opts.checkDuplicate = opts.checkDuplicate === "true";
        if (opts.debugCompress) opts.debugCompress = opts.debugCompress === "true";
        if (opts.debugLen) opts.debugLen = parseInt(opts.debugLen);
        if (opts.prepareCacheLength) opts.prepareCacheLength = parseInt(opts.prepareCacheLength);
        if (opts.queryTimeout) opts.queryTimeout = parseInt(opts.queryTimeout);
        if (opts.foundRows) opts.foundRows = opts.foundRows === "true";
        if (opts.maxAllowedPacket && !isNaN(Number.parseInt(opts.maxAllowedPacket)))
          opts.maxAllowedPacket = parseInt(opts.maxAllowedPacket);
        if (opts.metaAsArray) opts.metaAsArray = opts.metaAsArray === "true";
        if (opts.metaEnumerable) opts.metaEnumerable = opts.metaEnumerable === "true";
        if (opts.multipleStatements) opts.multipleStatements = opts.multipleStatements === "true";
        if (opts.namedPlaceholders) opts.namedPlaceholders = opts.namedPlaceholders === "true";
        if (opts.nestTables) opts.nestTables = opts.nestTables === "true";
        if (opts.permitSetMultiParamEntries) opts.permitSetMultiParamEntries = opts.permitSetMultiParamEntries === "true";
        if (opts.pipelining) opts.pipelining = opts.pipelining === "true";
        if (opts.forceVersionCheck) opts.forceVersionCheck = opts.forceVersionCheck === "true";
        if (opts.rowsAsArray) opts.rowsAsArray = opts.rowsAsArray === "true";
        if (opts.trace) opts.trace = opts.trace === "true";
        if (opts.ssl && (opts.ssl === "true" || opts.ssl === "false")) opts.ssl = opts.ssl === "true";
        if (opts.bitOneIsBoolean) opts.bitOneIsBoolean = opts.bitOneIsBoolean === "true";
        return opts;
      }
      static parse(opts) {
        const matchResults = opts.match(urlFormat);
        if (!matchResults) {
          throw new Error(
            `error parsing connection string '${opts}'. format must be 'mariadb://[<user>[:<password>]@]<host>[:<port>]/[<db>[?<opt1>=<value1>[&<opt2>=<value2>]]]'`
          );
        }
        const options = {
          user: matchResults[2] ? decodeURIComponent(matchResults[2]) : void 0,
          password: matchResults[4] ? decodeURIComponent(matchResults[4]) : void 0,
          host: matchResults[6] ? decodeURIComponent(matchResults[6]) : matchResults[6],
          port: matchResults[8] ? parseInt(matchResults[8]) : void 0,
          database: matchResults[9] ? decodeURIComponent(matchResults[9]) : matchResults[9]
        };
        const variousOptsString = matchResults[11];
        if (variousOptsString) {
          const keyValues = variousOptsString.split("&");
          keyValues.forEach(function(keyVal) {
            const equalIdx = keyVal.indexOf("=");
            if (equalIdx !== 1) {
              let val = keyVal.substring(equalIdx + 1);
              val = val ? decodeURIComponent(val) : void 0;
              options[keyVal.substring(0, equalIdx)] = val;
            }
          });
        }
        return this.parseOptionDataType(options);
      }
    };
    module2.exports = ConnectionOptions;
  }
});
var require_command = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/command.js"(exports, module2) {
    "use strict";
    var EventEmitter = (0, import_chunk_WWAWV7DQ.__require)("events");
    var Errors = require_errors();
    var Command = class extends EventEmitter {
      constructor(cmdParam, resolve, reject) {
        super();
        this.cmdParam = cmdParam;
        this.sequenceNo = -1;
        this.compressSequenceNo = -1;
        this.resolve = resolve;
        this.reject = reject;
        this.sending = false;
        this.unexpectedError = this.throwUnexpectedError.bind(this);
      }
      displaySql() {
        return null;
      }
      /**
       * Throw an unexpected error.
       * server exchange will still be read to keep connection in a good state, but promise will be rejected.
       *
       * @param msg message
       * @param fatal is error fatal for connection
       * @param info current server state information
       * @param sqlState error sqlState
       * @param errno error number
       */
      throwUnexpectedError(msg, fatal, info, sqlState, errno) {
        const err = Errors.createError(
          msg,
          errno,
          info,
          sqlState,
          this.opts && this.opts.logParam ? this.displaySql() : this.sql,
          fatal,
          this.cmdParam ? this.cmdParam.stack : null,
          false
        );
        if (this.reject) {
          process.nextTick(this.reject, err);
          this.resolve = null;
          this.reject = null;
        }
        return err;
      }
      /**
       * Create and throw new Error from error information
       * only first called throwing an error or successfully end will be executed.
       *
       * @param msg message
       * @param fatal is error fatal for connection
       * @param info current server state information
       * @param sqlState error sqlState
       * @param errno error number
       */
      throwNewError(msg, fatal, info, sqlState, errno) {
        this.onPacketReceive = null;
        const err = this.throwUnexpectedError(msg, fatal, info, sqlState, errno);
        this.emit("end");
        return err;
      }
      /**
       * When command cannot be sent due to error.
       * (this is only on start command)
       *
       * @param msg error message
       * @param errno error number
       * @param info connection information
       */
      sendCancelled(msg, errno, info) {
        const err = Errors.createError(msg, errno, info, "HY000", this.opts.logParam ? this.displaySql() : this.sql);
        this.emit("send_end");
        this.throwError(err, info);
      }
      /**
       * Throw Error
       *  only first called throwing an error or successfully end will be executed.
       *
       * @param err error to be thrown
       * @param info current server state information
       */
      throwError(err, info) {
        this.onPacketReceive = null;
        if (this.reject) {
          if (this.cmdParam && this.cmdParam.stack) {
            err = Errors.createError(
              err.text ? err.text : err.message,
              err.errno,
              info,
              err.sqlState,
              err.sql,
              err.fatal,
              this.cmdParam.stack,
              false
            );
          }
          this.resolve = null;
          process.nextTick(this.reject, err);
          this.reject = null;
        }
        this.emit("end", err);
      }
      /**
       * Successfully end command.
       * only first called throwing an error or successfully end will be executed.
       *
       * @param val return value.
       */
      successEnd(val) {
        this.onPacketReceive = null;
        if (this.resolve) {
          this.reject = null;
          process.nextTick(this.resolve, val);
          this.resolve = null;
        }
        this.emit("end");
      }
    };
    module2.exports = Command;
  }
});
var require_plugin_auth = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/handshake/auth/plugin-auth.js"(exports, module2) {
    "use strict";
    var Command = require_command();
    var PluginAuth = class extends Command {
      constructor(cmdParam, multiAuthResolver, reject) {
        super(cmdParam, multiAuthResolver, reject);
        this.onPacketReceive = multiAuthResolver;
      }
      permitHash() {
        return true;
      }
      hash(conf) {
        return null;
      }
    };
    module2.exports = PluginAuth;
  }
});
var require_initial_handshake = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/handshake/auth/initial-handshake.js"(exports, module2) {
    "use strict";
    var Capabilities = require_capabilities();
    var Collations = require_collations();
    var ConnectionInformation = require_connection_information();
    var InitialHandshake = class {
      constructor(packet, info) {
        packet.skip(1);
        info.serverVersion = {};
        info.serverVersion.raw = packet.readStringNullEnded();
        info.threadId = packet.readUInt32();
        let seed1 = packet.readBuffer(8);
        packet.skip(1);
        let serverCapabilities = BigInt(packet.readUInt16());
        info.collation = Collations.fromIndex(packet.readUInt8());
        info.status = packet.readUInt16();
        serverCapabilities += BigInt(packet.readUInt16()) << 16n;
        let saltLength = 0;
        if (serverCapabilities & Capabilities.PLUGIN_AUTH) {
          saltLength = Math.max(12, packet.readUInt8() - 9);
        } else {
          packet.skip(1);
        }
        if (serverCapabilities & Capabilities.MYSQL) {
          packet.skip(10);
        } else {
          packet.skip(6);
          serverCapabilities += BigInt(packet.readUInt32()) << 32n;
        }
        if (serverCapabilities & Capabilities.SECURE_CONNECTION) {
          let seed2 = packet.readBuffer(saltLength);
          info.seed = Buffer.concat([seed1, seed2]);
        } else {
          info.seed = seed1;
        }
        packet.skip(1);
        info.serverCapabilities = serverCapabilities;
        if (info.serverVersion.raw.startsWith("5.5.5-")) {
          info.serverVersion.mariaDb = true;
          info.serverVersion.raw = info.serverVersion.raw.substring("5.5.5-".length);
        } else {
          info.serverVersion.mariaDb = info.serverVersion.raw.includes("MariaDB") || (serverCapabilities & Capabilities.MYSQL) === 0n;
        }
        if (serverCapabilities & Capabilities.PLUGIN_AUTH) {
          this.pluginName = packet.readStringNullEnded();
        } else {
          this.pluginName = "";
        }
        ConnectionInformation.parseVersionString(info);
      }
    };
    module2.exports = InitialHandshake;
  }
});
var require_client_capabilities = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/handshake/client-capabilities.js"(exports, module2) {
    "use strict";
    var Capabilities = require_capabilities();
    module2.exports.init = function(opts, info) {
      let capabilities = Capabilities.IGNORE_SPACE | Capabilities.PROTOCOL_41 | Capabilities.TRANSACTIONS | Capabilities.SECURE_CONNECTION | Capabilities.MULTI_RESULTS | Capabilities.PS_MULTI_RESULTS | Capabilities.SESSION_TRACK | Capabilities.CONNECT_ATTRS | Capabilities.PLUGIN_AUTH_LENENC_CLIENT_DATA | Capabilities.MARIADB_CLIENT_EXTENDED_TYPE_INFO | Capabilities.PLUGIN_AUTH;
      if (opts.foundRows) {
        capabilities |= Capabilities.FOUND_ROWS;
      }
      if (opts.permitLocalInfile) {
        capabilities |= Capabilities.LOCAL_FILES;
      }
      if (opts.multipleStatements) {
        capabilities |= Capabilities.MULTI_STATEMENTS;
      }
      info.eofDeprecated = !opts.keepEof && (info.serverCapabilities & Capabilities.DEPRECATE_EOF) > 0;
      if (info.eofDeprecated) {
        capabilities |= Capabilities.DEPRECATE_EOF;
      }
      if (opts.database && info.serverCapabilities & Capabilities.CONNECT_WITH_DB) {
        capabilities |= Capabilities.CONNECT_WITH_DB;
      }
      info.serverPermitSkipMeta = (info.serverCapabilities & Capabilities.MARIADB_CLIENT_CACHE_METADATA) > 0;
      if (info.serverPermitSkipMeta) {
        capabilities |= Capabilities.MARIADB_CLIENT_CACHE_METADATA;
      }
      if (opts.compress) {
        if (info.serverCapabilities & Capabilities.COMPRESS) {
          capabilities |= Capabilities.COMPRESS;
        } else {
          opts.compress = false;
        }
      }
      if (opts.bulk && info.serverCapabilities & Capabilities.MARIADB_CLIENT_STMT_BULK_OPERATIONS) {
        capabilities |= Capabilities.MARIADB_CLIENT_STMT_BULK_OPERATIONS;
      }
      if (opts.permitConnectionWhenExpired) {
        capabilities |= Capabilities.CAN_HANDLE_EXPIRED_PASSWORDS;
      }
      info.clientCapabilities = capabilities & info.serverCapabilities;
    };
  }
});
var require_ssl_request = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/handshake/ssl-request.js"(exports, module2) {
    "use strict";
    var Capabilities = require_capabilities();
    module2.exports.send = function sendSSLRequest(cmd, out, info, opts) {
      out.startPacket(cmd);
      out.writeInt32(Number(info.clientCapabilities & BigInt(4294967295)));
      out.writeInt32(1024 * 1024 * 1024);
      out.writeInt8(opts.collation && opts.collation.index <= 255 ? opts.collation.index : 224);
      for (let i = 0; i < 19; i++) {
        out.writeInt8(0);
      }
      if (info.serverCapabilities & Capabilities.MYSQL) {
        out.writeInt32(0);
      } else {
        out.writeInt32(Number(info.clientCapabilities >> 32n));
      }
      out.flushPacket();
    };
  }
});
var require_native_password_auth = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/handshake/auth/native-password-auth.js"(exports, module2) {
    "use strict";
    var PluginAuth = require_plugin_auth();
    var Crypto = (0, import_chunk_WWAWV7DQ.__require)("crypto");
    var NativePasswordAuth = class _NativePasswordAuth extends PluginAuth {
      constructor(packSeq, compressPackSeq, pluginData, cmdParam, reject, multiAuthResolver) {
        super(cmdParam, multiAuthResolver, reject);
        this.pluginData = pluginData;
        this.sequenceNo = packSeq;
        this.compressSequenceNo = compressPackSeq;
      }
      start(out, opts, info) {
        const data = this.pluginData.slice(0, 20);
        let authToken = _NativePasswordAuth.encryptSha1Password(opts.password, data);
        out.startPacket(this);
        if (authToken.length > 0) {
          out.writeBuffer(authToken, 0, authToken.length);
          out.flushPacket();
        } else {
          out.writeEmptyPacket(true);
        }
        this.emit("send_end");
      }
      static encryptSha1Password(password, seed2) {
        if (!password) return Buffer.alloc(0);
        let hash = Crypto.createHash("sha1");
        let stage1 = hash.update(password, "utf8").digest();
        hash = Crypto.createHash("sha1");
        let stage2 = hash.update(stage1).digest();
        hash = Crypto.createHash("sha1");
        hash.update(seed2);
        hash.update(stage2);
        let digest = hash.digest();
        let returnBytes = Buffer.allocUnsafe(digest.length);
        for (let i = 0; i < digest.length; i++) {
          returnBytes[i] = stage1[i] ^ digest[i];
        }
        return returnBytes;
      }
      permitHash() {
        return true;
      }
      hash(conf) {
        let hash = Crypto.createHash("sha1");
        let stage1 = hash.update(conf.password, "utf8").digest();
        hash = Crypto.createHash("sha1");
        return hash.update(stage1).digest();
      }
    };
    module2.exports = NativePasswordAuth;
  }
});
var require_handshake = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/handshake/auth/handshake.js"(exports, module2) {
    "use strict";
    var PluginAuth = require_plugin_auth();
    var InitialHandshake = require_initial_handshake();
    var ClientCapabilities = require_client_capabilities();
    var Capabilities = require_capabilities();
    var SslRequest = require_ssl_request();
    var Errors = require_errors();
    var NativePasswordAuth = require_native_password_auth();
    var os = (0, import_chunk_WWAWV7DQ.__require)("os");
    var Iconv = (0, import_chunk_LOGAFLCN.require_lib)();
    var Crypto = (0, import_chunk_WWAWV7DQ.__require)("crypto");
    var driverVersion = require_package().version;
    var Handshake = class _Handshake extends PluginAuth {
      constructor(auth, getSocket, multiAuthResolver, reject) {
        super(null, multiAuthResolver, reject);
        this.sequenceNo = 0;
        this.compressSequenceNo = 0;
        this.auth = auth;
        this.getSocket = getSocket;
        this.counter = 0;
        this.onPacketReceive = this.parseHandshakeInit;
      }
      start(out, opts, info) {
      }
      parseHandshakeInit(packet, out, opts, info) {
        if (packet.peek() === 255) {
          const authErr = packet.readError(info);
          authErr.fatal = true;
          return this.throwError(authErr, info);
        }
        let handshake = new InitialHandshake(packet, info);
        ClientCapabilities.init(opts, info);
        this.pluginName = handshake.pluginName;
        if (opts.ssl) {
          if (info.serverCapabilities & Capabilities.SSL) {
            info.clientCapabilities |= Capabilities.SSL;
            SslRequest.send(this, out, info, opts);
            this.auth._createSecureContext(info, () => {
              const secureSocket = this.getSocket();
              info.selfSignedCertificate = !secureSocket.authorized;
              info.tlsAuthorizationError = secureSocket.authorizationError;
              const serverCert = secureSocket.getPeerCertificate(false);
              info.tlsFingerprint = serverCert ? serverCert.fingerprint256.replace(/:/gi, "").toLowerCase() : null;
              _Handshake.send.call(this, this, out, opts, handshake.pluginName, info);
            });
          } else {
            return this.throwNewError(
              "Trying to connect with ssl, but ssl not enabled in the server",
              true,
              info,
              "08S01",
              Errors.ER_SERVER_SSL_DISABLED
            );
          }
        } else {
          _Handshake.send(this, out, opts, handshake.pluginName, info);
        }
        this.onPacketReceive = this.auth.handshakeResult.bind(this.auth);
      }
      permitHash() {
        return this.pluginName !== "mysql_clear_password";
      }
      hash(conf) {
        let hash = Crypto.createHash("sha1");
        let stage1 = hash.update(conf.password, "utf8").digest();
        hash = Crypto.createHash("sha1");
        return hash.update(stage1).digest();
      }
      /**
       * Send Handshake response packet
       * see https://mariadb.com/kb/en/library/1-connecting-connecting/#handshake-response-packet
       *
       * @param cmd         current handshake command
       * @param out         output writer
       * @param opts        connection options
       * @param pluginName  plugin name
       * @param info        connection information
       */
      static send(cmd, out, opts, pluginName, info) {
        out.startPacket(cmd);
        info.defaultPluginName = pluginName;
        const pwd = Array.isArray(opts.password) ? opts.password[0] : opts.password;
        let authToken;
        let authPlugin;
        switch (pluginName) {
          case "mysql_clear_password":
            authToken = Buffer.from(pwd);
            authPlugin = "mysql_clear_password";
            break;
          default:
            authToken = NativePasswordAuth.encryptSha1Password(pwd, info.seed);
            authPlugin = "mysql_native_password";
            break;
        }
        out.writeInt32(Number(info.clientCapabilities & BigInt(4294967295)));
        out.writeInt32(1024 * 1024 * 1024);
        out.writeInt8(opts.collation && opts.collation.index <= 255 ? opts.collation.index : 224);
        for (let i = 0; i < 19; i++) {
          out.writeInt8(0);
        }
        out.writeInt32(Number(info.clientCapabilities >> 32n));
        out.writeString(opts.user || "");
        out.writeInt8(0);
        if (info.serverCapabilities & Capabilities.PLUGIN_AUTH_LENENC_CLIENT_DATA) {
          out.writeLengthCoded(authToken.length);
          out.writeBuffer(authToken, 0, authToken.length);
        } else if (info.serverCapabilities & Capabilities.SECURE_CONNECTION) {
          out.writeInt8(authToken.length);
          out.writeBuffer(authToken, 0, authToken.length);
        } else {
          out.writeBuffer(authToken, 0, authToken.length);
          out.writeInt8(0);
        }
        if (info.clientCapabilities & Capabilities.CONNECT_WITH_DB) {
          out.writeString(opts.database);
          out.writeInt8(0);
          info.database = opts.database;
        }
        if (info.clientCapabilities & Capabilities.PLUGIN_AUTH) {
          out.writeString(authPlugin);
          out.writeInt8(0);
        }
        if (info.clientCapabilities & Capabilities.CONNECT_ATTRS) {
          out.writeInt8(252);
          let initPos = out.pos;
          out.writeInt16(0);
          const encoding = info.collation ? info.collation.charset : "utf8";
          _Handshake.writeAttribute(out, "_client_name", encoding);
          _Handshake.writeAttribute(out, "MariaDB connector/Node", encoding);
          _Handshake.writeAttribute(out, "_client_version", encoding);
          _Handshake.writeAttribute(out, driverVersion, encoding);
          const address = cmd.getSocket().address().address;
          if (address) {
            _Handshake.writeAttribute(out, "_server_host", encoding);
            _Handshake.writeAttribute(out, address, encoding);
          }
          _Handshake.writeAttribute(out, "_os", encoding);
          _Handshake.writeAttribute(out, process.platform, encoding);
          _Handshake.writeAttribute(out, "_client_host", encoding);
          _Handshake.writeAttribute(out, os.hostname(), encoding);
          _Handshake.writeAttribute(out, "_node_version", encoding);
          _Handshake.writeAttribute(out, process.versions.node, encoding);
          if (opts.connectAttributes !== true) {
            let attrNames = Object.keys(opts.connectAttributes);
            for (let k = 0; k < attrNames.length; ++k) {
              _Handshake.writeAttribute(out, attrNames[k], encoding);
              _Handshake.writeAttribute(out, opts.connectAttributes[attrNames[k]], encoding);
            }
          }
          out.writeInt16AtPos(initPos);
        }
        out.flushPacket();
      }
      static writeAttribute(out, val, encoding) {
        let param = Buffer.isEncoding(encoding) ? Buffer.from(val, encoding) : Iconv.encode(val, encoding);
        out.writeLengthCoded(param.length);
        out.writeBuffer(param, 0, param.length);
      }
    };
    module2.exports = Handshake;
  }
});
var require_state_change = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/const/state-change.js"(exports, module2) {
    "use strict";
    module2.exports.SESSION_TRACK_SYSTEM_VARIABLES = 0;
    module2.exports.SESSION_TRACK_SCHEMA = 1;
    module2.exports.SESSION_TRACK_STATE_CHANGE = 2;
    module2.exports.SESSION_TRACK_GTIDS = 3;
    module2.exports.SESSION_TRACK_TRANSACTION_CHARACTERISTICS = 4;
    module2.exports.SESSION_TRACK_TRANSACTION_STATE = 5;
  }
});
var require_clear_password_auth = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/handshake/auth/clear-password-auth.js"(exports, module2) {
    "use strict";
    var PluginAuth = require_plugin_auth();
    var ClearPasswordAuth = class extends PluginAuth {
      constructor(packSeq, compressPackSeq, pluginData, cmdParam, reject, multiAuthResolver) {
        super(cmdParam, multiAuthResolver, reject);
        this.sequenceNo = packSeq;
        this.compressSequenceNo = compressPackSeq;
        this.counter = 0;
        this.multiAuthResolver = multiAuthResolver;
      }
      start(out, opts, info) {
        out.startPacket(this);
        const pwd = opts.password;
        if (pwd) {
          if (Array.isArray(pwd)) {
            out.writeString(pwd[this.counter++]);
          } else {
            out.writeString(pwd);
          }
        }
        out.writeInt8(0);
        out.flushPacket();
        this.onPacketReceive = this.response;
      }
      response(packet, out, opts, info) {
        const marker = packet.peek();
        switch (marker) {
          case 0:
          case 255:
            this.emit("send_end");
            return this.multiAuthResolver(packet, out, opts, info);
          default:
            packet.readBuffer();
            out.startPacket(this);
            out.writeString("password");
            out.writeInt8(0);
            out.flushPacket();
        }
      }
    };
    module2.exports = ClearPasswordAuth;
  }
});
var require_ed25519_password_auth = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/handshake/auth/ed25519-password-auth.js"(exports, module2) {
    "use strict";
    var PluginAuth = require_plugin_auth();
    var Crypto = (0, import_chunk_WWAWV7DQ.__require)("crypto");
    var Ed25519PasswordAuth = class _Ed25519PasswordAuth extends PluginAuth {
      constructor(packSeq, compressPackSeq, pluginData, cmdParam, reject, multiAuthResolver) {
        super(cmdParam, multiAuthResolver, reject);
        this.pluginData = pluginData;
        this.sequenceNo = packSeq;
        this.compressSequenceNo = compressPackSeq;
      }
      start(out, opts, info) {
        const data = this.pluginData;
        const sign = _Ed25519PasswordAuth.encryptPassword(opts.password, data);
        out.startPacket(this);
        out.writeBuffer(sign, 0, sign.length);
        out.flushPacket();
        this.emit("send_end");
      }
      static encryptPassword(password, seed2) {
        if (!password) return Buffer.alloc(0);
        let i, j;
        let p = [gf(), gf(), gf(), gf()];
        const signedMsg = Buffer.alloc(96);
        const bytePwd = Buffer.from(password);
        let hash = Crypto.createHash("sha512");
        const d = hash.update(bytePwd).digest();
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        for (i = 0; i < 32; i++) signedMsg[64 + i] = seed2[i];
        for (i = 0; i < 32; i++) signedMsg[32 + i] = d[32 + i];
        hash = Crypto.createHash("sha512");
        const r = hash.update(signedMsg.subarray(32, 96)).digest();
        reduce(r);
        scalarbase(p, r);
        pack(signedMsg, p);
        p = [gf(), gf(), gf(), gf()];
        scalarbase(p, d);
        const tt = Buffer.alloc(32);
        pack(tt, p);
        for (i = 32; i < 64; i++) signedMsg[i] = tt[i - 32];
        hash = Crypto.createHash("sha512");
        const h = hash.update(signedMsg).digest();
        reduce(h);
        const x = new Float64Array(64);
        for (i = 0; i < 64; i++) x[i] = 0;
        for (i = 0; i < 32; i++) x[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(signedMsg.subarray(32), x);
        return signedMsg.subarray(0, 64);
      }
      permitHash() {
        return true;
      }
      hash(conf) {
        let i;
        let p = [gf(), gf(), gf(), gf()];
        const signedMsg = Buffer.alloc(96);
        const bytePwd = Buffer.from(conf.password);
        let hash = Crypto.createHash("sha512");
        const d = hash.update(bytePwd).digest();
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        for (i = 0; i < 32; i++) signedMsg[64 + i] = seed[i];
        for (i = 0; i < 32; i++) signedMsg[32 + i] = d[32 + i];
        hash = Crypto.createHash("sha512");
        const r = hash.update(signedMsg.subarray(32, 96)).digest();
        reduce(r);
        scalarbase(p, r);
        return r;
      }
    };
    var gf = function(init) {
      const r = new Float64Array(16);
      if (init) for (let i = 0; i < init.length; i++) r[i] = init[i];
      return r;
    };
    var gf0 = gf();
    var gf1 = gf([1]);
    var D2 = gf([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X = gf([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y = gf([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var L = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    function reduce(r) {
      const x = new Float64Array(64);
      let i;
      for (i = 0; i < 64; i++) x[i] = r[i];
      for (i = 0; i < 64; i++) r[i] = 0;
      modL(r, x);
    }
    function modL(r, x) {
      let carry, i, j, k;
      for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k = i - 12; j < k; ++j) {
          x[j] += carry - 16 * x[i] * L[j - (i - 32)];
          carry = x[j] + 128 >> 8;
          x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
      }
      carry = 0;
      for (j = 0; j < 32; j++) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }
      for (j = 0; j < 32; j++) x[j] -= carry * L[j];
      for (i = 0; i < 32; i++) {
        x[i + 1] += x[i] >> 8;
        r[i] = x[i] & 255;
      }
    }
    function scalarbase(p, s) {
      const q = [gf(), gf(), gf(), gf()];
      set25519(q[0], X);
      set25519(q[1], Y);
      set25519(q[2], gf1);
      M(q[3], X, Y);
      scalarmult(p, q, s);
    }
    function set25519(r, a) {
      for (let i = 0; i < 16; i++) r[i] = a[i] | 0;
    }
    function M(o, a, b) {
      let v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0;
      const b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function scalarmult(p, q, s) {
      let b, i;
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);
      for (i = 255; i >= 0; --i) {
        b = s[i / 8 | 0] >> (i & 7) & 1;
        cswap(p, q, b);
        add(q, p);
        add(p, p);
        cswap(p, q, b);
      }
    }
    function pack(r, p) {
      const tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p[2]);
      M(tx, p[0], zi);
      M(ty, p[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }
    function inv25519(o, i) {
      const c = gf();
      let a;
      for (a = 0; a < 16; a++) c[a] = i[a];
      for (a = 253; a >= 0; a--) {
        S(c, c);
        if (a !== 2 && a !== 4) M(c, c, i);
      }
      for (a = 0; a < 16; a++) o[a] = c[a];
    }
    function S(o, a) {
      M(o, a, a);
    }
    function par25519(a) {
      const d = new Uint8Array(32);
      pack25519(d, a);
      return d[0] & 1;
    }
    function car25519(o) {
      let i, v, c = 1;
      for (i = 0; i < 16; i++) {
        v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    function pack25519(o, n) {
      let i, j, b;
      const m = gf(), t = gf();
      for (i = 0; i < 16; i++) t[i] = n[i];
      car25519(t);
      car25519(t);
      car25519(t);
      for (j = 0; j < 2; j++) {
        m[0] = t[0] - 65517;
        for (i = 1; i < 15; i++) {
          m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
          m[i - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
        b = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b);
      }
      for (i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 255;
        o[2 * i + 1] = t[i] >> 8;
      }
    }
    function cswap(p, q, b) {
      for (let i = 0; i < 4; i++) {
        sel25519(p[i], q[i], b);
      }
    }
    function A(o, a, b) {
      for (let i = 0; i < 16; i++) o[i] = a[i] + b[i];
    }
    function Z(o, a, b) {
      for (let i = 0; i < 16; i++) o[i] = a[i] - b[i];
    }
    function add(p, q) {
      const a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
      Z(a, p[1], p[0]);
      Z(t, q[1], q[0]);
      M(a, a, t);
      A(b, p[0], p[1]);
      A(t, q[0], q[1]);
      M(b, b, t);
      M(c, p[3], q[3]);
      M(c, c, D2);
      M(d, p[2], q[2]);
      A(d, d, d);
      Z(e, b, a);
      Z(f, d, c);
      A(g, d, c);
      A(h, b, a);
      M(p[0], e, f);
      M(p[1], h, g);
      M(p[2], g, f);
      M(p[3], e, h);
    }
    function sel25519(p, q, b) {
      const c = ~(b - 1);
      let t;
      for (let i = 0; i < 16; i++) {
        t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
      }
    }
    module2.exports = Ed25519PasswordAuth;
  }
});
var require_pam_password_auth = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/handshake/auth/pam-password-auth.js"(exports, module2) {
    "use strict";
    var PluginAuth = require_plugin_auth();
    var PamPasswordAuth = class extends PluginAuth {
      constructor(packSeq, compressPackSeq, pluginData, cmdParam, reject, multiAuthResolver) {
        super(cmdParam, multiAuthResolver, reject);
        this.pluginData = pluginData;
        this.sequenceNo = packSeq;
        this.compressSequenceNo = compressPackSeq;
        this.counter = 0;
        this.multiAuthResolver = multiAuthResolver;
      }
      start(out, opts, info) {
        this.exchange(this.pluginData, out, opts, info);
        this.onPacketReceive = this.response;
      }
      exchange(buffer, out, opts, info) {
        out.startPacket(this);
        let pwd;
        if (Array.isArray(opts.password)) {
          pwd = opts.password[this.counter];
          this.counter++;
        } else {
          pwd = opts.password;
        }
        if (pwd) out.writeString(pwd);
        out.writeInt8(0);
        out.flushPacket();
      }
      response(packet, out, opts, info) {
        const marker = packet.peek();
        switch (marker) {
          case 0:
          case 255:
            this.emit("send_end");
            return this.multiAuthResolver(packet, out, opts, info);
          default:
            let promptData = packet.readBuffer();
            this.exchange(promptData, out, opts, info);
            this.onPacketReceive = this.response;
        }
      }
    };
    module2.exports = PamPasswordAuth;
  }
});
var require_sha256_password_auth = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/handshake/auth/sha256-password-auth.js"(exports, module2) {
    "use strict";
    var PluginAuth = require_plugin_auth();
    var fs2 = (0, import_chunk_WWAWV7DQ.__require)("fs");
    var crypto = (0, import_chunk_WWAWV7DQ.__require)("crypto");
    var Errors = require_errors();
    var Crypto = (0, import_chunk_WWAWV7DQ.__require)("crypto");
    var Sha256PasswordAuth = class _Sha256PasswordAuth extends PluginAuth {
      constructor(packSeq, compressPackSeq, pluginData, cmdParam, reject, multiAuthResolver) {
        super(cmdParam, multiAuthResolver, reject);
        this.pluginData = pluginData;
        this.sequenceNo = packSeq;
        this.compressSequenceNo = compressPackSeq;
        this.counter = 0;
        this.counter = 0;
        this.initialState = true;
        this.multiAuthResolver = multiAuthResolver;
      }
      start(out, opts, info) {
        this.exchange(this.pluginData, out, opts, info);
        this.onPacketReceive = this.response;
      }
      exchange(buffer, out, opts, info) {
        if (this.initialState) {
          if (!opts.password) {
            out.startPacket(this);
            out.writeEmptyPacket(true);
            return;
          } else if (opts.ssl) {
            out.startPacket(this);
            if (opts.password) {
              out.writeString(opts.password);
            }
            out.writeInt8(0);
            out.flushPacket();
            return;
          } else {
            if (opts.rsaPublicKey) {
              try {
                let key = opts.rsaPublicKey;
                if (!key.includes("-----BEGIN")) {
                  key = fs2.readFileSync(key, "utf8");
                }
                this.publicKey = _Sha256PasswordAuth.retrievePublicKey(key);
              } catch (err) {
                return this.throwError(err, info);
              }
            } else {
              if (!opts.allowPublicKeyRetrieval) {
                return this.throwError(
                  Errors.createFatalError(
                    "RSA public key is not available client side. Either set option `rsaPublicKey` to indicate public key path, or allow public key retrieval with option `allowPublicKeyRetrieval`",
                    Errors.ER_CANNOT_RETRIEVE_RSA_KEY,
                    info
                  ),
                  info
                );
              }
              this.initialState = false;
              out.startPacket(this);
              out.writeInt8(1);
              out.flushPacket();
              return;
            }
          }
          _Sha256PasswordAuth.sendSha256PwdPacket(this, this.pluginData, this.publicKey, opts.password, out);
        } else {
          this.publicKey = _Sha256PasswordAuth.retrievePublicKey(buffer.toString("utf8", 1));
          _Sha256PasswordAuth.sendSha256PwdPacket(this, this.pluginData, this.publicKey, opts.password, out);
        }
      }
      static retrievePublicKey(key) {
        return key.replace("(-+BEGIN PUBLIC KEY-+\\r?\\n|\\n?-+END PUBLIC KEY-+\\r?\\n?)", "");
      }
      static sendSha256PwdPacket(cmd, pluginData, publicKey, password, out) {
        const truncatedSeed = pluginData.slice(0, pluginData.length - 1);
        out.startPacket(cmd);
        const enc = _Sha256PasswordAuth.encrypt(truncatedSeed, password, publicKey);
        out.writeBuffer(enc, 0, enc.length);
        out.flushPacket();
      }
      static encryptSha256Password(password, seed2) {
        if (!password) return Buffer.alloc(0);
        let hash = Crypto.createHash("sha256");
        let stage1 = hash.update(password, "utf8").digest();
        hash = Crypto.createHash("sha256");
        let stage2 = hash.update(stage1).digest();
        hash = Crypto.createHash("sha256");
        hash.update(stage2);
        hash.update(seed2);
        let digest = hash.digest();
        let returnBytes = Buffer.allocUnsafe(digest.length);
        for (let i = 0; i < digest.length; i++) {
          returnBytes[i] = stage1[i] ^ digest[i];
        }
        return returnBytes;
      }
      // encrypt password with public key
      static encrypt(seed2, password, publicKey) {
        const nullFinishedPwd = Buffer.from(password + "\0");
        const xorBytes = Buffer.allocUnsafe(nullFinishedPwd.length);
        const seedLength = seed2.length;
        for (let i = 0; i < xorBytes.length; i++) {
          xorBytes[i] = nullFinishedPwd[i] ^ seed2[i % seedLength];
        }
        return crypto.publicEncrypt({ key: publicKey, padding: crypto.constants.RSA_PKCS1_OAEP_PADDING }, xorBytes);
      }
      response(packet, out, opts, info) {
        const marker = packet.peek();
        switch (marker) {
          case 0:
          case 255:
            this.emit("send_end");
            return this.multiAuthResolver(packet, out, opts, info);
          default:
            let promptData = packet.readBufferRemaining();
            this.exchange(promptData, out, opts, info);
            this.onPacketReceive = this.response;
        }
      }
    };
    module2.exports = Sha256PasswordAuth;
  }
});
var require_caching_sha2_password_auth = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/handshake/auth/caching-sha2-password-auth.js"(exports, module2) {
    "use strict";
    var PluginAuth = require_plugin_auth();
    var fs2 = (0, import_chunk_WWAWV7DQ.__require)("fs");
    var Errors = require_errors();
    var Sha256PasswordAuth = require_sha256_password_auth();
    var State = {
      INIT: "INIT",
      FAST_AUTH_RESULT: "FAST_AUTH_RESULT",
      REQUEST_SERVER_KEY: "REQUEST_SERVER_KEY",
      SEND_AUTH: "SEND_AUTH"
    };
    var CachingSha2PasswordAuth = class extends PluginAuth {
      constructor(packSeq, compressPackSeq, pluginData, cmdParam, reject, multiAuthResolver) {
        super(cmdParam, multiAuthResolver, reject);
        this.multiAuthResolver = multiAuthResolver;
        this.pluginData = pluginData;
        this.sequenceNo = packSeq;
        this.compressSequenceNo = compressPackSeq;
        this.counter = 0;
        this.state = State.INIT;
      }
      start(out, opts, info) {
        this.exchange(this.pluginData, out, opts, info);
        this.onPacketReceive = this.response;
      }
      exchange(packet, out, opts, info) {
        switch (this.state) {
          case State.INIT:
            const truncatedSeed = this.pluginData.slice(0, this.pluginData.length - 1);
            const encPwd = Sha256PasswordAuth.encryptSha256Password(opts.password, truncatedSeed);
            out.startPacket(this);
            if (encPwd.length > 0) {
              out.writeBuffer(encPwd, 0, encPwd.length);
              out.flushPacket();
            } else {
              out.writeEmptyPacket(true);
            }
            this.state = State.FAST_AUTH_RESULT;
            return;
          case State.FAST_AUTH_RESULT:
            const fastAuthResult = packet[1];
            switch (fastAuthResult) {
              case 3:
                return;
              case 4:
                if (opts.ssl) {
                  out.startPacket(this);
                  out.writeString(opts.password);
                  out.writeInt8(0);
                  out.flushPacket();
                  return;
                }
                if (opts.cachingRsaPublicKey) {
                  try {
                    let key = opts.cachingRsaPublicKey;
                    if (!key.includes("-----BEGIN")) {
                      key = fs2.readFileSync(key, "utf8");
                    }
                    this.publicKey = Sha256PasswordAuth.retrievePublicKey(key);
                  } catch (err) {
                    return this.throwError(err, info);
                  }
                  Sha256PasswordAuth.sendSha256PwdPacket(this, this.pluginData, this.publicKey, opts.password, out);
                } else {
                  if (!opts.allowPublicKeyRetrieval) {
                    return this.throwError(
                      Errors.createFatalError(
                        "RSA public key is not available client side. Either set option `cachingRsaPublicKey` to indicate public key path, or allow public key retrieval with option `allowPublicKeyRetrieval`",
                        Errors.ER_CANNOT_RETRIEVE_RSA_KEY,
                        info
                      ),
                      info
                    );
                  }
                  this.state = State.REQUEST_SERVER_KEY;
                  out.startPacket(this);
                  out.writeInt8(2);
                  out.flushPacket();
                }
            }
            return;
          case State.REQUEST_SERVER_KEY:
            this.publicKey = Sha256PasswordAuth.retrievePublicKey(packet.toString(void 0, 1));
            this.state = State.SEND_AUTH;
            Sha256PasswordAuth.sendSha256PwdPacket(this, this.pluginData, this.publicKey, opts.password, out);
            return;
        }
      }
      response(packet, out, opts, info) {
        const marker = packet.peek();
        switch (marker) {
          case 0:
          case 255:
            this.emit("send_end");
            return this.multiAuthResolver(packet, out, opts, info);
          default:
            let promptData = packet.readBufferRemaining();
            this.exchange(promptData, out, opts, info);
            this.onPacketReceive = this.response;
        }
      }
    };
    module2.exports = CachingSha2PasswordAuth;
  }
});
var require_authentication = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/handshake/authentication.js"(exports, module2) {
    "use strict";
    var Command = require_command();
    var Errors = require_errors();
    var Capabilities = require_capabilities();
    var Handshake = require_handshake();
    var ServerStatus = require_server_status();
    var StateChange = require_state_change();
    var Collations = require_collations();
    var Crypto = (0, import_chunk_WWAWV7DQ.__require)("crypto");
    var utils = require_utils();
    var authenticationPlugins = {
      mysql_native_password: require_native_password_auth(),
      mysql_clear_password: require_clear_password_auth(),
      client_ed25519: require_ed25519_password_auth(),
      dialog: require_pam_password_auth(),
      sha256_password: require_sha256_password_auth(),
      caching_sha2_password: require_caching_sha2_password_auth()
    };
    var Authentication = class _Authentication extends Command {
      constructor(cmdParam, resolve, reject, _createSecureContext, getSocket) {
        super(cmdParam, resolve, reject);
        this.cmdParam = cmdParam;
        this._createSecureContext = _createSecureContext;
        this.getSocket = getSocket;
        this.plugin = new Handshake(this, getSocket, this.handshakeResult, reject);
      }
      onPacketReceive(packet, out, opts, info) {
        this.plugin.sequenceNo = this.sequenceNo;
        this.plugin.compressSequenceNo = this.compressSequenceNo;
        this.plugin.onPacketReceive(packet, out, opts, info);
      }
      /**
       * Fast-path handshake results :
       *  - if plugin was the one expected by server, server will send OK_Packet / ERR_Packet.
       *  - if not, server send an AuthSwitchRequest packet, indicating the specific PLUGIN to use with this user.
       *    dispatching to plugin handler then.
       *
       * @param packet    current packet
       * @param out       output buffer
       * @param opts      options
       * @param info      connection info
       * @returns {*}     return null if authentication succeed, depending on plugin conversation if not finished
       */
      handshakeResult(packet, out, opts, info) {
        const marker = packet.peek();
        switch (marker) {
          case 254:
            this.dispatchAuthSwitchRequest(packet, out, opts, info);
            return;
          case 0:
            this.plugin.onPacketReceive = null;
            packet.skip(1);
            packet.skipLengthCodedNumber();
            packet.skipLengthCodedNumber();
            info.status = packet.readUInt16();
            if (info.requireValidCert && info.selfSignedCertificate) {
              packet.skip(2);
              if (packet.remaining()) {
                const validationHash = packet.readBufferLengthEncoded();
                if (validationHash.length > 0) {
                  if (!this.plugin.permitHash() || !this.cmdParam.opts.password || this.cmdParam.opts.password === "") {
                    return this.throwNewError(
                      "Self signed certificates. Either set `ssl: { rejectUnauthorized: false }` (trust mode) or provide server certificate to client",
                      true,
                      info,
                      "08000",
                      Errors.ER_SELF_SIGNED_NO_PWD
                    );
                  }
                  if (this.validateFingerPrint(validationHash, info)) {
                    return this.successEnd();
                  }
                }
              }
              return this.throwNewError("self-signed certificate", true, info, "08000", Errors.ER_SELF_SIGNED);
            }
            let mustRedirect = false;
            if (info.status & ServerStatus.SESSION_STATE_CHANGED) {
              packet.skip(2);
              packet.skipLengthCodedNumber();
              while (packet.remaining()) {
                const len = packet.readUnsignedLength();
                if (len > 0) {
                  const subPacket = packet.subPacketLengthEncoded(len);
                  while (subPacket.remaining()) {
                    const type = subPacket.readUInt8();
                    switch (type) {
                      case StateChange.SESSION_TRACK_SYSTEM_VARIABLES:
                        let subSubPacket;
                        do {
                          subSubPacket = subPacket.subPacketLengthEncoded(subPacket.readUnsignedLength());
                          const variable = subSubPacket.readStringLengthEncoded();
                          const value = subSubPacket.readStringLengthEncoded();
                          switch (variable) {
                            case "character_set_client":
                              info.collation = Collations.fromCharset(value);
                              if (info.collation === void 0) {
                                this.throwError(new Error("unknown charset : '" + value + "'"), info);
                                return;
                              }
                              opts.emit("collation", info.collation);
                              break;
                            case "redirect_url":
                              if (value !== "") {
                                mustRedirect = true;
                                info.redirect(value, this.successEnd);
                              }
                              break;
                            case "maxscale":
                              info.maxscaleVersion = value;
                              break;
                            case "connection_id":
                              info.threadId = parseInt(value);
                              break;
                            default:
                          }
                        } while (subSubPacket.remaining() > 0);
                        break;
                      case StateChange.SESSION_TRACK_SCHEMA:
                        const subSubPacket2 = subPacket.subPacketLengthEncoded(subPacket.readUnsignedLength());
                        info.database = subSubPacket2.readStringLengthEncoded();
                        break;
                    }
                  }
                }
              }
            }
            if (!mustRedirect) this.successEnd();
            return;
          case 255:
            this.plugin.onPacketReceive = null;
            const authErr = packet.readError(info, this.displaySql(), void 0);
            authErr.fatal = true;
            return this.plugin.throwError(authErr, info);
          default:
            this.throwNewError(
              `Unexpected type of packet during handshake phase : ${marker}`,
              true,
              info,
              "42000",
              Errors.ER_AUTHENTICATION_BAD_PACKET
            );
        }
      }
      validateFingerPrint(validationHash, info) {
        if (validationHash.length === 0 || !info.tlsFingerprint) return false;
        if (validationHash[0] !== 1) {
          const err = Errors.createFatalError(
            `Unexpected hash format for fingerprint hash encoding`,
            Errors.ER_UNEXPECTED_PACKET,
            this.info
          );
          if (this.opts.logger.error) this.opts.logger.error(err);
          return false;
        }
        const pwdHash = this.plugin.hash(this.cmdParam.opts);
        let hash = Crypto.createHash("sha256");
        let digest = hash.update(pwdHash).update(info.seed).update(Buffer.from(info.tlsFingerprint, "hex")).digest();
        const hashHex = utils.toHexString(digest);
        const serverValidationHex = validationHash.toString("ascii", 1, validationHash.length).toLowerCase();
        return hashHex === serverValidationHex;
      }
      /**
       * Handle authentication switch request : dispatch to plugin handler.
       *
       * @param packet  packet
       * @param out     output writer
       * @param opts    options
       * @param info    connection information
       */
      dispatchAuthSwitchRequest(packet, out, opts, info) {
        let pluginName, pluginData;
        if (info.clientCapabilities & Capabilities.PLUGIN_AUTH) {
          packet.skip(1);
          if (packet.remaining()) {
            pluginName = packet.readStringNullEnded();
            pluginData = packet.readBufferRemaining();
          } else {
            pluginName = "mysql_old_password";
            pluginData = info.seed.subarray(0, 8);
          }
        } else {
          pluginName = packet.readStringNullEnded("ascii");
          pluginData = packet.readBufferRemaining();
        }
        if (opts.restrictedAuth && !opts.restrictedAuth.includes(pluginName)) {
          this.throwNewError(
            `Unsupported authentication plugin ${pluginName}. Authorized plugin: ${opts.restrictedAuth.toString()}`,
            true,
            info,
            "42000",
            Errors.ER_NOT_SUPPORTED_AUTH_PLUGIN
          );
          return;
        }
        try {
          this.plugin.emit("end");
          this.plugin.onPacketReceive = null;
          this.plugin = _Authentication.pluginHandler(
            pluginName,
            this.plugin.sequenceNo,
            this.plugin.compressSequenceNo,
            pluginData,
            info,
            opts,
            out,
            this.cmdParam,
            this.reject,
            this.handshakeResult.bind(this)
          );
          this.plugin.start(out, opts, info);
        } catch (err) {
          this.reject(err);
        }
      }
      static pluginHandler(pluginName, packSeq, compressPackSeq, pluginData, info, opts, out, cmdParam, authReject, multiAuthResolver) {
        let pluginAuth = authenticationPlugins[pluginName];
        if (!pluginAuth) {
          throw Errors.createFatalError(
            `Client does not support authentication protocol '${pluginName}' requested by server.`,
            Errors.ER_AUTHENTICATION_PLUGIN_NOT_SUPPORTED,
            info,
            "08004"
          );
        }
        return new pluginAuth(packSeq, compressPackSeq, pluginData, cmdParam, authReject, multiAuthResolver);
      }
    };
    module2.exports = Authentication;
  }
});
var require_quit = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/quit.js"(exports, module2) {
    "use strict";
    var Command = require_command();
    var QUIT_COMMAND = new Uint8Array([1, 0, 0, 0, 1]);
    var Quit = class extends Command {
      constructor(cmdParam, resolve, reject) {
        super(cmdParam, resolve, reject);
      }
      start(out, opts, info) {
        if (opts.logger.query) opts.logger.query("QUIT");
        this.onPacketReceive = this.skipResults;
        out.fastFlush(this, QUIT_COMMAND);
        this.emit("send_end");
        this.successEnd();
      }
      skipResults(packet, out, opts, info) {
      }
    };
    module2.exports = Quit;
  }
});
var require_ping = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/ping.js"(exports, module2) {
    "use strict";
    var Command = require_command();
    var ServerStatus = require_server_status();
    var PING_COMMAND = new Uint8Array([1, 0, 0, 0, 14]);
    var Ping = class extends Command {
      constructor(cmdParam, resolve, reject) {
        super(cmdParam, resolve, reject);
      }
      start(out, opts, info) {
        if (opts.logger.query) opts.logger.query("PING");
        this.onPacketReceive = this.readPingResponsePacket;
        out.fastFlush(this, PING_COMMAND);
        this.emit("send_end");
      }
      /**
       * Read ping response packet.
       * packet can be :
       * - an ERR_Packet
       * - an OK_Packet
       *
       * @param packet  query response
       * @param out     output writer
       * @param opts    connection options
       * @param info    connection info
       */
      readPingResponsePacket(packet, out, opts, info) {
        packet.skip(1);
        packet.skipLengthCodedNumber();
        packet.skipLengthCodedNumber();
        info.status = packet.readUInt16();
        if (info.redirectRequest && (info.status & ServerStatus.STATUS_IN_TRANS) === 0) {
          info.redirect(info.redirectRequest, this.successEnd.bind(this, null));
        } else {
          this.successEnd(null);
        }
      }
    };
    module2.exports = Ping;
  }
});
var require_reset = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/reset.js"(exports, module2) {
    "use strict";
    var Command = require_command();
    var ServerStatus = require_server_status();
    var RESET_COMMAND = new Uint8Array([1, 0, 0, 0, 31]);
    var Reset = class extends Command {
      constructor(cmdParam, resolve, reject) {
        super(cmdParam, resolve, reject);
      }
      start(out, opts, info) {
        if (opts.logger.query) opts.logger.query("RESET");
        this.onPacketReceive = this.readResetResponsePacket;
        out.fastFlush(this, RESET_COMMAND);
        this.emit("send_end");
      }
      /**
       * Read response packet.
       * packet can be :
       * - an ERR_Packet
       * - a OK_Packet
       *
       * @param packet  query response
       * @param out     output writer
       * @param opts    connection options
       * @param info    connection info
       */
      readResetResponsePacket(packet, out, opts, info) {
        packet.skip(1);
        packet.skipLengthCodedNumber();
        packet.skipLengthCodedNumber();
        info.status = packet.readUInt16();
        if (info.redirectRequest && (info.status & ServerStatus.STATUS_IN_TRANS) === 0) {
          info.redirect(info.redirectRequest, this.successEnd.bind(this));
        } else {
          this.successEnd();
        }
      }
    };
    module2.exports = Reset;
  }
});
var require_field_type = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/const/field-type.js"(exports, module2) {
    "use strict";
    module2.exports.DECIMAL = 0;
    module2.exports.TINY = 1;
    module2.exports.SHORT = 2;
    module2.exports.INT = 3;
    module2.exports.FLOAT = 4;
    module2.exports.DOUBLE = 5;
    module2.exports.NULL = 6;
    module2.exports.TIMESTAMP = 7;
    module2.exports.BIGINT = 8;
    module2.exports.INT24 = 9;
    module2.exports.DATE = 10;
    module2.exports.TIME = 11;
    module2.exports.DATETIME = 12;
    module2.exports.YEAR = 13;
    module2.exports.NEWDATE = 14;
    module2.exports.VARCHAR = 15;
    module2.exports.BIT = 16;
    module2.exports.TIMESTAMP2 = 17;
    module2.exports.DATETIME2 = 18;
    module2.exports.TIME2 = 19;
    module2.exports.JSON = 245;
    module2.exports.NEWDECIMAL = 246;
    module2.exports.ENUM = 247;
    module2.exports.SET = 248;
    module2.exports.TINY_BLOB = 249;
    module2.exports.MEDIUM_BLOB = 250;
    module2.exports.LONG_BLOB = 251;
    module2.exports.BLOB = 252;
    module2.exports.VAR_STRING = 253;
    module2.exports.STRING = 254;
    module2.exports.GEOMETRY = 255;
    var typeNames = [];
    typeNames[0] = "DECIMAL";
    typeNames[1] = "TINY";
    typeNames[2] = "SHORT";
    typeNames[3] = "INT";
    typeNames[4] = "FLOAT";
    typeNames[5] = "DOUBLE";
    typeNames[6] = "NULL";
    typeNames[7] = "TIMESTAMP";
    typeNames[8] = "BIGINT";
    typeNames[9] = "INT24";
    typeNames[10] = "DATE";
    typeNames[11] = "TIME";
    typeNames[12] = "DATETIME";
    typeNames[13] = "YEAR";
    typeNames[14] = "NEWDATE";
    typeNames[15] = "VARCHAR";
    typeNames[16] = "BIT";
    typeNames[17] = "TIMESTAMP2";
    typeNames[18] = "DATETIME2";
    typeNames[19] = "TIME2";
    typeNames[245] = "JSON";
    typeNames[246] = "NEWDECIMAL";
    typeNames[247] = "ENUM";
    typeNames[248] = "SET";
    typeNames[249] = "TINY_BLOB";
    typeNames[250] = "MEDIUM_BLOB";
    typeNames[251] = "LONG_BLOB";
    typeNames[252] = "BLOB";
    typeNames[253] = "VAR_STRING";
    typeNames[254] = "STRING";
    typeNames[255] = "GEOMETRY";
    module2.exports.TYPES = typeNames;
  }
});
var require_field_detail = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/const/field-detail.js"(exports, module2) {
    "use strict";
    module2.exports.NOT_NULL = 1;
    module2.exports.PRIMARY_KEY = 2;
    module2.exports.UNIQUE_KEY = 4;
    module2.exports.MULTIPLE_KEY = 8;
    module2.exports.BLOB = 1 << 4;
    module2.exports.UNSIGNED = 1 << 5;
    module2.exports.ZEROFILL_FLAG = 1 << 6;
    module2.exports.BINARY_COLLATION = 1 << 7;
    module2.exports.ENUM = 1 << 8;
    module2.exports.AUTO_INCREMENT = 1 << 9;
    module2.exports.TIMESTAMP = 1 << 10;
    module2.exports.SET = 1 << 11;
    module2.exports.NO_DEFAULT_VALUE_FLAG = 1 << 12;
    module2.exports.ON_UPDATE_NOW_FLAG = 1 << 13;
    module2.exports.NUM_FLAG = 1 << 14;
  }
});
var require_column_definition = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/column-definition.js"(exports, module2) {
    "use strict";
    var Collations = require_collations();
    var FieldType = require_field_type();
    var FieldDetails = require_field_detail();
    var Capabilities = require_capabilities();
    var _stringParser;
    var ColumnDef = class {
      constructor(packet, info, skipName) {
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _stringParser);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _stringParser, skipName ? new StringParser(packet) : new StringParserWithName(packet));
        if (info.clientCapabilities & Capabilities.MARIADB_CLIENT_EXTENDED_TYPE_INFO) {
          const len = packet.readUnsignedLength();
          if (len > 0) {
            const subPacket = packet.subPacketLengthEncoded(len);
            while (subPacket.remaining()) {
              switch (subPacket.readUInt8()) {
                case 0:
                  this.dataTypeName = subPacket.readAsciiStringLengthEncoded();
                  break;
                case 1:
                  this.dataTypeFormat = subPacket.readAsciiStringLengthEncoded();
                  break;
                default:
                  subPacket.skip(subPacket.readUnsignedLength());
                  break;
              }
            }
          }
        }
        packet.skip(1);
        this.collation = Collations.fromIndex(packet.readUInt16());
        this.columnLength = packet.readUInt32();
        this.columnType = packet.readUInt8();
        this.flags = packet.readUInt16();
        this.scale = packet.readUInt8();
        this.type = FieldType.TYPES[this.columnType];
      }
      __getDefaultGeomVal() {
        if (this.dataTypeName) {
          switch (this.dataTypeName) {
            case "point":
              return { type: "Point" };
            case "linestring":
              return { type: "LineString" };
            case "polygon":
              return { type: "Polygon" };
            case "multipoint":
              return { type: "MultiPoint" };
            case "multilinestring":
              return { type: "MultiLineString" };
            case "multipolygon":
              return { type: "MultiPolygon" };
            default:
              return { type: this.dataTypeName };
          }
        }
        return null;
      }
      db() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _stringParser).db();
      }
      schema() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _stringParser).schema();
      }
      table() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _stringParser).table();
      }
      orgTable() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _stringParser).orgTable();
      }
      name() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _stringParser).name();
      }
      orgName() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _stringParser).orgName();
      }
      signed() {
        return (this.flags & FieldDetails.UNSIGNED) === 0;
      }
      isSet() {
        return (this.flags & FieldDetails.SET) !== 0;
      }
    };
    _stringParser = /* @__PURE__ */ new WeakMap();
    var BaseStringParser = class {
      constructor(encoding, readFct, saveBuf, initialPos) {
        this.buf = saveBuf;
        this.encoding = encoding;
        this.readString = readFct;
        this.initialPos = initialPos;
      }
      _readIdentifier(skip) {
        let pos = this.initialPos;
        while (skip-- > 0) {
          const type2 = this.buf[pos++];
          pos += type2 < 251 ? type2 : 2 + this.buf[pos] + this.buf[pos + 1] * 2 ** 8;
        }
        let len;
        const type = this.buf[pos++];
        len = type < 251 ? type : this.buf[pos++] + this.buf[pos++] * 2 ** 8;
        return this.readString(this.encoding, this.buf, pos, len);
      }
      name() {
        return this._readIdentifier(3);
      }
      db() {
        return this._readIdentifier(0);
      }
      schema() {
        return this.db();
      }
      table() {
        return this._readIdentifier(1);
      }
      orgTable() {
        return this._readIdentifier(2);
      }
      orgName() {
        return this._readIdentifier(4);
      }
    };
    var StringParser = class extends BaseStringParser {
      constructor(packet) {
        packet.skip(packet.readMetadataLength());
        const initPos = packet.pos;
        packet.skip(packet.readMetadataLength());
        packet.skip(packet.readMetadataLength());
        packet.skip(packet.readMetadataLength());
        packet.skip(packet.readMetadataLength());
        packet.skip(packet.readMetadataLength());
        super(packet.encoding, packet.constructor.readString, packet.buf, initPos);
      }
    };
    var StringParserWithName = class extends BaseStringParser {
      constructor(packet) {
        packet.skip(packet.readMetadataLength());
        const initPos = packet.pos;
        packet.skip(packet.readMetadataLength());
        packet.skip(packet.readMetadataLength());
        packet.skip(packet.readMetadataLength());
        const colName = packet.readStringLengthEncoded();
        packet.skip(packet.readMetadataLength());
        super(packet.encoding, packet.constructor.readString, packet.buf, initPos);
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "colName");
        this.colName = colName;
      }
      name() {
        return this.colName;
      }
    };
    module2.exports = ColumnDef;
  }
});
var require_parse = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/misc/parse.js"(exports, module2) {
    "use strict";
    var Errors = require_errors();
    var State = {
      Normal: 1,
      String: 2,
      SlashStarComment: 3,
      Escape: 4,
      EOLComment: 5,
      Backtick: 6,
      Placeholder: 7
      /* found placeholder */
    };
    var SLASH_BYTE = "/".charCodeAt(0);
    var STAR_BYTE = "*".charCodeAt(0);
    var BACKSLASH_BYTE = "\\".charCodeAt(0);
    var HASH_BYTE = "#".charCodeAt(0);
    var MINUS_BYTE = "-".charCodeAt(0);
    var LINE_FEED_BYTE = "\n".charCodeAt(0);
    var DBL_QUOTE_BYTE = '"'.charCodeAt(0);
    var QUOTE_BYTE = "'".charCodeAt(0);
    var RADICAL_BYTE = "`".charCodeAt(0);
    var QUESTION_MARK_BYTE = "?".charCodeAt(0);
    var COLON_BYTE = ":".charCodeAt(0);
    var SEMICOLON_BYTE = ";".charCodeAt(0);
    module2.exports.splitQuery = function(query) {
      let paramPositions = [];
      let state = State.Normal;
      let lastChar = 0;
      let singleQuotes = false;
      const len = query.length;
      for (let i = 0; i < len; i++) {
        if (state === State.Escape && !(query[i] === QUOTE_BYTE && singleQuotes || query[i] === DBL_QUOTE_BYTE && !singleQuotes)) {
          state = State.String;
          lastChar = query[i];
          continue;
        }
        switch (query[i]) {
          case STAR_BYTE:
            if (state === State.Normal && lastChar === SLASH_BYTE) {
              state = State.SlashStarComment;
            }
            break;
          case SLASH_BYTE:
            if (state === State.SlashStarComment && lastChar === STAR_BYTE) {
              state = State.Normal;
            } else if (state === State.Normal && lastChar === SLASH_BYTE) {
              state = State.EOLComment;
            }
            break;
          case HASH_BYTE:
            if (state === State.Normal) {
              state = State.EOLComment;
            }
            break;
          case MINUS_BYTE:
            if (state === State.Normal && lastChar === MINUS_BYTE) {
              state = State.EOLComment;
            }
            break;
          case LINE_FEED_BYTE:
            if (state === State.EOLComment) {
              state = State.Normal;
            }
            break;
          case DBL_QUOTE_BYTE:
            if (state === State.Normal) {
              state = State.String;
              singleQuotes = false;
            } else if (state === State.String && !singleQuotes) {
              state = State.Normal;
            } else if (state === State.Escape) {
              state = State.String;
            }
            break;
          case QUOTE_BYTE:
            if (state === State.Normal) {
              state = State.String;
              singleQuotes = true;
            } else if (state === State.String && singleQuotes) {
              state = State.Normal;
            } else if (state === State.Escape) {
              state = State.String;
            }
            break;
          case BACKSLASH_BYTE:
            if (state === State.String) {
              state = State.Escape;
            }
            break;
          case QUESTION_MARK_BYTE:
            if (state === State.Normal) {
              paramPositions.push(i, ++i);
            }
            break;
          case RADICAL_BYTE:
            if (state === State.Backtick) {
              state = State.Normal;
            } else if (state === State.Normal) {
              state = State.Backtick;
            }
            break;
        }
        lastChar = query[i];
      }
      return paramPositions;
    };
    module2.exports.splitQueryPlaceholder = function(query, info, initialValues, displaySql) {
      let paramPositions = [];
      let values = [];
      let state = State.Normal;
      let lastChar = 0;
      let singleQuotes = false;
      let car;
      const len = query.length;
      for (let i = 0; i < len; i++) {
        car = query[i];
        if (state === State.Escape && !(car === QUOTE_BYTE && singleQuotes || car === DBL_QUOTE_BYTE && !singleQuotes)) {
          state = State.String;
          lastChar = car;
          continue;
        }
        switch (car) {
          case STAR_BYTE:
            if (state === State.Normal && lastChar === SLASH_BYTE) {
              state = State.SlashStarComment;
            }
            break;
          case SLASH_BYTE:
            if (state === State.SlashStarComment && lastChar === STAR_BYTE) {
              state = State.Normal;
            } else if (state === State.Normal && lastChar === SLASH_BYTE) {
              state = State.EOLComment;
            }
            break;
          case HASH_BYTE:
            if (state === State.Normal) {
              state = State.EOLComment;
            }
            break;
          case MINUS_BYTE:
            if (state === State.Normal && lastChar === MINUS_BYTE) {
              state = State.EOLComment;
            }
            break;
          case LINE_FEED_BYTE:
            if (state === State.EOLComment) {
              state = State.Normal;
            }
            break;
          case DBL_QUOTE_BYTE:
            if (state === State.Normal) {
              state = State.String;
              singleQuotes = false;
            } else if (state === State.String && !singleQuotes) {
              state = State.Normal;
            } else if (state === State.Escape) {
              state = State.String;
            }
            break;
          case QUOTE_BYTE:
            if (state === State.Normal) {
              state = State.String;
              singleQuotes = true;
            } else if (state === State.String && singleQuotes) {
              state = State.Normal;
            } else if (state === State.Escape) {
              state = State.String;
            }
            break;
          case BACKSLASH_BYTE:
            if (state === State.String) {
              state = State.Escape;
            }
            break;
          case QUESTION_MARK_BYTE:
            if (state === State.Normal) {
              paramPositions.push(i);
              paramPositions.push(++i);
            }
            break;
          case COLON_BYTE:
            if (state === State.Normal) {
              let j = 1;
              while (i + j < len && query[i + j] >= "0".charCodeAt(0) && query[i + j] <= "9".charCodeAt(0) || query[i + j] >= "A".charCodeAt(0) && query[i + j] <= "Z".charCodeAt(0) || query[i + j] >= "a".charCodeAt(0) && query[i + j] <= "z".charCodeAt(0) || query[i + j] === "-".charCodeAt(0) || query[i + j] === "_".charCodeAt(0)) {
                j++;
              }
              paramPositions.push(i, i + j);
              const placeholderName = query.toString("utf8", i + 1, i + j);
              i += j;
              const val = initialValues[placeholderName];
              if (val === void 0) {
                throw Errors.createError(
                  `Placeholder '${placeholderName}' is not defined`,
                  Errors.ER_PLACEHOLDER_UNDEFINED,
                  info,
                  "HY000",
                  displaySql.call()
                );
              }
              values.push(val);
            }
            break;
          case RADICAL_BYTE:
            if (state === State.Backtick) {
              state = State.Normal;
            } else if (state === State.Normal) {
              state = State.Backtick;
            }
            break;
        }
        lastChar = car;
      }
      return { paramPositions, values };
    };
    module2.exports.searchPlaceholder = function(sql) {
      let sqlPlaceHolder = "";
      let placeHolderIndex = [];
      let state = State.Normal;
      let lastChar = "\0";
      let singleQuotes = false;
      let lastParameterPosition = 0;
      let idx = 0;
      let car = sql.charAt(idx++);
      let placeholderName;
      while (car !== "") {
        if (state === State.Escape && !(car === "'" && singleQuotes || car === '"' && !singleQuotes)) {
          state = State.String;
          lastChar = car;
          car = sql.charAt(idx++);
          continue;
        }
        switch (car) {
          case "*":
            if (state === State.Normal && lastChar === "/") state = State.SlashStarComment;
            break;
          case "/":
            if (state === State.SlashStarComment && lastChar === "*") state = State.Normal;
            break;
          case "#":
            if (state === State.Normal) state = State.EOLComment;
            break;
          case "-":
            if (state === State.Normal && lastChar === "-") {
              state = State.EOLComment;
            }
            break;
          case "\n":
            if (state === State.EOLComment) {
              state = State.Normal;
            }
            break;
          case '"':
            if (state === State.Normal) {
              state = State.String;
              singleQuotes = false;
            } else if (state === State.String && !singleQuotes) {
              state = State.Normal;
            } else if (state === State.Escape && !singleQuotes) {
              state = State.String;
            }
            break;
          case "'":
            if (state === State.Normal) {
              state = State.String;
              singleQuotes = true;
            } else if (state === State.String && singleQuotes) {
              state = State.Normal;
              singleQuotes = false;
            } else if (state === State.Escape && singleQuotes) {
              state = State.String;
            }
            break;
          case "\\":
            if (state === State.String) state = State.Escape;
            break;
          case ":":
            if (state === State.Normal) {
              sqlPlaceHolder += sql.substring(lastParameterPosition, idx - 1) + "?";
              placeholderName = "";
              while ((car = sql.charAt(idx++)) !== "" && car >= "0" && car <= "9" || car >= "A" && car <= "Z" || car >= "a" && car <= "z" || car === "-" || car === "_") {
                placeholderName += car;
              }
              idx--;
              placeHolderIndex.push(placeholderName);
              lastParameterPosition = idx;
            }
            break;
          case "`":
            if (state === State.Backtick) {
              state = State.Normal;
            } else if (state === State.Normal) {
              state = State.Backtick;
            }
        }
        lastChar = car;
        car = sql.charAt(idx++);
      }
      if (lastParameterPosition === 0) {
        sqlPlaceHolder = sql;
      } else {
        sqlPlaceHolder += sql.substring(lastParameterPosition);
      }
      return { sql: sqlPlaceHolder, placeHolderIndex };
    };
    module2.exports.validateFileName = function(sql, parameters, fileName) {
      let queryValidator = new RegExp(
        "^(\\s*\\/\\*([^\\*]|\\*[^\\/])*\\*\\/)*\\s*LOAD\\s+DATA\\s+((LOW_PRIORITY|CONCURRENT)\\s+)?LOCAL\\s+INFILE\\s+'" + fileName.replace(/\\/g, "\\\\\\\\").replace(".", "\\.") + "'",
        "i"
      );
      if (queryValidator.test(sql)) return true;
      if (parameters != null) {
        queryValidator = new RegExp(
          "^(\\s*\\/\\*([^\\*]|\\*[^\\/])*\\*\\/)*\\s*LOAD\\s+DATA\\s+((LOW_PRIORITY|CONCURRENT)\\s+)?LOCAL\\s+INFILE\\s+\\?",
          "i"
        );
        if (queryValidator.test(sql) && parameters.length > 0) {
          if (Array.isArray(parameters)) {
            return parameters[0].toLowerCase() === fileName.toLowerCase();
          }
          return parameters.toLowerCase() === fileName.toLowerCase();
        }
      }
      return false;
    };
    module2.exports.parseQueries = function(bufState) {
      let state = State.Normal;
      let lastChar = 0;
      let currByte;
      let queries = [];
      let singleQuotes = false;
      for (let i = bufState.offset; i < bufState.end; i++) {
        currByte = bufState.buffer[i];
        if (state === State.Escape && !(currByte === QUOTE_BYTE && singleQuotes || currByte === DBL_QUOTE_BYTE && !singleQuotes)) {
          state = State.String;
          lastChar = currByte;
          continue;
        }
        switch (currByte) {
          case STAR_BYTE:
            if (state === State.Normal && lastChar === SLASH_BYTE) {
              state = State.SlashStarComment;
            }
            break;
          case SLASH_BYTE:
            if (state === State.SlashStarComment && lastChar === STAR_BYTE) {
              state = State.Normal;
            } else if (state === State.Normal && lastChar === SLASH_BYTE) {
              state = State.EOLComment;
            }
            break;
          case HASH_BYTE:
            if (state === State.Normal) {
              state = State.EOLComment;
            }
            break;
          case MINUS_BYTE:
            if (state === State.Normal && lastChar === MINUS_BYTE) {
              state = State.EOLComment;
            }
            break;
          case LINE_FEED_BYTE:
            if (state === State.EOLComment) {
              state = State.Normal;
            }
            break;
          case DBL_QUOTE_BYTE:
            if (state === State.Normal) {
              state = State.String;
              singleQuotes = false;
            } else if (state === State.String && !singleQuotes) {
              state = State.Normal;
            } else if (state === State.Escape) {
              state = State.String;
            }
            break;
          case QUOTE_BYTE:
            if (state === State.Normal) {
              state = State.String;
              singleQuotes = true;
            } else if (state === State.String && singleQuotes) {
              state = State.Normal;
            } else if (state === State.Escape) {
              state = State.String;
            }
            break;
          case BACKSLASH_BYTE:
            if (state === State.String) {
              state = State.Escape;
            }
            break;
          case SEMICOLON_BYTE:
            if (state === State.Normal) {
              queries.push(bufState.buffer.toString("utf8", bufState.offset, i));
              bufState.offset = i + 1;
            }
            break;
          case RADICAL_BYTE:
            if (state === State.Backtick) {
              state = State.Normal;
            } else if (state === State.Normal) {
              state = State.Backtick;
            }
            break;
        }
        lastChar = currByte;
      }
      return queries;
    };
  }
});
var require_binary_decoder = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/decoder/binary-decoder.js"(exports, module2) {
    "use strict";
    var FieldType = require_field_type();
    var Errors = require_errors();
    module2.exports.newRow = function(packet, columns) {
      packet.skip(1);
      const len = ~~((columns.length + 9) / 8);
      const nullBitMap = new Array(len);
      for (let i = 0; i < len; i++) nullBitMap[i] = packet.readUInt8();
      return nullBitMap;
    };
    module2.exports.castWrapper = function(column, packet, opts, nullBitmap, index) {
      column.string = () => isNullBitmap(index, nullBitmap) ? null : packet.readStringLengthEncoded();
      column.buffer = () => isNullBitmap(index, nullBitmap) ? null : packet.readBufferLengthEncoded();
      column.float = () => isNullBitmap(index, nullBitmap) ? null : packet.readFloat();
      column.tiny = () => isNullBitmap(index, nullBitmap) ? null : column.signed() ? packet.readInt8() : packet.readUInt8();
      column.short = () => isNullBitmap(index, nullBitmap) ? null : column.signed() ? packet.readInt16() : packet.readUInt16();
      column.int = () => isNullBitmap(index, nullBitmap) ? null : packet.readInt32();
      column.long = () => isNullBitmap(index, nullBitmap) ? null : packet.readBigInt64();
      column.decimal = () => isNullBitmap(index, nullBitmap) ? null : packet.readDecimalLengthEncoded();
      column.date = () => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDate(opts);
      column.datetime = () => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDateTime();
      column.geometry = () => {
        let defaultVal = null;
        if (column.dataTypeName) {
          switch (column.dataTypeName) {
            case "point":
              defaultVal = { type: "Point" };
              break;
            case "linestring":
              defaultVal = { type: "LineString" };
              break;
            case "polygon":
              defaultVal = { type: "Polygon" };
              break;
            case "multipoint":
              defaultVal = { type: "MultiPoint" };
              break;
            case "multilinestring":
              defaultVal = { type: "MultiLineString" };
              break;
            case "multipolygon":
              defaultVal = { type: "MultiPolygon" };
              break;
            default:
              defaultVal = { type: column.dataTypeName };
              break;
          }
        }
        if (isNullBitmap(index, nullBitmap)) {
          return defaultVal;
        }
        return packet.readGeometry(defaultVal);
      };
    };
    module2.exports.parser = function(col, opts) {
      const defaultParser = col.signed() ? DEFAULT_SIGNED_PARSER_TYPE[col.columnType] : DEFAULT_UNSIGNED_PARSER_TYPE[col.columnType];
      if (defaultParser) return defaultParser;
      switch (col.columnType) {
        case FieldType.BIGINT:
          if (col.signed()) {
            return opts.bigIntAsNumber || opts.supportBigNumbers ? readBigintAsIntBinarySigned : readBigintBinarySigned;
          }
          return opts.bigIntAsNumber || opts.supportBigNumbers ? readBigintAsIntBinaryUnsigned : readBigintBinaryUnsigned;
        case FieldType.DATETIME:
        case FieldType.TIMESTAMP:
          return opts.dateStrings ? readTimestampStringBinary.bind(null, col.scale) : readTimestampBinary;
        case FieldType.DECIMAL:
        case FieldType.NEWDECIMAL:
          return col.scale === 0 ? readDecimalAsIntBinary : readDecimalBinary;
        case FieldType.GEOMETRY:
          let defaultVal = col.__getDefaultGeomVal();
          return readGeometryBinary.bind(null, defaultVal);
        case FieldType.BIT:
          if (col.columnLength === 1 && opts.bitOneIsBoolean) {
            return readBitBinaryBoolean;
          }
          return readBinaryBuffer;
        default:
          if (col.dataTypeFormat && col.dataTypeFormat === "json" && opts.autoJsonMap) {
            return readJsonBinary;
          }
          if (col.collation.index === 63) {
            return readBinaryBuffer;
          }
          if (col.isSet()) {
            return readBinarySet;
          }
          return readStringBinary;
      }
    };
    var isNullBitmap = (index, nullBitmap) => {
      return (nullBitmap[~~((index + 2) / 8)] & 1 << (index + 2) % 8) > 0;
    };
    var readTinyBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readInt8();
    var readTinyBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readUInt8();
    var readShortBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readInt16();
    var readShortBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readUInt16();
    var readMediumBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => {
      if (isNullBitmap(index, nullBitmap)) {
        return null;
      }
      const result = packet.readInt24();
      packet.skip(1);
      return result;
    };
    var readMediumBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => {
      if (isNullBitmap(index, nullBitmap)) {
        return null;
      }
      const result = packet.readUInt24();
      packet.skip(1);
      return result;
    };
    var readIntBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readInt32();
    var readIntBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readUInt32();
    var readFloatBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readFloat();
    var readDoubleBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readDouble();
    var readBigintBinaryUnsigned = function(packet, opts, throwUnexpectedError, nullBitmap, index) {
      if (isNullBitmap(index, nullBitmap)) return null;
      return packet.readBigUInt64();
    };
    var readBigintBinarySigned = function(packet, opts, throwUnexpectedError, nullBitmap, index) {
      if (isNullBitmap(index, nullBitmap)) return null;
      return packet.readBigInt64();
    };
    var readBigintAsIntBinaryUnsigned = function(packet, opts, throwUnexpectedError, nullBitmap, index) {
      if (isNullBitmap(index, nullBitmap)) return null;
      const val = packet.readBigUInt64();
      if (opts.bigIntAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(val))) {
        return throwUnexpectedError(
          `value ${val} can't safely be converted to number`,
          false,
          null,
          "42000",
          Errors.ER_PARSING_PRECISION
        );
      }
      if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(val)))) {
        return val.toString();
      }
      return Number(val);
    };
    var readBigintAsIntBinarySigned = function(packet, opts, throwUnexpectedError, nullBitmap, index) {
      if (isNullBitmap(index, nullBitmap)) return null;
      const val = packet.readBigInt64();
      if (opts.bigIntAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(val))) {
        return throwUnexpectedError(
          `value ${val} can't safely be converted to number`,
          false,
          null,
          "42000",
          Errors.ER_PARSING_PRECISION
        );
      }
      if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(val)))) {
        return val.toString();
      }
      return Number(val);
    };
    var readGeometryBinary = (defaultVal, packet, opts, throwUnexpectedError, nullBitmap, index) => {
      if (isNullBitmap(index, nullBitmap)) {
        return defaultVal;
      }
      return packet.readGeometry(defaultVal);
    };
    var readDateBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDate(opts);
    var readTimestampBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDateTime();
    var readTimestampStringBinary = (scale, packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDateTimeAsString(scale);
    var readTimeBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryTime();
    var readDecimalAsIntBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => {
      if (isNullBitmap(index, nullBitmap)) return null;
      const valDec = packet.readDecimalLengthEncoded();
      if (valDec != null && (opts.decimalAsNumber || opts.supportBigNumbers)) {
        if (opts.decimalAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(valDec))) {
          return throwUnexpectedError(
            `value ${valDec} can't safely be converted to number`,
            false,
            null,
            "42000",
            Errors.ER_PARSING_PRECISION
          );
        }
        if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(valDec)))) {
          return valDec;
        }
        return Number(valDec);
      }
      return valDec;
    };
    var readDecimalBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => {
      if (isNullBitmap(index, nullBitmap)) return null;
      const valDec = packet.readDecimalLengthEncoded();
      if (valDec != null && (opts.decimalAsNumber || opts.supportBigNumbers)) {
        const numberValue = Number(valDec);
        if (opts.supportBigNumbers && (opts.bigNumberStrings || Number.isInteger(numberValue) && !Number.isSafeInteger(numberValue))) {
          return valDec;
        }
        return numberValue;
      }
      return valDec;
    };
    var readJsonBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : JSON.parse(packet.readStringLengthEncoded());
    var readBitBinaryBoolean = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBufferLengthEncoded()[0] === 1;
    var readBinaryBuffer = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBufferLengthEncoded();
    var readBinarySet = (packet, opts, throwUnexpectedError, nullBitmap, index) => {
      if (isNullBitmap(index, nullBitmap)) return null;
      const string = packet.readStringLengthEncoded();
      return string == null ? null : string === "" ? [] : string.split(",");
    };
    var readStringBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readStringLengthEncoded();
    var DEFAULT_SIGNED_PARSER_TYPE = Array(256);
    DEFAULT_SIGNED_PARSER_TYPE[FieldType.TINY] = readTinyBinarySigned;
    DEFAULT_SIGNED_PARSER_TYPE[FieldType.YEAR] = readShortBinarySigned;
    DEFAULT_SIGNED_PARSER_TYPE[FieldType.SHORT] = readShortBinarySigned;
    DEFAULT_SIGNED_PARSER_TYPE[FieldType.INT24] = readMediumBinarySigned;
    DEFAULT_SIGNED_PARSER_TYPE[FieldType.INT] = readIntBinarySigned;
    DEFAULT_SIGNED_PARSER_TYPE[FieldType.FLOAT] = readFloatBinary;
    DEFAULT_SIGNED_PARSER_TYPE[FieldType.DOUBLE] = readDoubleBinary;
    DEFAULT_SIGNED_PARSER_TYPE[FieldType.DATE] = readDateBinary;
    DEFAULT_SIGNED_PARSER_TYPE[FieldType.TIME] = readTimeBinary;
    DEFAULT_SIGNED_PARSER_TYPE[FieldType.JSON] = readJsonBinary;
    var DEFAULT_UNSIGNED_PARSER_TYPE = Array(256);
    DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.TINY] = readTinyBinaryUnsigned;
    DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.YEAR] = readShortBinaryUnsigned;
    DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.SHORT] = readShortBinaryUnsigned;
    DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.INT24] = readMediumBinaryUnsigned;
    DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.INT] = readIntBinaryUnsigned;
    DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.FLOAT] = readFloatBinary;
    DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.DOUBLE] = readDoubleBinary;
    DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.DATE] = readDateBinary;
    DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.TIME] = readTimeBinary;
    DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.JSON] = readJsonBinary;
  }
});
var require_text_decoder = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/decoder/text-decoder.js"(exports, module2) {
    "use strict";
    var FieldType = require_field_type();
    var Errors = require_errors();
    module2.exports.parser = function(col, opts) {
      const defaultParser = DEFAULT_PARSER_TYPE[col.columnType];
      if (defaultParser) return defaultParser;
      switch (col.columnType) {
        case FieldType.DECIMAL:
        case FieldType.NEWDECIMAL:
          return col.scale === 0 ? readDecimalAsIntLengthCoded : readDecimalLengthCoded;
        case FieldType.BIGINT:
          if (opts.bigIntAsNumber || opts.supportBigNumbers) return readBigIntAsNumberLengthCoded;
          return readBigIntLengthCoded;
        case FieldType.GEOMETRY:
          let defaultVal = col.__getDefaultGeomVal();
          return readGeometry.bind(null, defaultVal);
        case FieldType.BIT:
          if (col.columnLength === 1 && opts.bitOneIsBoolean) {
            return readBitAsBoolean;
          }
          return readBufferLengthEncoded;
        default:
          if (col.dataTypeFormat && col.dataTypeFormat === "json" && opts.autoJsonMap) {
            return readJson;
          }
          if (col.collation.index === 63) {
            return readBufferLengthEncoded;
          }
          if (col.isSet()) {
            return readSet;
          }
          return readStringLengthEncoded;
      }
    };
    module2.exports.castWrapper = function(column, packet, opts, nullBitmap, index) {
      column.string = () => packet.readStringLengthEncoded();
      column.buffer = () => packet.readBufferLengthEncoded();
      column.float = () => packet.readFloatLengthCoded();
      column.tiny = () => packet.readIntLengthEncoded();
      column.short = () => packet.readIntLengthEncoded();
      column.int = () => packet.readIntLengthEncoded();
      column.long = () => packet.readBigIntLengthEncoded();
      column.decimal = () => packet.readDecimalLengthEncoded();
      column.date = () => packet.readDate(opts);
      column.datetime = () => packet.readDateTime();
      column.geometry = () => {
        let defaultVal = null;
        if (column.dataTypeName) {
          switch (column.dataTypeName) {
            case "point":
              defaultVal = { type: "Point" };
              break;
            case "linestring":
              defaultVal = { type: "LineString" };
              break;
            case "polygon":
              defaultVal = { type: "Polygon" };
              break;
            case "multipoint":
              defaultVal = { type: "MultiPoint" };
              break;
            case "multilinestring":
              defaultVal = { type: "MultiLineString" };
              break;
            case "multipolygon":
              defaultVal = { type: "MultiPolygon" };
              break;
            default:
              defaultVal = { type: column.dataTypeName };
              break;
          }
        }
        return packet.readGeometry(defaultVal);
      };
    };
    var readGeometry = (defaultVal, packet, opts, throwUnexpectedError) => packet.readGeometry(defaultVal);
    var readIntLengthEncoded = (packet, opts, throwUnexpectedError) => packet.readIntLengthEncoded();
    var readStringLengthEncoded = (packet, opts, throwUnexpectedError) => packet.readStringLengthEncoded();
    var readFloatLengthCoded = (packet, opts, throwUnexpectedError) => packet.readFloatLengthCoded();
    var readBigIntLengthCoded = (packet, opts, throwUnexpectedError) => packet.readBigIntLengthEncoded();
    var readBigIntAsNumberLengthCoded = (packet, opts, throwUnexpectedError) => {
      const len = packet.readUnsignedLength();
      if (len === null) return null;
      if (len < 16) {
        const val2 = packet._atoi(len);
        if (opts.supportBigNumbers && opts.bigNumberStrings) {
          return `${val2}`;
        }
        return val2;
      }
      const val = packet.readBigIntFromLen(len);
      if (opts.bigIntAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(val))) {
        return throwUnexpectedError(
          `value ${val} can't safely be converted to number`,
          false,
          null,
          "42000",
          Errors.ER_PARSING_PRECISION
        );
      }
      if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(val)))) {
        return val.toString();
      }
      return Number(val);
    };
    var readDecimalAsIntLengthCoded = (packet, opts, throwUnexpectedError) => {
      const valDec = packet.readDecimalLengthEncoded();
      if (valDec != null && (opts.decimalAsNumber || opts.supportBigNumbers)) {
        if (opts.decimalAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(valDec))) {
          return throwUnexpectedError(
            `value ${valDec} can't safely be converted to number`,
            false,
            null,
            "42000",
            Errors.ER_PARSING_PRECISION
          );
        }
        if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(valDec)))) {
          return valDec;
        }
        return Number(valDec);
      }
      return valDec;
    };
    var readDecimalLengthCoded = (packet, opts, throwUnexpectedError) => {
      const valDec = packet.readDecimalLengthEncoded();
      if (valDec != null && (opts.decimalAsNumber || opts.supportBigNumbers)) {
        const numberValue = Number(valDec);
        if (opts.supportBigNumbers && (opts.bigNumberStrings || Number.isInteger(numberValue) && !Number.isSafeInteger(numberValue))) {
          return valDec;
        }
        return numberValue;
      }
      return valDec;
    };
    var readDate = (packet, opts, throwUnexpectedError) => {
      if (opts.dateStrings) {
        return packet.readAsciiStringLengthEncoded();
      }
      return packet.readDate();
    };
    var readTimestamp = (packet, opts, throwUnexpectedError) => {
      if (opts.dateStrings) {
        return packet.readAsciiStringLengthEncoded();
      }
      return packet.readDateTime();
    };
    var readAsciiStringLengthEncoded = (packet, opts, throwUnexpectedError) => packet.readAsciiStringLengthEncoded();
    var readBitAsBoolean = (packet, opts, throwUnexpectedError) => {
      const val = packet.readBufferLengthEncoded();
      return val == null ? null : val[0] === 1;
    };
    var readBufferLengthEncoded = (packet, opts, throwUnexpectedError) => packet.readBufferLengthEncoded();
    var readJson = (packet, opts, throwUnexpectedError) => JSON.parse(packet.readStringLengthEncoded());
    var readSet = (packet, opts, throwUnexpectedError) => {
      const string = packet.readStringLengthEncoded();
      return string == null ? null : string === "" ? [] : string.split(",");
    };
    var DEFAULT_PARSER_TYPE = Array(256);
    DEFAULT_PARSER_TYPE[FieldType.TINY] = readIntLengthEncoded;
    DEFAULT_PARSER_TYPE[FieldType.SHORT] = readIntLengthEncoded;
    DEFAULT_PARSER_TYPE[FieldType.INT] = readIntLengthEncoded;
    DEFAULT_PARSER_TYPE[FieldType.INT24] = readIntLengthEncoded;
    DEFAULT_PARSER_TYPE[FieldType.YEAR] = readIntLengthEncoded;
    DEFAULT_PARSER_TYPE[FieldType.FLOAT] = readFloatLengthCoded;
    DEFAULT_PARSER_TYPE[FieldType.DOUBLE] = readFloatLengthCoded;
    DEFAULT_PARSER_TYPE[FieldType.DATE] = readDate;
    DEFAULT_PARSER_TYPE[FieldType.DATETIME] = readTimestamp;
    DEFAULT_PARSER_TYPE[FieldType.TIMESTAMP] = readTimestamp;
    DEFAULT_PARSER_TYPE[FieldType.TIME] = readAsciiStringLengthEncoded;
    DEFAULT_PARSER_TYPE[FieldType.JSON] = readJson;
  }
});
var require_ok_packet = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/class/ok-packet.js"(exports, module2) {
    "use strict";
    var OkPacket = class {
      constructor(affectedRows, insertId, warningStatus) {
        this.affectedRows = affectedRows;
        this.insertId = insertId;
        this.warningStatus = warningStatus;
      }
    };
    module2.exports = OkPacket;
  }
});
var require_parser = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/parser.js"(exports, module2) {
    "use strict";
    var Command = require_command();
    var ServerStatus = require_server_status();
    var ColumnDefinition = require_column_definition();
    var Errors = require_errors();
    var fs2 = (0, import_chunk_WWAWV7DQ.__require)("fs");
    var Parse = require_parse();
    var BinaryDecoder = require_binary_decoder();
    var TextDecoder = require_text_decoder();
    var OkPacket = require_ok_packet();
    var StateChange = require_state_change();
    var Collations = require_collations();
    var Parser = class _Parser extends Command {
      constructor(resolve, reject, connOpts, cmdParam) {
        super(cmdParam, resolve, reject);
        this._responseIndex = 0;
        this._rows = [];
        this.opts = cmdParam.opts ? Object.assign({}, connOpts, cmdParam.opts) : connOpts;
        this.sql = cmdParam.sql;
        this.initialValues = cmdParam.values;
        this.canSkipMeta = false;
      }
      /**
       * Read Query response packet.
       * packet can be :
       * - a result-set
       * - an ERR_Packet
       * - a OK_Packet
       * - LOCAL_INFILE Packet
       *
       * @param packet  query response
       * @param out     output writer
       * @param opts    connection options
       * @param info    connection info
       */
      readResponsePacket(packet, out, opts, info) {
        switch (packet.peek()) {
          case 0:
            return this.readOKPacket(packet, out, opts, info);
          case 255:
            this._columns = null;
            this._rows = [];
            const err = packet.readError(info, opts.logParam ? this.displaySql() : this.sql, this.cmdParam.stack);
            info.status |= ServerStatus.STATUS_IN_TRANS;
            return this.throwError(err, info);
          case 251:
            return this.readLocalInfile(packet, out, opts, info);
          default:
            return this.readResultSet(packet, info);
        }
      }
      /**
       * Read result-set packets :
       * see https://mariadb.com/kb/en/library/resultset/
       *
       * @param packet    Column count packet
       * @param info      current connection information
       * @returns {Parser.readColumn} next packet handler
       */
      readResultSet(packet, info) {
        this._columnCount = packet.readUnsignedLength();
        this._rows.push([]);
        if (this.canSkipMeta && info.serverPermitSkipMeta && packet.readUInt8() === 0) {
          this._columns = this.prepare.columns;
          this.emit("fields", this._columns);
          this.setParser();
          return this.onPacketReceive = info.eofDeprecated ? this.readResultSetRow : this.readIntermediateEOF;
        }
        this._columns = [];
        this.onPacketReceive = this.readColumn;
      }
      /**
       * Read OK_Packet.
       * see https://mariadb.com/kb/en/library/ok_packet/
       *
       * @param packet    OK_Packet
       * @param opts      connection options
       * @param info      connection information
       * @param out       output writer
       * @returns {*}     null or {Result.readResponsePacket} in case of multi-result-set
       */
      readOKPacket(packet, out, opts, info) {
        packet.skip(1);
        const affectedRows = packet.readUnsignedLength();
        let insertId = packet.readInsertId();
        info.status = packet.readUInt16();
        if (this.opts.supportBigNumbers || this.opts.insertIdAsNumber) {
          if (this.opts.insertIdAsNumber && this.opts.checkNumberRange && !Number.isSafeInteger(Number(insertId))) {
            this.onPacketReceive = info.status & ServerStatus.MORE_RESULTS_EXISTS ? this.readResponsePacket : null;
            this.throwUnexpectedError(
              `last insert id value ${insertId} can't safely be converted to number`,
              false,
              info,
              "42000",
              Errors.ER_PARSING_PRECISION
            );
            return;
          }
          if (this.opts.supportBigNumbers && (this.opts.bigNumberStrings || !Number.isSafeInteger(Number(insertId)))) {
            insertId = insertId.toString();
          } else insertId = Number(insertId);
        }
        const okPacket = new OkPacket(affectedRows, insertId, packet.readUInt16());
        let mustRedirect = false;
        if (info.status & ServerStatus.SESSION_STATE_CHANGED) {
          packet.skipLengthCodedNumber();
          while (packet.remaining()) {
            const len = packet.readUnsignedLength();
            if (len > 0) {
              const subPacket = packet.subPacketLengthEncoded(len);
              while (subPacket.remaining()) {
                const type = subPacket.readUInt8();
                switch (type) {
                  case StateChange.SESSION_TRACK_SYSTEM_VARIABLES:
                    let subSubPacket;
                    do {
                      subSubPacket = subPacket.subPacketLengthEncoded(subPacket.readUnsignedLength());
                      const variable = subSubPacket.readStringLengthEncoded();
                      const value = subSubPacket.readStringLengthEncoded();
                      switch (variable) {
                        case "character_set_client":
                          info.collation = Collations.fromCharset(value);
                          if (info.collation === void 0) {
                            this.throwError(new Error("unknown charset : '" + value + "'"), info);
                            return;
                          }
                          opts.emit("collation", info.collation);
                          break;
                        case "redirect_url":
                          if (value !== "") {
                            mustRedirect = true;
                            info.redirect(value, this.okPacketSuccess.bind(this, okPacket, info));
                          }
                          break;
                        case "connection_id":
                          info.threadId = parseInt(value);
                          break;
                        default:
                      }
                    } while (subSubPacket.remaining() > 0);
                    break;
                  case StateChange.SESSION_TRACK_SCHEMA:
                    const subSubPacket2 = subPacket.subPacketLengthEncoded(subPacket.readUnsignedLength());
                    info.database = subSubPacket2.readStringLengthEncoded();
                    break;
                }
              }
            }
          }
        }
        if (!mustRedirect) {
          if (info.redirectRequest && (info.status & ServerStatus.STATUS_IN_TRANS) === 0 && (info.status & ServerStatus.MORE_RESULTS_EXISTS) === 0) {
            info.redirect(info.redirectRequest, this.okPacketSuccess.bind(this, okPacket, info));
          } else {
            this.okPacketSuccess(okPacket, info);
          }
        }
      }
      okPacketSuccess(okPacket, info) {
        if (this._responseIndex === 0) {
          if (info.status & ServerStatus.MORE_RESULTS_EXISTS) {
            this._rows.push(okPacket);
            this._responseIndex++;
            return this.onPacketReceive = this.readResponsePacket;
          }
          return this.success(this.opts.metaAsArray ? [okPacket, []] : okPacket);
        }
        this._rows.push(okPacket);
        if (info.status & ServerStatus.MORE_RESULTS_EXISTS) {
          this._responseIndex++;
          return this.onPacketReceive = this.readResponsePacket;
        }
        if (this.opts.metaAsArray) {
          if (!this._meta) {
            this._meta = new Array(this._responseIndex);
          }
          this._meta[this._responseIndex] = null;
          this.success([this._rows, this._meta]);
        } else {
          this.success(this._rows);
        }
      }
      success(val) {
        this.successEnd(val);
        this._columns = null;
        this._rows = [];
      }
      /**
       * Read column information metadata
       * see https://mariadb.com/kb/en/library/resultset/#column-definition-packet
       *
       * @param packet    column definition packet
       * @param out       output writer
       * @param opts      connection options
       * @param info      connection information
       * @returns {*}
       */
      readColumn(packet, out, opts, info) {
        this._columns.push(new ColumnDefinition(packet, info, this.opts.rowsAsArray));
        if (this._columns.length === this._columnCount) {
          this.setParser();
          if (this.canSkipMeta && info.serverPermitSkipMeta && this.prepare != null) {
            this.prepare.columns = this._columns;
          }
          this.emit("fields", this._columns);
          return this.onPacketReceive = info.eofDeprecated ? this.readResultSetRow : this.readIntermediateEOF;
        }
      }
      setParser() {
        this._parseFunction = new Array(this._columnCount);
        if (this.opts.typeCast) {
          for (let i = 0; i < this._columnCount; i++) {
            this._parseFunction[i] = this.readCastValue.bind(this, this._columns[i]);
          }
        } else {
          const dataParser = this.binary ? BinaryDecoder.parser : TextDecoder.parser;
          for (let i = 0; i < this._columnCount; i++) {
            this._parseFunction[i] = dataParser(this._columns[i], this.opts);
          }
        }
        if (this.opts.rowsAsArray) {
          this.parseRow = this.parseRowAsArray;
        } else {
          this.tableHeader = new Array(this._columnCount);
          this.parseRow = this.binary ? this.parseRowStdBinary : this.parseRowStdText;
          if (this.opts.nestTables) {
            if (typeof this.opts.nestTables === "string") {
              for (let i = 0; i < this._columnCount; i++) {
                this.tableHeader[i] = this._columns[i].table() + this.opts.nestTables + this._columns[i].name();
              }
              this.checkDuplicates();
            } else if (this.opts.nestTables === true) {
              this.parseRow = this.parseRowNested;
              for (let i = 0; i < this._columnCount; i++) {
                this.tableHeader[i] = [this._columns[i].table(), this._columns[i].name()];
              }
              this.checkNestTablesDuplicates();
            }
          } else {
            for (let i = 0; i < this._columnCount; i++) {
              this.tableHeader[i] = this._columns[i].name();
            }
            this.checkDuplicates();
          }
        }
      }
      checkDuplicates() {
        if (this.opts.checkDuplicate) {
          for (let i = 0; i < this._columnCount; i++) {
            if (this.tableHeader.indexOf(this.tableHeader[i], i + 1) > 0) {
              const dupes = this.tableHeader.reduce(
                (acc, v, i2, arr) => arr.indexOf(v) !== i2 && acc.indexOf(v) === -1 ? acc.concat(v) : acc,
                []
              );
              this.throwUnexpectedError(
                `Error in results, duplicate field name \`${dupes[0]}\`.
(see option \`checkDuplicate\`)`,
                false,
                null,
                "42000",
                Errors.ER_DUPLICATE_FIELD
              );
            }
          }
        }
      }
      checkNestTablesDuplicates() {
        if (this.opts.checkDuplicate) {
          for (let i = 0; i < this._columnCount; i++) {
            for (let j = 0; j < i; j++) {
              if (this.tableHeader[j][0] === this.tableHeader[i][0] && this.tableHeader[j][1] === this.tableHeader[i][1]) {
                this.throwUnexpectedError(
                  `Error in results, duplicate field name \`${this.tableHeader[i][0]}\`.\`${this.tableHeader[i][1]}\`
(see option \`checkDuplicate\`)`,
                  false,
                  null,
                  "42000",
                  Errors.ER_DUPLICATE_FIELD
                );
              }
            }
          }
        }
      }
      /**
       * Read intermediate EOF.
       * _only for server before MariaDB 10.2 / MySQL 5.7 that doesn't have CLIENT_DEPRECATE_EOF capability_
       * see https://mariadb.com/kb/en/library/eof_packet/
       *
       * @param packet    EOF Packet
       * @param out       output writer
       * @param opts      connection options
       * @param info      connection information
       * @returns {*}
       */
      readIntermediateEOF(packet, out, opts, info) {
        if (packet.peek() !== 254) {
          return this.throwNewError("Error in protocol, expected EOF packet", true, info, "42000", Errors.ER_EOF_EXPECTED);
        }
        packet.skip(3);
        info.status = packet.readUInt16();
        this.isOutParameter = info.status & ServerStatus.PS_OUT_PARAMS;
        this.onPacketReceive = this.readResultSetRow;
      }
      handleNewRows(row) {
        this._rows[this._responseIndex].push(row);
      }
      /**
       * Check if packet is result-set end = EOF of OK_Packet with EOF header according to CLIENT_DEPRECATE_EOF capability
       * or a result-set row
       *
       * @param packet    current packet
       * @param out       output writer
       * @param opts      connection options
       * @param info      connection information
       * @returns {*}
       */
      readResultSetRow(packet, out, opts, info) {
        if (packet.peek() >= 254) {
          if (packet.peek() === 255) {
            info.status |= ServerStatus.STATUS_IN_TRANS;
            return this.throwError(
              packet.readError(info, this.opts.logParam ? this.displaySql() : this.sql, this.cmdParam.err),
              info
            );
          }
          if (!info.eofDeprecated && packet.length() < 13 || info.eofDeprecated && packet.length() < 16777215) {
            if (!info.eofDeprecated) {
              packet.skip(3);
              info.status = packet.readUInt16();
            } else {
              packet.skip(1);
              packet.skipLengthCodedNumber();
              packet.skipLengthCodedNumber();
              info.status = packet.readUInt16();
            }
            if (info.redirectRequest && (info.status & ServerStatus.STATUS_IN_TRANS) === 0 && (info.status & ServerStatus.MORE_RESULTS_EXISTS) === 0) {
              info.redirect(info.redirectRequest, this.resultSetEndingPacketResult.bind(this, info));
            } else {
              this.resultSetEndingPacketResult(info);
            }
            return;
          }
        }
        this.handleNewRows(this.parseRow(packet));
      }
      resultSetEndingPacketResult(info) {
        if (this.opts.metaAsArray) {
          if (info.status & ServerStatus.MORE_RESULTS_EXISTS || this.isOutParameter) {
            if (!this._meta) this._meta = [];
            this._meta[this._responseIndex] = this._columns;
            this._responseIndex++;
            return this.onPacketReceive = this.readResponsePacket;
          }
          if (this._responseIndex === 0) {
            this.success([this._rows[0], this._columns]);
          } else {
            if (!this._meta) this._meta = [];
            this._meta[this._responseIndex] = this._columns;
            this.success([this._rows, this._meta]);
          }
        } else {
          Object.defineProperty(this._rows[this._responseIndex], "meta", {
            value: this._columns,
            writable: true,
            enumerable: this.opts.metaEnumerable
          });
          if (info.status & ServerStatus.MORE_RESULTS_EXISTS || this.isOutParameter) {
            this._responseIndex++;
            return this.onPacketReceive = this.readResponsePacket;
          }
          this.success(this._responseIndex === 0 ? this._rows[0] : this._rows);
        }
      }
      /**
       * Display current SQL with parameters (truncated if too big)
       *
       * @returns {string}
       */
      displaySql() {
        if (this.opts && this.initialValues) {
          if (this.sql.length > this.opts.debugLen) {
            return this.sql.substring(0, this.opts.debugLen) + "...";
          }
          let sqlMsg = this.sql + " - parameters:";
          return _Parser.logParameters(this.opts, sqlMsg, this.initialValues);
        }
        if (this.sql.length > this.opts.debugLen) {
          return this.sql.substring(0, this.opts.debugLen) + "... - parameters:[]";
        }
        return this.sql + " - parameters:[]";
      }
      static logParameters(opts, sqlMsg, values) {
        if (opts.namedPlaceholders) {
          sqlMsg += "{";
          let first = true;
          for (let key in values) {
            if (first) {
              first = false;
            } else {
              sqlMsg += ",";
            }
            sqlMsg += "'" + key + "':";
            let param = values[key];
            sqlMsg = _Parser.logParam(sqlMsg, param);
            if (sqlMsg.length > opts.debugLen) {
              return sqlMsg.substring(0, opts.debugLen) + "...";
            }
          }
          sqlMsg += "}";
        } else {
          sqlMsg += "[";
          if (Array.isArray(values)) {
            for (let i = 0; i < values.length; i++) {
              if (i !== 0) sqlMsg += ",";
              let param = values[i];
              sqlMsg = _Parser.logParam(sqlMsg, param);
              if (sqlMsg.length > opts.debugLen) {
                return sqlMsg.substring(0, opts.debugLen) + "...";
              }
            }
          } else {
            sqlMsg = _Parser.logParam(sqlMsg, values);
            if (sqlMsg.length > opts.debugLen) {
              return sqlMsg.substring(0, opts.debugLen) + "...";
            }
          }
          sqlMsg += "]";
        }
        return sqlMsg;
      }
      parseRowAsArray(packet) {
        const row = new Array(this._columnCount);
        const nullBitMap = this.binary ? BinaryDecoder.newRow(packet, this._columns) : null;
        for (let i = 0; i < this._columnCount; i++) {
          row[i] = this._parseFunction[i](packet, this.opts, this.unexpectedError, nullBitMap, i);
        }
        return row;
      }
      parseRowNested(packet) {
        const row = {};
        const nullBitMap = this.binary ? BinaryDecoder.newRow(packet, this._columns) : null;
        for (let i = 0; i < this._columnCount; i++) {
          if (!row[this.tableHeader[i][0]]) row[this.tableHeader[i][0]] = {};
          row[this.tableHeader[i][0]][this.tableHeader[i][1]] = this._parseFunction[i](
            packet,
            this.opts,
            this.unexpectedError,
            nullBitMap,
            i
          );
        }
        return row;
      }
      parseRowStdText(packet) {
        const row = {};
        for (let i = 0; i < this._columnCount; i++) {
          row[this.tableHeader[i]] = this._parseFunction[i](packet, this.opts, this.unexpectedError);
        }
        return row;
      }
      parseRowStdBinary(packet) {
        const nullBitMap = BinaryDecoder.newRow(packet, this._columns);
        const row = {};
        for (let i = 0; i < this._columnCount; i++) {
          row[this.tableHeader[i]] = this._parseFunction[i](packet, this.opts, this.unexpectedError, nullBitMap, i);
        }
        return row;
      }
      readCastValue(column, packet, opts, unexpectedError, nullBitmap, index) {
        if (this.binary) {
          BinaryDecoder.castWrapper(column, packet, opts, nullBitmap, index);
        } else {
          TextDecoder.castWrapper(column, packet, opts, nullBitmap, index);
        }
        const dataParser = this.binary ? BinaryDecoder.parser : TextDecoder.parser;
        return opts.typeCast(column, dataParser(column, opts).bind(null, packet, opts, unexpectedError, nullBitmap, index));
      }
      readLocalInfile(packet, out, opts, info) {
        packet.skip(1);
        out.startPacket(this);
        const fileName = packet.readStringRemaining();
        if (!Parse.validateFileName(this.sql, this.initialValues, fileName)) {
          out.writeEmptyPacket();
          const error = Errors.createError(
            "LOCAL INFILE wrong filename. '" + fileName + "' doesn't correspond to query " + this.sql + ". Query cancelled. Check for malicious server / proxy",
            Errors.ER_LOCAL_INFILE_WRONG_FILENAME,
            info,
            "HY000",
            this.sql
          );
          process.nextTick(this.reject, error);
          this.reject = null;
          this.resolve = null;
          return this.onPacketReceive = this.readResponsePacket;
        }
        let stream;
        try {
          stream = this.opts.infileStreamFactory ? this.opts.infileStreamFactory(fileName) : fs2.createReadStream(fileName);
        } catch (e) {
          out.writeEmptyPacket();
          const error = Errors.createError(
            `LOCAL INFILE infileStreamFactory failed`,
            Errors.ER_LOCAL_INFILE_NOT_READABLE,
            info,
            "22000",
            this.opts.logParam ? this.displaySql() : this.sql
          );
          error.cause = e;
          process.nextTick(this.reject, error);
          this.reject = null;
          this.resolve = null;
          return this.onPacketReceive = this.readResponsePacket;
        }
        stream.on(
          "error",
          function(err) {
            out.writeEmptyPacket();
            const error = Errors.createError(
              `LOCAL INFILE command failed: ${err.message}`,
              Errors.ER_LOCAL_INFILE_NOT_READABLE,
              info,
              "22000",
              this.sql
            );
            process.nextTick(this.reject, error);
            this.reject = null;
            this.resolve = null;
          }.bind(this)
        );
        stream.on("data", (chunk) => {
          out.writeBuffer(chunk, 0, chunk.length);
        });
        stream.on("end", () => {
          if (!out.isEmpty()) {
            out.flushBuffer(false);
          }
          out.writeEmptyPacket();
        });
        this.onPacketReceive = this.readResponsePacket;
      }
      static logParam(sqlMsg, param) {
        if (param == null) {
          sqlMsg += param === void 0 ? "undefined" : "null";
        } else {
          switch (param.constructor.name) {
            case "Buffer":
              sqlMsg += "0x" + param.toString("hex", 0, Math.min(1024, param.length));
              break;
            case "String":
              sqlMsg += "'" + param + "'";
              break;
            case "Date":
              sqlMsg += getStringDate(param);
              break;
            case "Object":
              sqlMsg += JSON.stringify(param);
              break;
            default:
              sqlMsg += param.toString();
          }
        }
        return sqlMsg;
      }
    };
    function getStringDate(param) {
      return "'" + ("00" + (param.getMonth() + 1)).slice(-2) + "/" + ("00" + param.getDate()).slice(-2) + "/" + param.getFullYear() + " " + ("00" + param.getHours()).slice(-2) + ":" + ("00" + param.getMinutes()).slice(-2) + ":" + ("00" + param.getSeconds()).slice(-2) + "." + ("000" + param.getMilliseconds()).slice(-3) + "'";
    }
    module2.exports = Parser;
  }
});
var require_query = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/query.js"(exports, module2) {
    "use strict";
    var Parser = require_parser();
    var Errors = require_errors();
    var Parse = require_parse();
    var TextEncoder = require_text_encoder();
    var { Readable } = (0, import_chunk_WWAWV7DQ.__require)("stream");
    var QUOTE = 39;
    var Query = class extends Parser {
      constructor(resolve, reject, connOpts, cmdParam) {
        super(resolve, reject, connOpts, cmdParam);
        this.binary = false;
      }
      /**
       * Send COM_QUERY
       *
       * @param out   output writer
       * @param opts  connection options
       * @param info  connection information
       */
      start(out, opts, info) {
        if (opts.logger.query) opts.logger.query(`QUERY: ${opts.logParam ? this.displaySql() : this.sql}`);
        this.onPacketReceive = this.readResponsePacket;
        if (this.initialValues === void 0) {
          out.startPacket(this);
          out.writeInt8(3);
          if (!this.handleTimeout(out, info)) return;
          out.writeString(this.sql);
          out.flush();
          this.emit("send_end");
          return;
        }
        this.encodedSql = out.encodeString(this.sql);
        if (this.opts.namedPlaceholders) {
          try {
            const parsed = Parse.splitQueryPlaceholder(
              this.encodedSql,
              info,
              this.initialValues,
              this.opts.logParam ? this.displaySql.bind(this) : () => this.sql
            );
            this.paramPositions = parsed.paramPositions;
            this.values = parsed.values;
          } catch (err) {
            this.emit("send_end");
            return this.throwError(err, info);
          }
        } else {
          this.paramPositions = Parse.splitQuery(this.encodedSql);
          this.values = Array.isArray(this.initialValues) ? this.initialValues : [this.initialValues];
          if (!this.validateParameters(info)) return;
        }
        out.startPacket(this);
        out.writeInt8(3);
        if (!this.handleTimeout(out, info)) return;
        this.paramPos = 0;
        this.sqlPos = 0;
        const len = this.paramPositions.length / 2;
        for (this.valueIdx = 0; this.valueIdx < len; ) {
          out.writeBuffer(this.encodedSql, this.sqlPos, this.paramPositions[this.paramPos++] - this.sqlPos);
          this.sqlPos = this.paramPositions[this.paramPos++];
          const value = this.values[this.valueIdx++];
          if (value == null) {
            out.writeStringAscii("NULL");
            continue;
          }
          switch (typeof value) {
            case "boolean":
              out.writeStringAscii(value ? "true" : "false");
              break;
            case "bigint":
            case "number":
              out.writeStringAscii(`${value}`);
              break;
            case "string":
              out.writeStringEscapeQuote(value);
              break;
            case "object":
              if (typeof value.pipe === "function" && typeof value.read === "function") {
                this.sending = true;
                this.paramWritten = this._paramWritten.bind(this, out, info);
                out.writeInt8(QUOTE);
                value.on("data", out.writeBufferEscape.bind(out));
                value.on(
                  "end",
                  function() {
                    out.writeInt8(QUOTE);
                    this.paramWritten();
                  }.bind(this)
                );
                return;
              }
              if (Object.prototype.toString.call(value) === "[object Date]") {
                out.writeStringAscii(TextEncoder.getLocalDate(value));
              } else if (Buffer.isBuffer(value)) {
                out.writeStringAscii("_BINARY '");
                out.writeBufferEscape(value);
                out.writeInt8(QUOTE);
              } else if (typeof value.toSqlString === "function") {
                out.writeStringEscapeQuote(String(value.toSqlString()));
              } else if (Array.isArray(value)) {
                if (opts.arrayParenthesis) {
                  out.writeStringAscii("(");
                }
                for (let i = 0; i < value.length; i++) {
                  if (i !== 0) out.writeStringAscii(",");
                  if (value[i] == null) {
                    out.writeStringAscii("NULL");
                  } else TextEncoder.writeParam(out, value[i], opts, info);
                }
                if (opts.arrayParenthesis) {
                  out.writeStringAscii(")");
                }
              } else {
                if (value.type != null && [
                  "Point",
                  "LineString",
                  "Polygon",
                  "MultiPoint",
                  "MultiLineString",
                  "MultiPolygon",
                  "GeometryCollection"
                ].includes(value.type)) {
                  let prefix = info.isMariaDB() && info.hasMinVersion(10, 1, 4) || !info.isMariaDB() && info.hasMinVersion(5, 7, 6) ? "ST_" : "";
                  switch (value.type) {
                    case "Point":
                      out.writeStringAscii(
                        prefix + "PointFromText('POINT(" + TextEncoder.geoPointToString(value.coordinates) + ")')"
                      );
                      break;
                    case "LineString":
                      out.writeStringAscii(
                        prefix + "LineFromText('LINESTRING(" + TextEncoder.geoArrayPointToString(value.coordinates) + ")')"
                      );
                      break;
                    case "Polygon":
                      out.writeStringAscii(
                        prefix + "PolygonFromText('POLYGON(" + TextEncoder.geoMultiArrayPointToString(value.coordinates) + ")')"
                      );
                      break;
                    case "MultiPoint":
                      out.writeStringAscii(
                        prefix + "MULTIPOINTFROMTEXT('MULTIPOINT(" + TextEncoder.geoArrayPointToString(value.coordinates) + ")')"
                      );
                      break;
                    case "MultiLineString":
                      out.writeStringAscii(
                        prefix + "MLineFromText('MULTILINESTRING(" + TextEncoder.geoMultiArrayPointToString(value.coordinates) + ")')"
                      );
                      break;
                    case "MultiPolygon":
                      out.writeStringAscii(
                        prefix + "MPolyFromText('MULTIPOLYGON(" + TextEncoder.geoMultiPolygonToString(value.coordinates) + ")')"
                      );
                      break;
                    case "GeometryCollection":
                      out.writeStringAscii(
                        prefix + "GeomCollFromText('GEOMETRYCOLLECTION(" + TextEncoder.geometricCollectionToString(value.geometries) + ")')"
                      );
                      break;
                  }
                } else if (String === value.constructor) {
                  out.writeStringEscapeQuote(value);
                  break;
                } else {
                  if (opts.permitSetMultiParamEntries) {
                    let first = true;
                    for (let key in value) {
                      const val = value[key];
                      if (typeof val === "function") continue;
                      if (first) {
                        first = false;
                      } else {
                        out.writeStringAscii(",");
                      }
                      out.writeString("`" + key + "`");
                      if (val == null) {
                        out.writeStringAscii("=NULL");
                      } else {
                        out.writeStringAscii("=");
                        TextEncoder.writeParam(out, val, opts, info);
                      }
                    }
                    if (first) out.writeStringEscapeQuote(JSON.stringify(value));
                  } else {
                    out.writeStringEscapeQuote(JSON.stringify(value));
                  }
                }
              }
              break;
          }
        }
        out.writeBuffer(this.encodedSql, this.sqlPos, this.encodedSql.length - this.sqlPos);
        out.flush();
        this.emit("send_end");
      }
      /**
       * If timeout is set, prepend query with SET STATEMENT max_statement_time=xx FOR, or throw an error
       * @param out buffer
       * @param info server information
       * @returns {boolean} false if an error has been thrown
       */
      handleTimeout(out, info) {
        if (this.opts.timeout) {
          if (info.isMariaDB()) {
            if (info.hasMinVersion(10, 1, 2)) {
              out.writeString(`SET STATEMENT max_statement_time=${this.opts.timeout / 1e3} FOR `);
              return true;
            } else {
              this.sendCancelled(
                `Cannot use timeout for xpand/MariaDB server before 10.1.2. timeout value: ${this.opts.timeout}`,
                Errors.ER_TIMEOUT_NOT_SUPPORTED,
                info
              );
              return false;
            }
          } else {
            this.sendCancelled(
              `Cannot use timeout for MySQL server. timeout value: ${this.opts.timeout}`,
              Errors.ER_TIMEOUT_NOT_SUPPORTED,
              info
            );
            return false;
          }
        }
        return true;
      }
      /**
       * Validate that parameters exists and are defined.
       *
       * @param info        connection info
       * @returns {boolean} return false if any error occur.
       */
      validateParameters(info) {
        if (this.paramPositions.length / 2 > this.values.length) {
          this.sendCancelled(
            `Parameter at position ${this.values.length + 1} is not set`,
            Errors.ER_MISSING_PARAMETER,
            info
          );
          return false;
        }
        return true;
      }
      _paramWritten(out, info) {
        while (true) {
          if (this.valueIdx === this.paramPositions.length / 2) {
            out.writeBuffer(this.encodedSql, this.sqlPos, this.encodedSql.length - this.sqlPos);
            out.flush();
            this.sending = false;
            this.emit("send_end");
            return;
          } else {
            const value = this.values[this.valueIdx++];
            out.writeBuffer(this.encodedSql, this.sqlPos, this.paramPositions[this.paramPos++] - this.sqlPos);
            this.sqlPos = this.paramPositions[this.paramPos++];
            if (value == null) {
              out.writeStringAscii("NULL");
              continue;
            }
            if (typeof value === "object" && typeof value.pipe === "function" && typeof value.read === "function") {
              out.writeInt8(QUOTE);
              value.once(
                "end",
                function() {
                  out.writeInt8(QUOTE);
                  this._paramWritten(out, info);
                }.bind(this)
              );
              value.on("data", out.writeBufferEscape.bind(out));
              return;
            }
            TextEncoder.writeParam(out, value, this.opts, info);
          }
        }
      }
      _stream(socket, options) {
        this.socket = socket;
        options = options || {};
        options.objectMode = true;
        options.read = () => {
          this.socket.resume();
        };
        this.inStream = new Readable(options);
        this.on("fields", function(meta) {
          this.inStream.emit("fields", meta);
        });
        this.on("error", function(err) {
          this.inStream.emit("error", err);
        });
        this.on("close", function(err) {
          this.inStream.emit("error", err);
        });
        this.on("end", function(err) {
          if (err) this.inStream.emit("error", err);
          this.socket.resume();
          this.inStream.push(null);
        });
        this.inStream.close = function() {
          this.handleNewRows = () => {
          };
          this.socket.resume();
        }.bind(this);
        this.handleNewRows = function(row) {
          if (!this.inStream.push(row)) {
            this.socket.pause();
          }
        };
        return this.inStream;
      }
    };
    module2.exports = Query;
  }
});
var require_binary_encoder = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/encoder/binary-encoder.js"(exports, module2) {
    "use strict";
    var BinaryEncoder = class {
      /**
       * Write (and escape) current parameter value to output writer
       *
       * @param out     output writer
       * @param value   current parameter
       * @param opts    connection options
       * @param info    connection information
       */
      static writeParam(out, value, opts, info) {
        switch (typeof value) {
          case "boolean":
            out.writeInt8(value ? 1 : 0);
            break;
          case "bigint":
            if (value >= 2n ** 63n) {
              out.writeLengthEncodedString(value.toString());
            } else {
              out.writeBigInt(value);
            }
            break;
          case "number":
            if (Number.isInteger(value) && value >= -2147483648 && value < 2147483647) {
              out.writeInt32(value);
              break;
            }
            out.writeDouble(value);
            break;
          case "string":
            out.writeLengthEncodedString(value);
            break;
          case "object":
            if (Object.prototype.toString.call(value) === "[object Date]") {
              out.writeBinaryDate(value);
            } else if (Buffer.isBuffer(value)) {
              out.writeLengthEncodedBuffer(value);
            } else if (typeof value.toSqlString === "function") {
              out.writeLengthEncodedString(String(value.toSqlString()));
            } else {
              out.writeLengthEncodedString(JSON.stringify(value));
            }
            break;
          default:
            out.writeLengthEncodedBuffer(value);
        }
      }
      static getBufferFromGeometryValue(value, headerType) {
        let geoBuff;
        let pos;
        let type;
        if (!headerType) {
          switch (value.type) {
            case "Point":
              geoBuff = Buffer.allocUnsafe(21);
              geoBuff.writeInt8(1, 0);
              geoBuff.writeInt32LE(1, 1);
              if (value.coordinates && Array.isArray(value.coordinates) && value.coordinates.length >= 2 && !isNaN(value.coordinates[0]) && !isNaN(value.coordinates[1])) {
                geoBuff.writeDoubleLE(value.coordinates[0], 5);
                geoBuff.writeDoubleLE(value.coordinates[1], 13);
                return geoBuff;
              } else {
                return null;
              }
            case "LineString":
              if (value.coordinates && Array.isArray(value.coordinates)) {
                const pointNumber = value.coordinates.length;
                geoBuff = Buffer.allocUnsafe(9 + 16 * pointNumber);
                geoBuff.writeInt8(1, 0);
                geoBuff.writeInt32LE(2, 1);
                geoBuff.writeInt32LE(pointNumber, 5);
                for (let i = 0; i < pointNumber; i++) {
                  if (value.coordinates[i] && Array.isArray(value.coordinates[i]) && value.coordinates[i].length >= 2 && !isNaN(value.coordinates[i][0]) && !isNaN(value.coordinates[i][1])) {
                    geoBuff.writeDoubleLE(value.coordinates[i][0], 9 + 16 * i);
                    geoBuff.writeDoubleLE(value.coordinates[i][1], 17 + 16 * i);
                  } else {
                    return null;
                  }
                }
                return geoBuff;
              } else {
                return null;
              }
            case "Polygon":
              if (value.coordinates && Array.isArray(value.coordinates)) {
                const numRings = value.coordinates.length;
                let size = 0;
                for (let i = 0; i < numRings; i++) {
                  size += 4 + 16 * value.coordinates[i].length;
                }
                geoBuff = Buffer.allocUnsafe(9 + size);
                geoBuff.writeInt8(1, 0);
                geoBuff.writeInt32LE(3, 1);
                geoBuff.writeInt32LE(numRings, 5);
                pos = 9;
                for (let i = 0; i < numRings; i++) {
                  const lineString = value.coordinates[i];
                  if (lineString && Array.isArray(lineString)) {
                    geoBuff.writeInt32LE(lineString.length, pos);
                    pos += 4;
                    for (let j = 0; j < lineString.length; j++) {
                      if (lineString[j] && Array.isArray(lineString[j]) && lineString[j].length >= 2 && !isNaN(lineString[j][0]) && !isNaN(lineString[j][1])) {
                        geoBuff.writeDoubleLE(lineString[j][0], pos);
                        geoBuff.writeDoubleLE(lineString[j][1], pos + 8);
                        pos += 16;
                      } else {
                        return null;
                      }
                    }
                  }
                }
                return geoBuff;
              } else {
                return null;
              }
            case "MultiPoint":
              type = "MultiPoint";
              geoBuff = Buffer.allocUnsafe(9);
              geoBuff.writeInt8(1, 0);
              geoBuff.writeInt32LE(4, 1);
              break;
            case "MultiLineString":
              type = "MultiLineString";
              geoBuff = Buffer.allocUnsafe(9);
              geoBuff.writeInt8(1, 0);
              geoBuff.writeInt32LE(5, 1);
              break;
            case "MultiPolygon":
              type = "MultiPolygon";
              geoBuff = Buffer.allocUnsafe(9);
              geoBuff.writeInt8(1, 0);
              geoBuff.writeInt32LE(6, 1);
              break;
            case "GeometryCollection":
              geoBuff = Buffer.allocUnsafe(9);
              geoBuff.writeInt8(1, 0);
              geoBuff.writeInt32LE(7, 1);
              if (value.geometries && Array.isArray(value.geometries)) {
                const coordinateLength = value.geometries.length;
                const subArrays = [geoBuff];
                for (let i = 0; i < coordinateLength; i++) {
                  const tmpBuf = this.getBufferFromGeometryValue(value.geometries[i]);
                  if (tmpBuf == null) break;
                  subArrays.push(tmpBuf);
                }
                geoBuff.writeInt32LE(subArrays.length - 1, 5);
                return Buffer.concat(subArrays);
              } else {
                geoBuff.writeInt32LE(0, 5);
                return geoBuff;
              }
            default:
              return null;
          }
          if (value.coordinates && Array.isArray(value.coordinates)) {
            const coordinateLength = value.coordinates.length;
            const subArrays = [geoBuff];
            for (let i = 0; i < coordinateLength; i++) {
              const tmpBuf = this.getBufferFromGeometryValue(value.coordinates[i], type);
              if (tmpBuf == null) break;
              subArrays.push(tmpBuf);
            }
            geoBuff.writeInt32LE(subArrays.length - 1, 5);
            return Buffer.concat(subArrays);
          } else {
            geoBuff.writeInt32LE(0, 5);
            return geoBuff;
          }
        } else {
          switch (headerType) {
            case "MultiPoint":
              if (value && Array.isArray(value) && value.length >= 2 && !isNaN(value[0]) && !isNaN(value[1])) {
                geoBuff = Buffer.allocUnsafe(21);
                geoBuff.writeInt8(1, 0);
                geoBuff.writeInt32LE(1, 1);
                geoBuff.writeDoubleLE(value[0], 5);
                geoBuff.writeDoubleLE(value[1], 13);
                return geoBuff;
              }
              return null;
            case "MultiLineString":
              if (value && Array.isArray(value)) {
                const pointNumber = value.length;
                geoBuff = Buffer.allocUnsafe(9 + 16 * pointNumber);
                geoBuff.writeInt8(1, 0);
                geoBuff.writeInt32LE(2, 1);
                geoBuff.writeInt32LE(pointNumber, 5);
                for (let i = 0; i < pointNumber; i++) {
                  if (value[i] && Array.isArray(value[i]) && value[i].length >= 2 && !isNaN(value[i][0]) && !isNaN(value[i][1])) {
                    geoBuff.writeDoubleLE(value[i][0], 9 + 16 * i);
                    geoBuff.writeDoubleLE(value[i][1], 17 + 16 * i);
                  } else {
                    return null;
                  }
                }
                return geoBuff;
              }
              return null;
            case "MultiPolygon":
              if (value && Array.isArray(value)) {
                const numRings = value.length;
                let size = 0;
                for (let i = 0; i < numRings; i++) {
                  size += 4 + 16 * value[i].length;
                }
                geoBuff = Buffer.allocUnsafe(9 + size);
                geoBuff.writeInt8(1, 0);
                geoBuff.writeInt32LE(3, 1);
                geoBuff.writeInt32LE(numRings, 5);
                pos = 9;
                for (let i = 0; i < numRings; i++) {
                  const lineString = value[i];
                  if (lineString && Array.isArray(lineString)) {
                    geoBuff.writeInt32LE(lineString.length, pos);
                    pos += 4;
                    for (let j = 0; j < lineString.length; j++) {
                      if (lineString[j] && Array.isArray(lineString[j]) && lineString[j].length >= 2 && !isNaN(lineString[j][0]) && !isNaN(lineString[j][1])) {
                        geoBuff.writeDoubleLE(lineString[j][0], pos);
                        geoBuff.writeDoubleLE(lineString[j][1], pos + 8);
                        pos += 16;
                      } else {
                        return null;
                      }
                    }
                  }
                }
                return geoBuff;
              }
              return null;
          }
          return null;
        }
      }
    };
    module2.exports = BinaryEncoder;
  }
});
var require_prepare_wrapper = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/class/prepare-wrapper.js"(exports, module2) {
    "use strict";
    var _closed, _cacheWrapper, _prepare, _conn;
    var PrepareWrapper = class {
      constructor(cacheWrapper, prepare) {
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _closed, false);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _cacheWrapper);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _prepare);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _conn);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _cacheWrapper, cacheWrapper);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _prepare, prepare);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _conn, prepare.conn);
        this.execute = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _prepare).execute;
        this.executeStream = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _prepare).executeStream;
      }
      get conn() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn);
      }
      get id() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _prepare).id;
      }
      get parameterCount() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _prepare).parameterCount;
      }
      get _placeHolderIndex() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _prepare)._placeHolderIndex;
      }
      get columns() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _prepare).columns;
      }
      set columns(columns) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _prepare).columns = columns;
      }
      get database() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _prepare).database;
      }
      get query() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _prepare).query;
      }
      isClose() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _closed);
      }
      close() {
        if (!(0, import_chunk_WWAWV7DQ.__privateGet)(this, _closed)) {
          (0, import_chunk_WWAWV7DQ.__privateSet)(this, _closed, true);
          (0, import_chunk_WWAWV7DQ.__privateGet)(this, _cacheWrapper).decrementUse();
        }
      }
      toString() {
        return "PrepareWrapper{closed:" + (0, import_chunk_WWAWV7DQ.__privateGet)(this, _closed) + ",cache:" + (0, import_chunk_WWAWV7DQ.__privateGet)(this, _cacheWrapper) + "}";
      }
    };
    _closed = /* @__PURE__ */ new WeakMap();
    _cacheWrapper = /* @__PURE__ */ new WeakMap();
    _prepare = /* @__PURE__ */ new WeakMap();
    _conn = /* @__PURE__ */ new WeakMap();
    module2.exports = PrepareWrapper;
  }
});
var require_prepare_cache_wrapper = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/class/prepare-cache-wrapper.js"(exports, module2) {
    "use strict";
    var PrepareWrapper = require_prepare_wrapper();
    var _use, _cached, _prepare;
    var PrepareCacheWrapper = class {
      constructor(prepare) {
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _use, 0);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _cached);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _prepare);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _prepare, prepare);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _cached, true);
      }
      incrementUse() {
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _use, (0, import_chunk_WWAWV7DQ.__privateGet)(this, _use) + 1);
        return new PrepareWrapper(this, (0, import_chunk_WWAWV7DQ.__privateGet)(this, _prepare));
      }
      unCache() {
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _cached, false);
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _use) === 0) {
          (0, import_chunk_WWAWV7DQ.__privateGet)(this, _prepare).close();
        }
      }
      decrementUse() {
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _use, (0, import_chunk_WWAWV7DQ.__privateGet)(this, _use) - 1);
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _use) === 0 && !(0, import_chunk_WWAWV7DQ.__privateGet)(this, _cached)) {
          (0, import_chunk_WWAWV7DQ.__privateGet)(this, _prepare).close();
        }
      }
      toString() {
        return "Prepare{use:" + (0, import_chunk_WWAWV7DQ.__privateGet)(this, _use) + ",cached:" + (0, import_chunk_WWAWV7DQ.__privateGet)(this, _cached) + "}";
      }
    };
    _use = /* @__PURE__ */ new WeakMap();
    _cached = /* @__PURE__ */ new WeakMap();
    _prepare = /* @__PURE__ */ new WeakMap();
    module2.exports = PrepareCacheWrapper;
  }
});
var require_execute = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/execute.js"(exports, module2) {
    "use strict";
    var Parser = require_parser();
    var Errors = require_errors();
    var BinaryEncoder = require_binary_encoder();
    var FieldType = require_field_type();
    var Parse = require_parse();
    var Execute = class extends Parser {
      constructor(resolve, reject, connOpts, cmdParam, prepare) {
        super(resolve, reject, connOpts, cmdParam);
        this.binary = true;
        this.prepare = prepare;
        this.canSkipMeta = true;
      }
      /**
       * Send COM_QUERY
       *
       * @param out   output writer
       * @param opts  connection options
       * @param info  connection information
       */
      start(out, opts, info) {
        this.onPacketReceive = this.readResponsePacket;
        this.values = [];
        if (this.opts.namedPlaceholders) {
          if (this.prepare) {
            this.values = new Array(this.prepare.parameterCount);
            this.placeHolderIndex = this.prepare._placeHolderIndex;
          } else {
            const res = Parse.searchPlaceholder(this.sql);
            this.placeHolderIndex = res.placeHolderIndex;
            this.values = new Array(this.placeHolderIndex.length);
          }
          if (this.initialValues) {
            for (let i = 0; i < this.placeHolderIndex.length; i++) {
              this.values[i] = this.initialValues[this.placeHolderIndex[i]];
            }
          }
        } else {
          if (this.initialValues)
            this.values = Array.isArray(this.initialValues) ? this.initialValues : [this.initialValues];
        }
        this.parameterCount = this.prepare ? this.prepare.parameterCount : this.values.length;
        if (!this.validateParameters(info)) return;
        this.parametersType = new Array(this.parameterCount);
        let hasLongData = false;
        let val;
        for (let i = 0; i < this.parameterCount; i++) {
          val = this.values[i];
          if (val && val.type != null && [
            "Point",
            "LineString",
            "Polygon",
            "MultiPoint",
            "MultiLineString",
            "MultiPolygon",
            "GeometryCollection"
          ].includes(val.type)) {
            const geoBuff = BinaryEncoder.getBufferFromGeometryValue(val);
            if (geoBuff == null) {
              this.values[i] = null;
              val = null;
            } else {
              this.values[i] = Buffer.concat([
                Buffer.from([0, 0, 0, 0]),
                // SRID
                geoBuff
                // WKB
              ]);
              val = this.values[i];
            }
          }
          if (val == null) {
            this.parametersType[i] = NULL_PARAM_TYPE;
          } else {
            switch (typeof val) {
              case "boolean":
                this.parametersType[i] = BOOLEAN_TYPE;
                break;
              case "bigint":
                if (val >= 2n ** 63n) {
                  this.parametersType[i] = BIG_BIGINT_TYPE;
                } else {
                  this.parametersType[i] = BIGINT_TYPE;
                }
                break;
              case "number":
                if (Number.isInteger(val) && val >= -2147483648 && val < 2147483647) {
                  this.parametersType[i] = INT_TYPE;
                  break;
                }
                this.parametersType[i] = DOUBLE_TYPE;
                break;
              case "string":
                this.parametersType[i] = STRING_TYPE;
                break;
              case "object":
                if (Object.prototype.toString.call(val) === "[object Date]") {
                  this.parametersType[i] = DATE_TYPE;
                } else if (Buffer.isBuffer(val)) {
                  if (val.length < 16384 || !this.prepare) {
                    this.parametersType[i] = BLOB_TYPE;
                  } else {
                    this.parametersType[i] = LONGBLOB_TYPE;
                    hasLongData = true;
                  }
                } else if (typeof val.toSqlString === "function") {
                  this.parametersType[i] = STRING_FCT_TYPE;
                } else if (typeof val.pipe === "function" && typeof val.read === "function") {
                  hasLongData = true;
                  this.parametersType[i] = STREAM_TYPE;
                } else if (String === val.constructor) {
                  this.parametersType[i] = STRING_TOSTR_TYPE;
                } else {
                  this.parametersType[i] = STRINGIFY_TYPE;
                }
                break;
            }
          }
        }
        this.longDataStep = false;
        if (hasLongData) {
          for (let i = 0; i < this.parameterCount; i++) {
            if (this.parametersType[i].isLongData()) {
              if (opts.logger.query)
                opts.logger.query(
                  `EXECUTE: (${this.prepare ? this.prepare.id : -1}) sql: ${opts.logParam ? this.displaySql() : this.sql}`
                );
              if (!this.longDataStep) {
                this.longDataStep = true;
                this.registerStreamSendEvent(out, info);
                this.currentParam = i;
              }
              this.sendComStmtLongData(out, info, this.values[i]);
              return;
            }
          }
        }
        if (!this.longDataStep) {
          if (opts.logger.query)
            opts.logger.query(
              `EXECUTE: (${this.prepare ? this.prepare.id : -1}) sql: ${opts.logParam ? this.displaySql() : this.sql}`
            );
          this.sendComStmtExecute(out, info);
        }
      }
      /**
       * Validate that parameters exists and are defined.
       *
       * @param info        connection info
       * @returns {boolean} return false if any error occur.
       */
      validateParameters(info) {
        if (this.parameterCount > this.values.length) {
          this.sendCancelled(
            `Parameter at position ${this.values.length} is not set\\nsql: ${this.opts.logParam ? this.displaySql() : this.sql}`,
            Errors.ER_MISSING_PARAMETER,
            info
          );
          return false;
        }
        if (this.opts.namedPlaceholders && this.placeHolderIndex) {
          for (let i = 0; i < this.parameterCount; i++) {
            if (this.values[i] === void 0) {
              let errMsg = `Parameter named ${this.placeHolderIndex[i]} is not set`;
              if (this.placeHolderIndex.length < this.parameterCount) {
                errMsg = `Command expect ${this.parameterCount} parameters, but found only ${this.placeHolderIndex.length} named parameters. You probably use question mark in place of named parameters`;
              }
              this.sendCancelled(errMsg, Errors.ER_PARAMETER_UNDEFINED, info);
              return false;
            }
          }
        }
        return true;
      }
      sendComStmtLongData(out, info, value) {
        out.startPacket(this);
        out.writeInt8(24);
        out.writeInt32(this.prepare.id);
        out.writeInt16(this.currentParam);
        if (Buffer.isBuffer(value)) {
          out.writeBuffer(value, 0, value.length);
          out.flush();
          this.currentParam++;
          return this.paramWritten();
        }
        this.sending = true;
        value.on("data", function(chunk) {
          out.writeBuffer(chunk, 0, chunk.length);
        });
        value.on(
          "end",
          function() {
            out.flush();
            this.currentParam++;
            this.paramWritten();
          }.bind(this)
        );
      }
      /**
       * Send a COM_STMT_EXECUTE
       * @param out
       * @param info
       */
      sendComStmtExecute(out, info) {
        let nullCount = ~~((this.parameterCount + 7) / 8);
        const nullBitsBuffer = Buffer.alloc(nullCount);
        for (let i = 0; i < this.parameterCount; i++) {
          if (this.values[i] == null) {
            nullBitsBuffer[~~(i / 8)] |= 1 << i % 8;
          }
        }
        out.startPacket(this);
        out.writeInt8(23);
        out.writeInt32(this.prepare ? this.prepare.id : -1);
        out.writeInt8(0);
        out.writeInt32(1);
        out.writeBuffer(nullBitsBuffer, 0, nullCount);
        out.writeInt8(1);
        for (let i = 0; i < this.parameterCount; i++) {
          out.writeInt8(this.parametersType[i].type);
          out.writeInt8(0);
        }
        for (let i = 0; i < this.parameterCount; i++) {
          const parameterType = this.parametersType[i];
          if (parameterType.encoder) parameterType.encoder(out, this.values[i]);
        }
        out.flush();
        this.sending = false;
        this.emit("send_end");
      }
      /**
       * Define params events.
       * Each parameter indicate that he is written to socket,
       * emitting event so next stream parameter can be written.
       */
      registerStreamSendEvent(out, info) {
        this.paramWritten = function() {
          if (this.longDataStep) {
            for (; this.currentParam < this.parameterCount; this.currentParam++) {
              if (this.parametersType[this.currentParam].isLongData()) {
                const value = this.values[this.currentParam];
                this.sendComStmtLongData(out, info, value);
                return;
              }
            }
            this.longDataStep = false;
          }
          if (!this.longDataStep) {
            this.sendComStmtExecute(out, info);
          }
        }.bind(this);
      }
    };
    var ParameterType = class {
      constructor(type, encoder, pipe = false, isNull = false) {
        this.pipe = pipe;
        this.type = type;
        this.encoder = encoder;
        this.isNull = isNull;
      }
      isLongData() {
        return this.encoder === null && !this.isNull;
      }
    };
    var NULL_PARAM_TYPE = new ParameterType(FieldType.VAR_STRING, null, false, true);
    var BOOLEAN_TYPE = new ParameterType(FieldType.TINY, (out, value) => out.writeInt8(value ? 1 : 0));
    var BIG_BIGINT_TYPE = new ParameterType(
      FieldType.NEWDECIMAL,
      (out, value) => out.writeLengthEncodedString(value.toString())
    );
    var BIGINT_TYPE = new ParameterType(FieldType.BIGINT, (out, value) => out.writeBigInt(value));
    var INT_TYPE = new ParameterType(FieldType.INT, (out, value) => out.writeInt32(value));
    var DOUBLE_TYPE = new ParameterType(FieldType.DOUBLE, (out, value) => out.writeDouble(value));
    var STRING_TYPE = new ParameterType(FieldType.VAR_STRING, (out, value) => out.writeLengthEncodedString(value));
    var STRING_TOSTR_TYPE = new ParameterType(
      FieldType.VAR_STRING,
      (out, value) => out.writeLengthEncodedString(value.toString())
    );
    var DATE_TYPE = new ParameterType(FieldType.DATETIME, (out, value) => out.writeBinaryDate(value));
    var BLOB_TYPE = new ParameterType(FieldType.BLOB, (out, value) => out.writeLengthEncodedBuffer(value));
    var LONGBLOB_TYPE = new ParameterType(FieldType.BLOB, null);
    var STRING_FCT_TYPE = new ParameterType(
      FieldType.VAR_STRING,
      (out, value) => out.writeLengthEncodedString(String(value.toSqlString()))
    );
    var STREAM_TYPE = new ParameterType(FieldType.BLOB, null, true);
    var STRINGIFY_TYPE = new ParameterType(
      FieldType.VAR_STRING,
      (out, value) => out.writeLengthEncodedString(JSON.stringify(value))
    );
    module2.exports = Execute;
  }
});
var require_execute_stream = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/execute-stream.js"(exports, module2) {
    "use strict";
    var Execute = require_execute();
    var { Readable } = (0, import_chunk_WWAWV7DQ.__require)("stream");
    var ExecuteStream = class extends Execute {
      constructor(cmdParam, connOpts, prepare, socket) {
        super(
          () => {
          },
          () => {
          },
          connOpts,
          cmdParam,
          prepare
        );
        this.socket = socket;
        this.inStream = new Readable({
          objectMode: true,
          read: () => {
            this.socket.resume();
          }
        });
        this.on("fields", function(meta) {
          this.inStream.emit("fields", meta);
        });
        this.on("error", function(err) {
          this.inStream.emit("error", err);
        });
        this.on("close", function(err) {
          this.inStream.emit("error", err);
        });
        this.on("end", function(err) {
          if (err) this.inStream.emit("error", err);
          this.socket.resume();
          this.inStream.push(null);
        });
        this.inStream.close = function() {
          this.handleNewRows = () => {
          };
          this.socket.resume();
        }.bind(this);
      }
      handleNewRows(row) {
        if (!this.inStream.push(row)) {
          this.socket.pause();
        }
      }
    };
    module2.exports = ExecuteStream;
  }
});
var require_prepare_result_packet = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/class/prepare-result-packet.js"(exports, module2) {
    "use strict";
    var Errors = require_errors();
    var ExecuteStream = require_execute_stream();
    var Parser = require_parser();
    var _conn;
    var PrepareResultPacket = class {
      constructor(statementId, parameterCount, columns, database, sql, placeHolderIndex, conn) {
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _conn);
        this.id = statementId;
        this.parameterCount = parameterCount;
        this.columns = columns;
        this.database = database;
        this.query = sql;
        this.closed = false;
        this._placeHolderIndex = placeHolderIndex;
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _conn, conn);
      }
      get conn() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn);
      }
      execute(values, opts, cb, stack) {
        let _opts = opts, _cb = cb;
        if (typeof _opts === "function") {
          _cb = _opts;
          _opts = void 0;
        }
        if (this.isClose()) {
          let sql = this.query;
          if (this.conn.opts.logParam) {
            if (this.query.length > this.conn.opts.debugLen) {
              sql = this.query.substring(0, this.conn.opts.debugLen) + "...";
            } else {
              let sqlMsg = this.query + " - parameters:";
              sql = Parser.logParameters(this.conn.opts, sqlMsg, values);
            }
          }
          const error = Errors.createError(
            `Execute fails, prepare command as already been closed`,
            Errors.ER_PREPARE_CLOSED,
            null,
            "22000",
            sql
          );
          if (!_cb) {
            return Promise.reject(error);
          } else {
            _cb(error);
            return;
          }
        }
        const cmdParam = {
          sql: this.query,
          values,
          opts: _opts,
          callback: _cb
        };
        if (stack) cmdParam.stack = stack;
        const conn = this.conn;
        const promise = new Promise((resolve, reject) => conn.executePromise.call(conn, cmdParam, this, resolve, reject));
        if (!_cb) {
          return promise;
        } else {
          promise.then((res) => {
            if (_cb) _cb(null, res, null);
          }).catch(_cb || function(err) {
          });
        }
      }
      executeStream(values, opts, cb, stack) {
        let _opts = opts, _cb = cb;
        if (typeof _opts === "function") {
          _cb = _opts;
          _opts = void 0;
        }
        if (this.isClose()) {
          const error = Errors.createError(
            `Execute fails, prepare command as already been closed`,
            Errors.ER_PREPARE_CLOSED,
            null,
            "22000",
            this.query
          );
          if (!_cb) {
            throw error;
          } else {
            _cb(error);
            return;
          }
        }
        const cmdParam = {
          sql: this.query,
          values,
          opts: _opts,
          callback: _cb
        };
        if (stack) cmdParam.stack = stack;
        const cmd = new ExecuteStream(cmdParam, this.conn.opts, this, this.conn.socket);
        if (this.conn.opts.logger.error) cmd.on("error", this.conn.opts.logger.error);
        this.conn.addCommand(cmd, true);
        return cmd.inStream;
      }
      isClose() {
        return this.closed;
      }
      close() {
        if (!this.closed) {
          this.closed = true;
          (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).emit("close_prepare", this);
        }
      }
      toString() {
        return "Prepare{closed:" + this.closed + "}";
      }
    };
    _conn = /* @__PURE__ */ new WeakMap();
    module2.exports = PrepareResultPacket;
  }
});
var require_prepare = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/prepare.js"(exports, module2) {
    "use strict";
    var Parser = require_parser();
    var Parse = require_parse();
    var BinaryEncoder = require_binary_encoder();
    var PrepareCacheWrapper = require_prepare_cache_wrapper();
    var PrepareResult = require_prepare_result_packet();
    var ServerStatus = require_server_status();
    var Errors = require_errors();
    var ColumnDefinition = require_column_definition();
    var Prepare = class extends Parser {
      constructor(resolve, reject, connOpts, cmdParam, conn) {
        super(resolve, reject, connOpts, cmdParam);
        this.encoder = new BinaryEncoder(this.opts);
        this.binary = true;
        this.conn = conn;
        this.executeCommand = cmdParam.executeCommand;
      }
      /**
       * Send COM_STMT_PREPARE
       *
       * @param out   output writer
       * @param opts  connection options
       * @param info  connection information
       */
      start(out, opts, info) {
        if (this.conn.prepareCache) {
          let cachedPrepare = this.conn.prepareCache.get(this.sql);
          if (cachedPrepare) {
            this.emit("send_end");
            return this.successEnd(cachedPrepare);
          }
        }
        if (opts.logger.query) opts.logger.query(`PREPARE: ${this.sql}`);
        this.onPacketReceive = this.readPrepareResultPacket;
        if (this.opts.namedPlaceholders) {
          const res = Parse.searchPlaceholder(this.sql);
          this.sql = res.sql;
          this.placeHolderIndex = res.placeHolderIndex;
        }
        out.startPacket(this);
        out.writeInt8(22);
        out.writeString(this.sql);
        out.flush();
        this.emit("send_end");
      }
      successPrepare(info, opts) {
        let prepare = new PrepareResult(
          this.statementId,
          this.parameterCount,
          this._columns,
          info.database,
          this.sql,
          this.placeHolderIndex,
          this.conn
        );
        if (this.conn.prepareCache) {
          let cached = new PrepareCacheWrapper(prepare);
          this.conn.prepareCache.set(this.sql, cached);
          const cachedWrappedPrepared = cached.incrementUse();
          if (this.executeCommand) this.executeCommand.prepare = cachedWrappedPrepared;
          return this.successEnd(cachedWrappedPrepared);
        }
        if (this.executeCommand) this.executeCommand.prepare = prepare;
        this.successEnd(prepare);
      }
      /**
       * Read COM_STMT_PREPARE response Packet.
       * see https://mariadb.com/kb/en/library/com_stmt_prepare/#com_stmt_prepare-response
       *
       * @param packet    COM_STMT_PREPARE_OK packet
       * @param opts      connection options
       * @param info      connection information
       * @param out       output writer
       * @returns {*}     null or {Result.readResponsePacket} in case of multi-result-set
       */
      readPrepareResultPacket(packet, out, opts, info) {
        switch (packet.peek()) {
          case 0:
            packet.skip(1);
            this.statementId = packet.readInt32();
            this.columnNo = packet.readUInt16();
            this.parameterCount = packet.readUInt16();
            this._parameterNo = this.parameterCount;
            this._columns = [];
            if (this._parameterNo > 0) return this.onPacketReceive = this.skipPrepareParameterPacket;
            if (this.columnNo > 0) return this.onPacketReceive = this.readPrepareColumnsPacket;
            return this.successPrepare(info, opts);
          case 255:
            const err = packet.readError(info, this.displaySql(), this.stack);
            info.status |= ServerStatus.STATUS_IN_TRANS;
            this.onPacketReceive = this.readResponsePacket;
            return this.throwError(err, info);
          default:
            info.status |= ServerStatus.STATUS_IN_TRANS;
            this.onPacketReceive = this.readResponsePacket;
            return this.throwError(Errors.ER_UNEXPECTED_PACKET, info);
        }
      }
      readPrepareColumnsPacket(packet, out, opts, info) {
        this.columnNo--;
        this._columns.push(new ColumnDefinition(packet, info, opts.rowsAsArray));
        if (this.columnNo === 0) {
          if (info.eofDeprecated) {
            return this.successPrepare(info, opts);
          }
          this.onPacketReceive = this.skipEofPacket;
        }
      }
      skipEofPacket(packet, out, opts, info) {
        if (this.columnNo > 0) return this.onPacketReceive = this.readPrepareColumnsPacket;
        this.successPrepare(info, opts);
      }
      skipPrepareParameterPacket(packet, out, opts, info) {
        this._parameterNo--;
        if (this._parameterNo === 0) {
          if (info.eofDeprecated) {
            if (this.columnNo > 0) return this.onPacketReceive = this.readPrepareColumnsPacket;
            return this.successPrepare(info, opts);
          }
          this.onPacketReceive = this.skipEofPacket;
        }
      }
      /**
       * Display current SQL with parameters (truncated if too big)
       *
       * @returns {string}
       */
      displaySql() {
        if (this.opts) {
          if (this.sql.length > this.opts.debugLen) {
            return this.sql.substring(0, this.opts.debugLen) + "...";
          }
        }
        return this.sql;
      }
    };
    module2.exports = Prepare;
  }
});
var require_close_prepare = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/close-prepare.js"(exports, module2) {
    "use strict";
    var Command = require_command();
    var ClosePrepare = class extends Command {
      constructor(cmdParam, resolve, reject, prepare) {
        super(cmdParam, resolve, reject);
        this.prepare = prepare;
      }
      start(out, opts, info) {
        if (opts.logger.query) opts.logger.query(`CLOSE PREPARE: (${this.prepare.id}) ${this.prepare.query}`);
        const closeCmd = new Uint8Array([
          5,
          0,
          0,
          0,
          25,
          this.prepare.id,
          this.prepare.id >> 8,
          this.prepare.id >> 16,
          this.prepare.id >> 24
        ]);
        out.fastFlush(this, closeCmd);
        this.onPacketReceive = null;
        this.emit("send_end");
        this.emit("end");
      }
    };
    module2.exports = ClosePrepare;
  }
});
var require_batch_bulk = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/batch-bulk.js"(exports, module2) {
    "use strict";
    var Parser = require_parser();
    var Errors = require_errors();
    var BinaryEncoder = require_binary_encoder();
    var FieldType = require_field_type();
    var OkPacket = require_ok_packet();
    var BatchBulk = class extends Parser {
      constructor(resolve, reject, connOpts, prepare, cmdParam) {
        super(resolve, reject, connOpts, cmdParam);
        this.cmdOpts = cmdParam.opts;
        this.binary = true;
        this.prepare = prepare;
        this.canSkipMeta = true;
      }
      /**
       * Send COM_STMT_BULK_EXECUTE
       *
       * @param out   output writer
       * @param opts  connection options
       * @param info  connection information
       */
      start(out, opts, info) {
        this.info = info;
        this.values = this.initialValues;
        if (this.cmdOpts && this.cmdOpts.timeout) {
          this.bulkPacketNo = 1;
          this.sending = false;
          return this.sendCancelled("Cannot use timeout for Batch statement", Errors.ER_TIMEOUT_NOT_SUPPORTED);
        }
        this.onPacketReceive = this.readResponsePacket;
        if (this.opts.namedPlaceholders && this.prepare._placeHolderIndex) {
          this.values = [];
          if (this.initialValues) {
            for (let r = 0; r < this.initialValues.length; r++) {
              let val = this.initialValues[r];
              this.values[r] = new Array(this.prepare.parameterCount);
              for (let i = 0; i < this.prepare._placeHolderIndex.length; i++) {
                this.values[r][i] = val[this.prepare._placeHolderIndex[i]];
              }
            }
          }
        } else {
          this.values = this.initialValues;
        }
        if (!this.validateParameters(info)) return;
        this.sendComStmtBulkExecute(out, opts, info);
      }
      /**
       * Set header type
       * @param value current value
       * @param parameterCount parameter number
       * @returns {*[]} header type array
       */
      parameterHeaderFromValue(value, parameterCount) {
        const parameterHeaderType = new Array(parameterCount);
        for (let i = 0; i < parameterCount; i++) {
          const val = value[i];
          if (val != null) {
            switch (typeof val) {
              case "boolean":
                parameterHeaderType[i] = FieldType.TINY;
                break;
              case "bigint":
                if (val >= 2n ** 63n) {
                  parameterHeaderType[i] = FieldType.NEWDECIMAL;
                } else {
                  parameterHeaderType[i] = FieldType.BIGINT;
                }
                break;
              case "number":
                if (Number.isInteger(val) && val >= -2147483648 && val < 2147483647) {
                  parameterHeaderType[i] = FieldType.INT;
                  break;
                }
                parameterHeaderType[i] = FieldType.DOUBLE;
                break;
              case "string":
                parameterHeaderType[i] = FieldType.VAR_STRING;
                break;
              case "object":
                if (Object.prototype.toString.call(val) === "[object Date]") {
                  parameterHeaderType[i] = FieldType.DATETIME;
                } else if (Buffer.isBuffer(val)) {
                  parameterHeaderType[i] = FieldType.BLOB;
                } else if (typeof val.toSqlString === "function") {
                  parameterHeaderType[i] = FieldType.VAR_STRING;
                } else {
                  if (val.type != null && [
                    "Point",
                    "LineString",
                    "Polygon",
                    "MultiPoint",
                    "MultiLineString",
                    "MultiPolygon",
                    "GeometryCollection"
                  ].includes(val.type)) {
                    parameterHeaderType[i] = FieldType.BLOB;
                  } else {
                    parameterHeaderType[i] = FieldType.VAR_STRING;
                  }
                }
                break;
              default:
                parameterHeaderType[i] = FieldType.BLOB;
                break;
            }
          } else {
            parameterHeaderType[i] = FieldType.VAR_STRING;
          }
        }
        return parameterHeaderType;
      }
      /**
       * Check current value has same header than set in initial BULK header
       *
       * @param parameterHeaderType current header
       * @param value current value
       * @param parameterCount number of parameter
       * @returns {boolean} true if identical
       */
      checkSameHeader(parameterHeaderType, value, parameterCount) {
        let val;
        for (let i = 0; i < parameterCount; i++) {
          if ((val = value[i]) != null) {
            switch (typeof val) {
              case "boolean":
                if (parameterHeaderType[i] !== FieldType.TINY) return false;
                break;
              case "bigint":
                if (val >= 2n ** 63n) {
                  if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;
                } else {
                  if (parameterHeaderType[i] !== FieldType.BIGINT) return false;
                }
                break;
              case "number":
                if (Number.isInteger(val) && val >= -2147483648 && val < 2147483647) {
                  if (parameterHeaderType[i] !== FieldType.INT) return false;
                  break;
                }
                if (parameterHeaderType[i] !== FieldType.DOUBLE) return false;
                break;
              case "string":
                if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;
                break;
              case "object":
                if (Object.prototype.toString.call(val) === "[object Date]") {
                  if (parameterHeaderType[i] !== FieldType.TIMESTAMP) return false;
                } else if (Buffer.isBuffer(val)) {
                  if (parameterHeaderType[i] !== FieldType.BLOB) return false;
                } else if (typeof val.toSqlString === "function") {
                  if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;
                } else {
                  if (val.type != null && [
                    "Point",
                    "LineString",
                    "Polygon",
                    "MultiPoint",
                    "MultiLineString",
                    "MultiPolygon",
                    "GeometryCollection"
                  ].includes(val.type)) {
                    if (parameterHeaderType[i] !== FieldType.BLOB) return false;
                  } else {
                    if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;
                  }
                }
                break;
              default:
                if (parameterHeaderType[i] !== FieldType.BLOB) return false;
                break;
            }
          }
        }
        return true;
      }
      /**
       * Send a COM_STMT_BULK_EXECUTE
       * @param out output packet writer
       * @param opts options
       * @param info information
       */
      sendComStmtBulkExecute(out, opts, info) {
        if (opts.logger.query)
          opts.logger.query(`BULK: (${this.prepare.id}) sql: ${opts.logParam ? this.displaySql() : this.sql}`);
        const parameterCount = this.prepare.parameterCount;
        this.rowIdx = 0;
        this.vals = this.values[this.rowIdx++];
        let parameterHeaderType = this.parameterHeaderFromValue(this.vals, parameterCount);
        let lastCmdData = null;
        this.bulkPacketNo = 0;
        this.sending = true;
        main_loop: while (true) {
          this.bulkPacketNo++;
          out.startPacket(this);
          out.writeInt8(250);
          out.writeInt32(this.prepare.id);
          out.writeInt16(128);
          for (let i = 0; i < parameterCount; i++) {
            out.writeInt16(parameterHeaderType[i]);
          }
          if (lastCmdData != null) {
            const err = out.checkMaxAllowedLength(lastCmdData.length, info);
            if (err) {
              this.sending = false;
              this.throwError(err, info);
              return;
            }
            out.writeBuffer(lastCmdData, 0, lastCmdData.length);
            out.mark();
            lastCmdData = null;
            if (this.rowIdx >= this.values.length) {
              break;
            }
            this.vals = this.values[this.rowIdx++];
          }
          parameter_loop: while (true) {
            for (let i = 0; i < parameterCount; i++) {
              let param = this.vals[i];
              if (param != null) {
                if (param.type != null && [
                  "Point",
                  "LineString",
                  "Polygon",
                  "MultiPoint",
                  "MultiLineString",
                  "MultiPolygon",
                  "GeometryCollection"
                ].includes(param.type)) {
                  const geoBuff = BinaryEncoder.getBufferFromGeometryValue(param);
                  if (geoBuff == null) {
                    out.writeInt8(1);
                  } else {
                    out.writeInt8(0);
                    param = Buffer.concat([
                      Buffer.from([0, 0, 0, 0]),
                      // SRID
                      geoBuff
                      // WKB
                    ]);
                    BinaryEncoder.writeParam(out, param, this.opts, info);
                  }
                } else {
                  out.writeInt8(0);
                  BinaryEncoder.writeParam(out, param, this.opts, info);
                }
              } else {
                out.writeInt8(1);
              }
            }
            if (!out.bufIsDataAfterMark() && !out.isMarked() && out.hasFlushed()) {
              out.flush();
              if (!this.rowIdx >= this.values.length) {
                break main_loop;
              }
              this.vals = this.values[this.rowIdx++];
              parameterHeaderType = this.parameterHeaderFromValue(this.vals, parameterCount);
              break parameter_loop;
            }
            if (out.isMarked() && out.bufIsAfterMaxPacketLength()) {
              out.flushBufferStopAtMark();
              out.mark();
              lastCmdData = out.resetMark();
              break;
            }
            out.mark();
            if (out.bufIsDataAfterMark()) {
              lastCmdData = out.resetMark();
              break;
            }
            if (this.rowIdx >= this.values.length) {
              break main_loop;
            }
            this.vals = this.values[this.rowIdx++];
            if (!this.checkSameHeader(parameterHeaderType, this.vals, parameterCount)) {
              out.flush();
              parameterHeaderType = this.parameterHeaderFromValue(this.vals, parameterCount);
              break parameter_loop;
            }
          }
        }
        out.flush();
        this.sending = false;
        this.emit("send_end");
      }
      displaySql() {
        if (this.sql.length > this.opts.debugLen) {
          return this.sql.substring(0, this.opts.debugLen) + "...";
        }
        let sqlMsg = this.sql + " - parameters:[";
        for (let i = 0; i < this.initialValues.length; i++) {
          if (i !== 0) sqlMsg += ",";
          let param = this.initialValues[i];
          sqlMsg = Parser.logParameters(this.opts, sqlMsg, param);
          if (sqlMsg.length > this.opts.debugLen) {
            return sqlMsg.substring(0, this.opts.debugLen) + "...";
          }
        }
        sqlMsg += "]";
        return sqlMsg;
      }
      success(val) {
        this.bulkPacketNo--;
        if (this._responseIndex === 0) {
          if (this.opts.metaAsArray) {
            if (val[0] instanceof OkPacket) this._rows.push(val[0]);
          } else if (val instanceof OkPacket) this._rows.push(val);
        }
        if (!this.sending && this.bulkPacketNo === 0) {
          this.packet = null;
          if (this.firstError) {
            this.resolve = null;
            this.onPacketReceive = null;
            this._columns = null;
            this._rows = null;
            process.nextTick(this.reject, this.firstError);
            this.reject = null;
            this.emit("end", this.firstError);
          } else {
            if (this._rows[0].affectedRows !== void 0) {
              let totalAffectedRows = 0;
              this._rows.forEach((row) => {
                totalAffectedRows += row.affectedRows;
              });
              const rs = new OkPacket(
                totalAffectedRows,
                this._rows[0].insertId,
                this._rows[this._rows.length - 1].warningStatus
              );
              this.successEnd(this.opts.metaAsArray ? [rs, []] : rs);
            } else {
              if (this._rows.length === 1) {
                this.successEnd(this.opts.metaAsArray ? [this._rows[0], this._columns] : this._rows[0]);
              }
              if (this.opts.metaAsArray) {
                if (this._rows.length === 1) {
                  this.successEnd([this._rows[0], this._columns]);
                } else {
                  const rs = [];
                  this._rows.forEach((row) => {
                    rs.push(...row);
                  });
                  this.successEnd([rs, this._columns]);
                }
              } else {
                if (this._rows.length === 1) {
                  this.successEnd(this._rows[0]);
                } else {
                  const rs = [];
                  this._rows.forEach((row) => {
                    rs.push(...row);
                  });
                  Object.defineProperty(rs, "meta", {
                    value: this._columns,
                    writable: true,
                    enumerable: this.opts.metaEnumerable
                  });
                  this.successEnd(rs);
                }
              }
            }
            this._columns = null;
            this._rows = null;
          }
          return;
        }
        if (!this.firstError) {
          this._responseIndex++;
          this.onPacketReceive = this.readResponsePacket;
        }
      }
      throwError(err, info) {
        this.bulkPacketNo--;
        if (!this.firstError) {
          if (err.fatal) {
            this.bulkPacketNo = 0;
          }
          if (this.cmdParam.stack) {
            err = Errors.createError(
              err.message,
              err.errno,
              info,
              err.sqlState,
              this.sql,
              err.fatal,
              this.cmdParam.stack,
              false
            );
          }
          this.firstError = err;
        }
        if (!this.sending && this.bulkPacketNo === 0) {
          this.resolve = null;
          this.emit("send_end");
          process.nextTick(this.reject, this.firstError);
          this.reject = null;
          this.onPacketReceive = null;
          this.emit("end", this.firstError);
        } else {
          this._responseIndex++;
          this.onPacketReceive = this.readResponsePacket;
        }
      }
      /**
       * Validate that parameters exists and are defined.
       *
       * @param info        connection info
       * @returns {boolean} return false if any error occur.
       */
      validateParameters(info) {
        const nbParameter = this.prepare.parameterCount;
        for (let r = 0; r < this.values.length; r++) {
          if (!Array.isArray(this.values[r])) this.values[r] = [this.values[r]];
          if (this.values[r].length < nbParameter) {
            this.emit("send_end");
            this.throwNewError(
              `Expect ${nbParameter} parameters, but at index ${r}, parameters only contains ${this.values[r].length}
 ${this.opts.logParam ? this.displaySql() : this.sql}`,
              false,
              info,
              "HY000",
              Errors.ER_PARAMETER_UNDEFINED
            );
            return false;
          }
        }
        return true;
      }
    };
    module2.exports = BatchBulk;
  }
});
var require_change_user = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/change-user.js"(exports, module2) {
    "use strict";
    var Iconv = (0, import_chunk_LOGAFLCN.require_lib)();
    var Capabilities = require_capabilities();
    var Ed25519PasswordAuth = require_ed25519_password_auth();
    var NativePasswordAuth = require_native_password_auth();
    var Collations = require_collations();
    var Authentication = require_authentication();
    var ChangeUser = class extends Authentication {
      constructor(cmdParam, connOpts, resolve, reject, getSocket) {
        super(cmdParam, resolve, reject, () => {
        }, getSocket);
        this.configAssign(connOpts, cmdParam.opts);
      }
      start(out, opts, info) {
        if (opts.logger.query) opts.logger.query(`CHANGE USER to '${this.opts.user || ""}'`);
        let authToken;
        const pwd = Array.isArray(this.opts.password) ? this.opts.password[0] : this.opts.password;
        switch (info.defaultPluginName) {
          case "mysql_native_password":
          case "":
            authToken = NativePasswordAuth.encryptSha1Password(pwd, info.seed);
            break;
          case "client_ed25519":
            authToken = Ed25519PasswordAuth.encryptPassword(pwd, info.seed);
            break;
          default:
            authToken = Buffer.alloc(0);
            break;
        }
        out.startPacket(this);
        out.writeInt8(17);
        out.writeString(this.opts.user || "");
        out.writeInt8(0);
        if (info.serverCapabilities & Capabilities.SECURE_CONNECTION) {
          out.writeInt8(authToken.length);
          out.writeBuffer(authToken, 0, authToken.length);
        } else {
          out.writeBuffer(authToken, 0, authToken.length);
          out.writeInt8(0);
        }
        if (info.clientCapabilities & Capabilities.CONNECT_WITH_DB) {
          out.writeString(this.opts.database);
          out.writeInt8(0);
          info.database = this.opts.database;
        }
        if (this.opts.collation) {
          if (!this.opts.charset || info.collation.charset !== this.opts.collation.charset) {
            info.collation = this.opts.collation;
          }
        } else {
          if (info.collation.charset !== "utf8" || info.collation.maxLength === 3) {
            info.collation = Collations.fromIndex(224);
          }
        }
        out.writeInt16(info.collation.index);
        if (info.clientCapabilities & Capabilities.PLUGIN_AUTH) {
          out.writeString(info.defaultPluginName);
          out.writeInt8(0);
        }
        if (info.clientCapabilities & Capabilities.CONNECT_ATTRS) {
          out.writeInt8(252);
          let initPos = out.pos;
          out.writeInt16(0);
          const encoding = info.collation.charset;
          writeAttribute(out, "_client_name", encoding);
          writeAttribute(out, "MariaDB connector/Node", encoding);
          let packageJson = require_package();
          writeAttribute(out, "_client_version", encoding);
          writeAttribute(out, packageJson.version, encoding);
          writeAttribute(out, "_node_version", encoding);
          writeAttribute(out, process.versions.node, encoding);
          if (opts.connectAttributes !== true) {
            let attrNames = Object.keys(this.opts.connectAttributes);
            for (let k = 0; k < attrNames.length; ++k) {
              writeAttribute(out, attrNames[k], encoding);
              writeAttribute(out, this.opts.connectAttributes[attrNames[k]], encoding);
            }
          }
          out.writeInt16AtPos(initPos);
        }
        out.flush();
        this.plugin.onPacketReceive = this.handshakeResult.bind(this);
      }
      /**
       * Assign global configuration option used by result-set to current query option.
       * a little faster than Object.assign() since doest copy all information
       *
       * @param connOpts  connection global configuration
       * @param cmdOpts   current options
       */
      configAssign(connOpts, cmdOpts) {
        if (!cmdOpts) {
          this.opts = connOpts;
          return;
        }
        this.opts = cmdOpts ? Object.assign({}, connOpts, cmdOpts) : connOpts;
        if (cmdOpts.charset && typeof cmdOpts.charset === "string") {
          this.opts.collation = Collations.fromCharset(cmdOpts.charset.toLowerCase());
          if (this.opts.collation === void 0) {
            this.opts.collation = Collations.fromName(cmdOpts.charset.toUpperCase());
            if (this.opts.collation !== void 0) {
              this.opts.logger.warning(
                "warning: please use option 'collation' in replacement of 'charset' when using a collation name ('" + cmdOpts.charset + "')\n(collation looks like 'UTF8MB4_UNICODE_CI', charset like 'utf8')."
              );
            }
          }
          if (this.opts.collation === void 0) throw new RangeError("Unknown charset '" + cmdOpts.charset + "'");
        } else if (cmdOpts.collation && typeof cmdOpts.collation === "string") {
          const initial = cmdOpts.collation;
          this.opts.collation = Collations.fromName(initial.toUpperCase());
          if (this.opts.collation === void 0) throw new RangeError("Unknown collation '" + initial + "'");
        } else {
          this.opts.collation = Collations.fromIndex(cmdOpts.charsetNumber) || connOpts.collation;
        }
        connOpts.password = cmdOpts.password;
      }
    };
    function writeAttribute(out, val, encoding) {
      let param = Buffer.isEncoding(encoding) ? Buffer.from(val, encoding) : Iconv.encode(val, encoding);
      out.writeLengthCoded(param.length);
      out.writeBuffer(param, 0, param.length);
    }
    module2.exports = ChangeUser;
  }
});
var require_connection_status = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/const/connection_status.js"(exports, module2) {
    "use strict";
    var Status = {
      NOT_CONNECTED: 1,
      CONNECTING: 2,
      AUTHENTICATING: 3,
      INIT_CMD: 4,
      CONNECTED: 5,
      CLOSING: 6,
      CLOSED: 7
    };
    module2.exports.Status = Status;
  }
});
var require_lru_prepare_cache = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/lru-prepare-cache.js"(exports, module2) {
    "use strict";
    var LRU = (0, import_chunk_XRTNIFND.require_commonjs)();
    var _lruCache, _info;
    var LruPrepareCache = class {
      constructor(info, prepareCacheLength) {
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _lruCache);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _info);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _info, info);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _lruCache, new LRU.LRUCache({
          max: prepareCacheLength,
          dispose: (value, key) => value.unCache()
        }));
      }
      get(sql) {
        const key = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _info).database + "|" + sql;
        const cachedItem = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _lruCache).get(key);
        if (cachedItem) {
          return cachedItem.incrementUse();
        }
        return null;
      }
      set(sql, cache) {
        const key = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _info).database + "|" + sql;
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _lruCache).set(key, cache);
      }
      toString() {
        let keyStr = "";
        for (const value of (0, import_chunk_WWAWV7DQ.__privateGet)(this, _lruCache).keys()) {
          keyStr += "[" + value + "],";
        }
        if (keyStr.length > 1) keyStr = keyStr.substring(0, keyStr.length - 1);
        return "info{cache:" + keyStr + "}";
      }
      reset() {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _lruCache).clear();
      }
    };
    _lruCache = /* @__PURE__ */ new WeakMap();
    _info = /* @__PURE__ */ new WeakMap();
    module2.exports = LruPrepareCache;
  }
});
var require_connection = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/connection.js"(exports, module2) {
    "use strict";
    var EventEmitter = (0, import_chunk_WWAWV7DQ.__require)("events");
    var Queue = require_denque();
    var Net = (0, import_chunk_WWAWV7DQ.__require)("net");
    var PacketInputStream = require_packet_input_stream();
    var PacketOutputStream = require_packet_output_stream();
    var CompressionInputStream = require_compression_input_stream();
    var CompressionOutputStream = require_compression_output_stream();
    var ServerStatus = require_server_status();
    var ConnectionInformation = require_connection_information();
    var tls = (0, import_chunk_WWAWV7DQ.__require)("tls");
    var Errors = require_errors();
    var Utils = require_utils();
    var Capabilities = require_capabilities();
    var ConnectionOptions = require_connection_options();
    var Authentication = require_authentication();
    var Quit = require_quit();
    var Ping = require_ping();
    var Reset = require_reset();
    var Query = require_query();
    var Prepare = require_prepare();
    var OkPacket = require_ok_packet();
    var Execute = require_execute();
    var ClosePrepare = require_close_prepare();
    var BatchBulk = require_batch_bulk();
    var ChangeUser = require_change_user();
    var { Status } = require_connection_status();
    var LruPrepareCache = require_lru_prepare_cache();
    var fsPromises = (0, import_chunk_WWAWV7DQ.__require)("fs").promises;
    var Parse = require_parse();
    var Collations = require_collations();
    var ConnOptions = require_connection_options();
    var convertFixedTime = function(tz, conn) {
      if (tz === "UTC" || tz === "Etc/UTC" || tz === "Z" || tz === "Etc/GMT") {
        return "+00:00";
      } else if (tz.startsWith("Etc/GMT") || tz.startsWith("GMT")) {
        let tzdiff;
        let negate;
        if (tz.startsWith("Etc/GMT")) {
          tzdiff = tz.substring(7);
          negate = !tzdiff.startsWith("-");
        } else {
          tzdiff = tz.substring(3);
          negate = tzdiff.startsWith("-");
        }
        let diff = parseInt(tzdiff.substring(1));
        if (isNaN(diff)) {
          throw Errors.createFatalError(
            `Automatic timezone setting fails. wrong Server timezone '${tz}' conversion to +/-HH:00 conversion.`,
            Errors.ER_WRONG_AUTO_TIMEZONE,
            conn.info
          );
        }
        return (negate ? "-" : "+") + (diff >= 10 ? diff : "0" + diff) + ":00";
      }
      return tz;
    };
    var redirectUrlFormat = /(mariadb|mysql):\/\/(([^/@:]+)?(:([^/]+))?@)?(([^/:]+)(:([0-9]+))?)(\/([^?]+)(\?(.*))?)?$/;
    var Connection = class _Connection extends EventEmitter {
      constructor(options) {
        super();
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "opts");
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "sendQueue", new Queue());
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "receiveQueue", new Queue());
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "waitingAuthenticationQueue", new Queue());
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "status", Status.NOT_CONNECTED);
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "socket", null);
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "timeout", null);
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "addCommand");
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "streamOut");
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "streamIn");
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "info");
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "prepareCache");
        this.opts = Object.assign(new EventEmitter(), options);
        this.info = new ConnectionInformation(this.opts, this.redirect.bind(this));
        this.prepareCache = this.opts.prepareCacheLength > 0 ? new LruPrepareCache(this.info, this.opts.prepareCacheLength) : null;
        this.addCommand = this.addCommandQueue;
        this.streamOut = new PacketOutputStream(this.opts, this.info);
        this.streamIn = new PacketInputStream(
          this.unexpectedPacket.bind(this),
          this.receiveQueue,
          this.streamOut,
          this.opts,
          this.info
        );
        this.on("close_prepare", this._closePrepare.bind(this));
        this.escape = Utils.escape.bind(this, this.opts, this.info);
        this.escapeId = Utils.escapeId.bind(this, this.opts, this.info);
      }
      //*****************************************************************
      // public methods
      //*****************************************************************
      /**
       * Connect event
       *
       * @returns {Promise} promise
       */
      connect() {
        const conn = this;
        this.status = Status.CONNECTING;
        const authenticationParam = {
          opts: this.opts
        };
        return new Promise(function(resolve, reject) {
          conn.connectRejectFct = reject;
          conn.connectResolveFct = resolve;
          const authentication = new Authentication(
            authenticationParam,
            conn.authSucceedHandler.bind(conn),
            conn.authFailHandler.bind(conn),
            conn.createSecureContext.bind(conn),
            conn.getSocket.bind(conn)
          );
          Error.captureStackTrace(authentication);
          authentication.once("end", () => {
            conn.receiveQueue.shift();
            if (!conn.opts.collation && conn.info.collation) {
              conn.opts.emit("collation", conn.info.collation);
            }
            process.nextTick(conn.nextSendCmd.bind(conn));
          });
          conn.receiveQueue.push(authentication);
          conn.streamInitSocket.call(conn);
        });
      }
      executePromise(cmdParam, prepare, resolve, reject) {
        const cmd = new Execute(resolve, this._logAndReject.bind(this, reject), this.opts, cmdParam, prepare);
        this.addCommand(cmd, true);
      }
      batch(cmdParam) {
        if (!cmdParam.sql) {
          const err = Errors.createError(
            "sql parameter is mandatory",
            Errors.ER_UNDEFINED_SQL,
            this.info,
            "HY000",
            null,
            false,
            cmdParam.stack
          );
          if (this.opts.logger.error) this.opts.logger.error(err);
          return Promise.reject(err);
        }
        if (!cmdParam.values) {
          const err = Errors.createError(
            "Batch must have values set",
            Errors.ER_BATCH_WITH_NO_VALUES,
            this.info,
            "HY000",
            cmdParam.sql.length > this.opts.debugLen ? cmdParam.sql.substring(0, this.opts.debugLen) + "..." : cmdParam.sql,
            false,
            cmdParam.stack
          );
          if (this.opts.logger.error) this.opts.logger.error(err);
          return Promise.reject(err);
        }
        return new Promise(this.prepare.bind(this, cmdParam)).then((prepare) => {
          const usePlaceHolder = cmdParam.opts && cmdParam.opts.namedPlaceholders || this.opts.namedPlaceholders;
          let vals;
          if (Array.isArray(cmdParam.values)) {
            if (usePlaceHolder) {
              vals = cmdParam.values;
            } else if (Array.isArray(cmdParam.values[0])) {
              vals = cmdParam.values;
            } else if (prepare.parameterCount === 1) {
              vals = [];
              for (let i = 0; i < cmdParam.values.length; i++) {
                vals.push([cmdParam.values[i]]);
              }
            } else {
              vals = [cmdParam.values];
            }
          } else {
            vals = [[cmdParam.values]];
          }
          cmdParam.values = vals;
          let useBulk = this._canUseBulk(vals, cmdParam.opts);
          if (useBulk) {
            return new Promise(this.executeBulkPromise.bind(this, cmdParam, prepare, this.opts));
          } else {
            const executes = [];
            const cmdOpt = Object.assign({}, this.opts, cmdParam.opts);
            for (let i = 0; i < vals.length; i++) {
              executes.push(prepare.execute(vals[i], cmdParam.opts, null, cmdParam.stack));
            }
            return Promise.all(executes).then(
              function(res) {
                if (cmdParam.opts && cmdParam.opts.fullResult) {
                  return Promise.resolve(res);
                } else {
                  let firstResult = res[0];
                  if (cmdOpt.metaAsArray) firstResult = firstResult[0];
                  if (firstResult instanceof OkPacket) {
                    let affectedRows = 0;
                    const insertId = firstResult.insertId;
                    const warningStatus = firstResult.warningStatus;
                    if (cmdOpt.metaAsArray) {
                      for (let i = 0; i < res.length; i++) {
                        affectedRows += res[i][0].affectedRows;
                      }
                      return Promise.resolve([new OkPacket(affectedRows, insertId, warningStatus), []]);
                    } else {
                      for (let i = 0; i < res.length; i++) {
                        affectedRows += res[i].affectedRows;
                      }
                      return Promise.resolve(new OkPacket(affectedRows, insertId, warningStatus));
                    }
                  } else {
                    if (cmdOpt.metaAsArray) {
                      const rs = [];
                      res.forEach((row) => {
                        rs.push(...row[0]);
                      });
                      return Promise.resolve([rs, res[0][1]]);
                    } else {
                      const rs = [];
                      res.forEach((row) => {
                        rs.push(...row);
                      });
                      Object.defineProperty(rs, "meta", {
                        value: res[0].meta,
                        writable: true,
                        enumerable: this.opts.metaEnumerable
                      });
                      return Promise.resolve(rs);
                    }
                  }
                }
              }.bind(this)
            ).finally(() => prepare.close());
          }
        });
      }
      executeBulkPromise(cmdParam, prepare, opts, resolve, reject) {
        const cmd = new BatchBulk(
          (res) => {
            prepare.close();
            return resolve(res);
          },
          function(err) {
            prepare.close();
            if (opts.logger.error) opts.logger.error(err);
            reject(err);
          },
          opts,
          prepare,
          cmdParam
        );
        this.addCommand(cmd, true);
      }
      /**
       * Send an empty MySQL packet to ensure connection is active, and reset @@wait_timeout
       * @param cmdParam command context
       * @param resolve success function
       * @param reject rejection function
       */
      ping(cmdParam, resolve, reject) {
        if (cmdParam.opts && cmdParam.opts.timeout) {
          if (cmdParam.opts.timeout < 0) {
            const err = Errors.createError(
              "Ping cannot have negative timeout value",
              Errors.ER_BAD_PARAMETER_VALUE,
              this.info,
              "0A000"
            );
            if (this.opts.logger.error) this.opts.logger.error(err);
            reject(err);
            return;
          }
          let tOut = setTimeout(
            function() {
              tOut = void 0;
              const err = Errors.createFatalError("Ping timeout", Errors.ER_PING_TIMEOUT, this.info, "0A000");
              if (this.opts.logger.error) this.opts.logger.error(err);
              this.addCommand = this.addCommandDisabled;
              clearTimeout(this.timeout);
              if (this.status !== Status.CLOSING && this.status !== Status.CLOSED) {
                this.sendQueue.clear();
                this.status = Status.CLOSED;
                this.socket.destroy();
              }
              this.clear();
              reject(err);
            }.bind(this),
            cmdParam.opts.timeout
          );
          this.addCommand(
            new Ping(
              cmdParam,
              () => {
                if (tOut) {
                  clearTimeout(tOut);
                  resolve();
                }
              },
              (err) => {
                if (this.opts.logger.error) this.opts.logger.error(err);
                clearTimeout(tOut);
                reject(err);
              }
            ),
            true
          );
          return;
        }
        this.addCommand(new Ping(cmdParam, resolve, reject), true);
      }
      /**
       * Send a reset command that will
       * - rollback any open transaction
       * - reset transaction isolation level
       * - reset session variables
       * - delete user variables
       * - remove temporary tables
       * - remove all PREPARE statement
       */
      reset(cmdParam, resolve, reject) {
        if (this.info.isMariaDB() && this.info.hasMinVersion(10, 2, 4) || !this.info.isMariaDB() && this.info.hasMinVersion(5, 7, 3)) {
          const conn = this;
          const resetCmd = new Reset(
            cmdParam,
            () => {
              if (conn.prepareCache) conn.prepareCache.reset();
              let prom = Promise.resolve();
              prom.then(conn.handleCharset.bind(conn)).then(conn.handleTimezone.bind(conn)).then(conn.executeInitQuery.bind(conn)).then(conn.executeSessionTimeout.bind(conn)).then(resolve).catch(reject);
            },
            reject
          );
          this.addCommand(resetCmd, true);
          return;
        }
        const err = new Error(
          `Reset command not permitted for server ${this.info.serverVersion.raw} (requires server MariaDB version 10.2.4+ or MySQL 5.7.3+)`
        );
        err.stack = cmdParam.stack;
        if (this.opts.logger.error) this.opts.logger.error(err);
        reject(err);
      }
      /**
       * Indicates the state of the connection as the driver knows it
       * @returns {boolean}
       */
      isValid() {
        return this.status === Status.CONNECTED;
      }
      /**
       * Terminate connection gracefully.
       */
      end(cmdParam, resolve, reject) {
        this.addCommand = this.addCommandDisabled;
        clearTimeout(this.timeout);
        if (this.status < Status.CLOSING && this.status !== Status.NOT_CONNECTED) {
          this.status = Status.CLOSING;
          const ended = () => {
            this.status = Status.CLOSED;
            this.socket.destroy();
            this.socket.unref();
            this.clear();
            this.receiveQueue.clear();
            resolve();
          };
          const quitCmd = new Quit(cmdParam, ended, ended);
          this.sendQueue.push(quitCmd);
          this.receiveQueue.push(quitCmd);
          if (this.sendQueue.length === 1) {
            process.nextTick(this.nextSendCmd.bind(this));
          }
        } else resolve();
      }
      /**
       * Force connection termination by closing the underlying socket and killing server process if any.
       */
      destroy() {
        this.addCommand = this.addCommandDisabled;
        clearTimeout(this.timeout);
        if (this.status < Status.CLOSING) {
          this.status = Status.CLOSING;
          this.sendQueue.clear();
          if (this.receiveQueue.length > 0) {
            const self = this;
            const remoteAddress = this.socket.remoteAddress;
            const connOption = remoteAddress ? Object.assign({}, this.opts, { host: remoteAddress }) : this.opts;
            const killCon = new _Connection(connOption);
            killCon.connect().then(() => {
              new Promise(killCon.query.bind(killCon, { sql: `KILL ${self.info.threadId}` })).finally((err) => {
                const destroyError = Errors.createFatalError(
                  "Connection destroyed, command was killed",
                  Errors.ER_CMD_NOT_EXECUTED_DESTROYED,
                  self.info
                );
                if (self.opts.logger.error) self.opts.logger.error(destroyError);
                self.socketErrorDispatchToQueries(destroyError);
                if (self.socket) {
                  const sok = self.socket;
                  process.nextTick(() => {
                    sok.destroy();
                  });
                }
                self.status = Status.CLOSED;
                self.clear();
                new Promise(killCon.end.bind(killCon)).catch(() => {
                });
              });
            }).catch(() => {
              const ended = () => {
                let sock = self.socket;
                self.clear();
                self.status = Status.CLOSED;
                sock.destroy();
                self.receiveQueue.clear();
              };
              const quitCmd = new Quit(ended, ended);
              self.sendQueue.push(quitCmd);
              self.receiveQueue.push(quitCmd);
              if (self.sendQueue.length === 1) {
                process.nextTick(self.nextSendCmd.bind(self));
              }
            });
          } else {
            this.status = Status.CLOSED;
            this.socket.destroy();
            this.clear();
          }
        }
      }
      pause() {
        this.socket.pause();
      }
      resume() {
        this.socket.resume();
      }
      format(sql, values) {
        const err = Errors.createError(
          '"Connection.format intentionally not implemented. please use Connection.query(sql, values), it will be more secure and faster',
          Errors.ER_NOT_IMPLEMENTED_FORMAT,
          this.info,
          "0A000"
        );
        if (this.opts.logger.error) this.opts.logger.error(err);
        throw err;
      }
      //*****************************************************************
      // additional public methods
      //*****************************************************************
      /**
       * return current connected server version information.
       *
       * @returns {*}
       */
      serverVersion() {
        if (!this.info.serverVersion) {
          const err = new Error("cannot know if server information until connection is established");
          if (this.opts.logger.error) this.opts.logger.error(err);
          throw err;
        }
        return this.info.serverVersion.raw;
      }
      /**
       * Change option "debug" during connection.
       * @param val   debug value
       */
      debug(val) {
        if (typeof val === "boolean") {
          if (val && !this.opts.logger.network) this.opts.logger.network = console.log;
        } else if (typeof val === "function") {
          this.opts.logger.network = val;
        }
        this.opts.emit("debug", val);
      }
      debugCompress(val) {
        if (val) {
          if (typeof val === "boolean") {
            this.opts.debugCompress = val;
            if (val && !this.opts.logger.network) this.opts.logger.network = console.log;
          } else if (typeof val === "function") {
            this.opts.debugCompress = true;
            this.opts.logger.network = val;
          }
        } else this.opts.debugCompress = false;
      }
      //*****************************************************************
      // internal public testing methods
      //*****************************************************************
      get __tests() {
        return new TestMethods(this.info.collation, this.socket);
      }
      //*****************************************************************
      // internal methods
      //*****************************************************************
      /**
       * Use multiple COM_STMT_EXECUTE or COM_STMT_BULK_EXECUTE
       *
       * @param values current batch values
       * @param _options batch option
       * @return {boolean} indicating if can use bulk command
       */
      _canUseBulk(values, _options) {
        if (_options && _options.fullResult) return false;
        const bulkEnable = _options === void 0 || _options === null ? this.opts.bulk : _options.bulk !== void 0 && _options.bulk !== null ? _options.bulk : this.opts.bulk;
        if (this.info.serverVersion && this.info.serverVersion.mariaDb && this.info.hasMinVersion(10, 2, 7) && bulkEnable && (this.info.serverCapabilities & Capabilities.MARIADB_CLIENT_STMT_BULK_OPERATIONS) > 0n) {
          if (values !== void 0) {
            if (!this.opts.namedPlaceholders) {
              const paramLen = Array.isArray(values[0]) ? values[0].length : values[0] ? 1 : 0;
              if (paramLen === 0) return false;
              for (let r = 0; r < values.length; r++) {
                let row = values[r];
                if (!Array.isArray(row)) row = [row];
                if (paramLen !== row.length) {
                  return false;
                }
                for (let j = 0; j < paramLen; j++) {
                  const val = row[j];
                  if (val != null && typeof val === "object" && typeof val.pipe === "function" && typeof val.read === "function") {
                    return false;
                  }
                }
              }
            } else {
              for (let r = 0; r < values.length; r++) {
                let row = values[r];
                const keys = Object.keys(row);
                for (let j = 0; j < keys.length; j++) {
                  const val = row[keys[j]];
                  if (val != null && typeof val === "object" && typeof val.pipe === "function" && typeof val.read === "function") {
                    return false;
                  }
                }
              }
            }
          }
          return true;
        }
        return false;
      }
      executeSessionVariableQuery() {
        if (this.opts.sessionVariables) {
          const values = [];
          let sessionQuery = "set ";
          let keys = Object.keys(this.opts.sessionVariables);
          if (keys.length > 0) {
            for (let k = 0; k < keys.length; ++k) {
              sessionQuery += (k !== 0 ? "," : "") + "@@" + keys[k].replace(/[^a-z0-9_]/gi, "") + "=?";
              values.push(this.opts.sessionVariables[keys[k]]);
            }
            return new Promise(
              this.query.bind(this, {
                sql: sessionQuery,
                values
              })
            ).catch((initialErr) => {
              const err = Errors.createFatalError(
                `Error setting session variable (value ${JSON.stringify(this.opts.sessionVariables)}). Error: ${initialErr.message}`,
                Errors.ER_SETTING_SESSION_ERROR,
                this.info,
                "08S01",
                sessionQuery
              );
              if (this.opts.logger.error) this.opts.logger.error(err);
              return Promise.reject(err);
            });
          }
        }
        return Promise.resolve();
      }
      /**
       * set charset to charset/collation if set or utf8mb4 if not.
       * @returns {Promise<void>}
       * @private
       */
      handleCharset() {
        if (this.opts.collation) {
          if (this.opts.collation.index <= 255) return Promise.resolve();
          const charset = this.opts.collation.charset === "utf8" && this.opts.collation.maxLength === 4 ? "utf8mb4" : this.opts.collation.charset;
          return new Promise(
            this.query.bind(this, {
              sql: `SET NAMES ${charset} COLLATE ${this.opts.collation.name}`
            })
          );
        }
        if (!this.opts.charset && this.info.collation && this.info.collation.charset === "utf8" && this.info.collation.maxLength === 4) {
          this.info.collation = Collations.fromCharset("utf8mb4");
          return Promise.resolve();
        }
        const connCharset = this.opts.charset ? this.opts.charset : "utf8mb4";
        this.info.collation = Collations.fromCharset(connCharset);
        return new Promise(
          this.query.bind(this, {
            sql: `SET NAMES ${connCharset}`
          })
        );
      }
      /**
       * Asking server timezone if not set in case of 'auto'
       * @returns {Promise<void>}
       * @private
       */
      handleTimezone() {
        const conn = this;
        if (this.opts.timezone === "local") this.opts.timezone = void 0;
        if (this.opts.timezone === "auto") {
          return new Promise(
            this.query.bind(this, {
              sql: "SELECT @@system_time_zone stz, @@time_zone tz"
            })
          ).then((res) => {
            const serverTimezone = res[0].tz === "SYSTEM" ? res[0].stz : res[0].tz;
            const localTz = Intl.DateTimeFormat().resolvedOptions().timeZone;
            if (serverTimezone === localTz || convertFixedTime(serverTimezone, conn) === convertFixedTime(localTz, conn)) {
              this.opts.timezone = localTz;
              return Promise.resolve();
            }
            return this._setSessionTimezone(convertFixedTime(localTz, conn));
          });
        }
        if (this.opts.timezone) {
          return this._setSessionTimezone(convertFixedTime(this.opts.timezone, conn));
        }
        return Promise.resolve();
      }
      _setSessionTimezone(tz) {
        return new Promise(
          this.query.bind(this, {
            sql: "SET time_zone=?",
            values: [tz]
          })
        ).catch((err) => {
          const er = Errors.createFatalError(
            `setting timezone '${tz}' fails on server.
 look at https://mariadb.com/kb/en/mysql_tzinfo_to_sql/ to load IANA timezone. `,
            Errors.ER_WRONG_IANA_TIMEZONE,
            this.info
          );
          if (this.opts.logger.error) this.opts.logger.error(er);
          return Promise.reject(er);
        });
      }
      checkServerVersion() {
        if (!this.opts.forceVersionCheck) {
          return Promise.resolve();
        }
        return new Promise(
          this.query.bind(this, {
            sql: "SELECT @@VERSION AS v"
          })
        ).then(
          function(res) {
            this.info.serverVersion.raw = res[0].v;
            this.info.serverVersion.mariaDb = this.info.serverVersion.raw.includes("MariaDB");
            ConnectionInformation.parseVersionString(this.info);
            return Promise.resolve();
          }.bind(this)
        );
      }
      executeInitQuery() {
        if (this.opts.initSql) {
          const initialArr = Array.isArray(this.opts.initSql) ? this.opts.initSql : [this.opts.initSql];
          const initialPromises = [];
          initialArr.forEach((sql) => {
            initialPromises.push(
              new Promise(
                this.query.bind(this, {
                  sql
                })
              )
            );
          });
          return Promise.all(initialPromises).catch((initialErr) => {
            const err = Errors.createFatalError(
              `Error executing initial sql command: ${initialErr.message}`,
              Errors.ER_INITIAL_SQL_ERROR,
              this.info
            );
            if (this.opts.logger.error) this.opts.logger.error(err);
            return Promise.reject(err);
          });
        }
        return Promise.resolve();
      }
      executeSessionTimeout() {
        if (this.opts.queryTimeout) {
          if (this.info.isMariaDB() && this.info.hasMinVersion(10, 1, 2)) {
            const query = `SET max_statement_time=${this.opts.queryTimeout / 1e3}`;
            new Promise(
              this.query.bind(this, {
                sql: query
              })
            ).catch(
              function(initialErr) {
                const err = Errors.createFatalError(
                  `Error setting session queryTimeout: ${initialErr.message}`,
                  Errors.ER_INITIAL_TIMEOUT_ERROR,
                  this.info,
                  "08S01",
                  query
                );
                if (this.opts.logger.error) this.opts.logger.error(err);
                return Promise.reject(err);
              }.bind(this)
            );
          } else {
            const err = Errors.createError(
              `Can only use queryTimeout for MariaDB server after 10.1.1. queryTimeout value: ${this.opts.queryTimeout}`,
              Errors.ER_TIMEOUT_NOT_SUPPORTED,
              this.info,
              "HY000",
              this.opts.queryTimeout
            );
            if (this.opts.logger.error) this.opts.logger.error(err);
            return Promise.reject(err);
          }
        }
        return Promise.resolve();
      }
      getSocket() {
        return this.socket;
      }
      /**
       * Initialize socket and associate events.
       * @private
       */
      streamInitSocket() {
        if (this.opts.connectTimeout) {
          this.timeout = setTimeout(this.connectTimeoutReached.bind(this), this.opts.connectTimeout, Date.now());
        }
        if (this.opts.socketPath) {
          this.socket = Net.connect(this.opts.socketPath);
        } else if (this.opts.stream) {
          if (typeof this.opts.stream === "function") {
            const tmpSocket = this.opts.stream(
              function(err, stream) {
                if (err) {
                  this.authFailHandler(err);
                  return;
                }
                this.socket = stream ? stream : Net.connect(this.opts.port, this.opts.host);
                this.socketInit();
              }.bind(this)
            );
            if (tmpSocket) {
              this.socket = tmpSocket;
              this.socketInit();
            }
          } else {
            this.authFailHandler(
              Errors.createError(
                "stream option is not a function. stream must be a function with (error, callback) parameter",
                Errors.ER_BAD_PARAMETER_VALUE,
                this.info
              )
            );
          }
          return;
        } else {
          this.socket = Net.connect(this.opts.port, this.opts.host);
          this.socket.setNoDelay(true);
        }
        this.socketInit();
      }
      socketInit() {
        this.socket.on("data", this.streamIn.onData.bind(this.streamIn));
        this.socket.on("error", this.socketErrorHandler.bind(this));
        this.socket.on("end", this.socketErrorHandler.bind(this));
        this.socket.on(
          "connect",
          function() {
            if (this.status === Status.CONNECTING) {
              this.status = Status.AUTHENTICATING;
              this.socket.setTimeout(this.opts.socketTimeout, this.socketTimeoutReached.bind(this));
              this.socket.setNoDelay(true);
              if (this.opts.keepAliveDelay) {
                this.socket.setKeepAlive(true, this.opts.keepAliveDelay);
              }
            }
          }.bind(this)
        );
        this.socket.writeBuf = (buf) => this.socket.write(buf);
        this.socket.flush = () => {
        };
        this.streamOut.setStream(this.socket);
      }
      /**
       * Authentication success result handler.
       *
       * @private
       */
      authSucceedHandler() {
        if (this.opts.compress) {
          if (this.info.serverCapabilities & Capabilities.COMPRESS) {
            this.streamOut.setStream(new CompressionOutputStream(this.socket, this.opts, this.info));
            this.streamIn = new CompressionInputStream(this.streamIn, this.receiveQueue, this.opts, this.info);
            this.socket.removeAllListeners("data");
            this.socket.on("data", this.streamIn.onData.bind(this.streamIn));
          } else if (this.opts.logger.error) {
            this.opts.logger.error(
              Errors.createError(
                "connection is configured to use packet compression, but the server doesn't have this capability",
                Errors.ER_COMPRESSION_NOT_SUPPORTED,
                this.info
              )
            );
          }
        }
        this.addCommand = this.opts.pipelining ? this.addCommandEnablePipeline : this.addCommandEnable;
        const conn = this;
        this.status = Status.INIT_CMD;
        this.executeSessionVariableQuery().then(conn.handleCharset.bind(conn)).then(this.handleTimezone.bind(this)).then(this.checkServerVersion.bind(this)).then(this.executeInitQuery.bind(this)).then(this.executeSessionTimeout.bind(this)).then(() => {
          clearTimeout(this.timeout);
          conn.status = Status.CONNECTED;
          process.nextTick(conn.connectResolveFct, conn);
          const commands = conn.waitingAuthenticationQueue.toArray();
          commands.forEach((cmd) => {
            conn.addCommand(cmd, true);
          });
          conn.waitingAuthenticationQueue = null;
          conn.connectRejectFct = null;
          conn.connectResolveFct = null;
        }).catch((err) => {
          if (!err.fatal) {
            const res = () => {
              conn.authFailHandler.call(conn, err);
            };
            conn.end(res, res);
          } else {
            conn.authFailHandler.call(conn, err);
          }
          return Promise.reject(err);
        });
      }
      /**
       * Authentication failed result handler.
       *
       * @private
       */
      authFailHandler(err) {
        clearTimeout(this.timeout);
        if (this.connectRejectFct) {
          if (this.opts.logger.error) this.opts.logger.error(err);
          this.receiveQueue.shift();
          this.fatalError(err, true);
          process.nextTick(this.connectRejectFct, err);
          this.connectRejectFct = null;
        }
      }
      /**
       * Create TLS socket and associate events.
       *
       * @param info current connection information
       * @param callback  callback function when done
       * @private
       */
      createSecureContext(info, callback) {
        info.requireValidCert = this.opts.ssl === true || this.opts.ssl.rejectUnauthorized === void 0 || this.opts.ssl.rejectUnauthorized === true;
        const baseConf = {
          servername: this.opts.host,
          socket: this.socket,
          rejectUnauthorized: false
        };
        const sslOption = this.opts.ssl === true ? baseConf : Object.assign({}, this.opts.ssl, baseConf);
        try {
          const secureSocket = tls.connect(sslOption, callback);
          secureSocket.on("data", this.streamIn.onData.bind(this.streamIn));
          secureSocket.on("error", this.socketErrorHandler.bind(this));
          secureSocket.on("end", this.socketErrorHandler.bind(this));
          secureSocket.writeBuf = (buf) => secureSocket.write(buf);
          secureSocket.flush = () => {
          };
          this.socket.removeAllListeners("data");
          this.socket = secureSocket;
          this.streamOut.setStream(secureSocket);
        } catch (err) {
          this.socketErrorHandler(err);
        }
      }
      /**
       * Handle packet when no packet is expected.
       * (there can be an ERROR packet send by server/proxy to inform that connection is ending).
       *
       * @param packet  packet
       * @private
       */
      unexpectedPacket(packet) {
        if (packet && packet.peek() === 255) {
          let err = packet.readError(this.info);
          if (err.fatal && this.status < Status.CLOSING) {
            this.emit("error", err);
            if (this.opts.logger.error) this.opts.logger.error(err);
            this.end(
              () => {
              },
              () => {
              }
            );
          }
        } else if (this.status < Status.CLOSING) {
          const err = Errors.createFatalError(
            `receiving packet from server without active commands
conn:${this.info.threadId ? this.info.threadId : -1}(${packet.pos},${packet.end})
${Utils.log(this.opts, packet.buf, packet.pos, packet.end)}`,
            Errors.ER_UNEXPECTED_PACKET,
            this.info
          );
          if (this.opts.logger.error) this.opts.logger.error(err);
          this.emit("error", err);
          this.destroy();
        }
      }
      /**
       * Handle connection timeout.
       *
       * @private
       */
      connectTimeoutReached(initialConnectionTime) {
        this.timeout = null;
        const handshake = this.receiveQueue.peekFront();
        const err = Errors.createFatalError(
          `Connection timeout: failed to create socket after ${Date.now() - initialConnectionTime}ms`,
          Errors.ER_CONNECTION_TIMEOUT,
          this.info,
          "08S01",
          null,
          handshake ? handshake.stack : null
        );
        if (this.opts.logger.error) this.opts.logger.error(err);
        this.authFailHandler(err);
      }
      /**
       * Handle socket timeout.
       *
       * @private
       */
      socketTimeoutReached() {
        const err = Errors.createFatalError("socket timeout", Errors.ER_SOCKET_TIMEOUT, this.info);
        if (this.opts.logger.error) this.opts.logger.error(err);
        this.fatalError(err, true);
      }
      /**
       * Add command to waiting queue until authentication.
       *
       * @param cmd         command
       * @private
       */
      addCommandQueue(cmd) {
        this.waitingAuthenticationQueue.push(cmd);
      }
      /**
       * Add command to command sending and receiving queue.
       *
       * @param cmd         command
       * @param expectResponse queue command response
       * @private
       */
      addCommandEnable(cmd, expectResponse) {
        cmd.once("end", this._sendNextCmdImmediate.bind(this));
        if (this.sendQueue.isEmpty() && this.receiveQueue.isEmpty()) {
          if (expectResponse) this.receiveQueue.push(cmd);
          cmd.start(this.streamOut, this.opts, this.info);
        } else {
          if (expectResponse) this.receiveQueue.push(cmd);
          this.sendQueue.push(cmd);
        }
      }
      /**
       * Add command to command sending and receiving queue using pipelining
       *
       * @param cmd             command
       * @param expectResponse queue command response
       * @private
       */
      addCommandEnablePipeline(cmd, expectResponse) {
        cmd.once("send_end", this._sendNextCmdImmediate.bind(this));
        if (expectResponse) this.receiveQueue.push(cmd);
        if (this.sendQueue.isEmpty()) {
          cmd.start(this.streamOut, this.opts, this.info);
          if (cmd.sending) {
            this.sendQueue.push(cmd);
            cmd.prependOnceListener("send_end", this.sendQueue.shift.bind(this.sendQueue));
          }
        } else {
          this.sendQueue.push(cmd);
        }
      }
      /**
       * Replacing command when connection is closing or closed to send a proper error message.
       *
       * @param cmd         command
       * @private
       */
      addCommandDisabled(cmd) {
        const err = cmd.throwNewError(
          "Cannot execute new commands: connection closed",
          true,
          this.info,
          "08S01",
          Errors.ER_CMD_CONNECTION_CLOSED
        );
        if (this.opts.logger.error) this.opts.logger.error(err);
      }
      /**
       * Handle socket error.
       *
       * @param err               socket error
       * @private
       */
      socketErrorHandler(err) {
        if (this.status >= Status.CLOSING) return;
        if (this.socket) {
          this.socket.writeBuf = () => {
          };
          this.socket.flush = () => {
          };
        }
        if (!err) {
          err = Errors.createFatalError(
            "socket has unexpectedly been closed",
            Errors.ER_SOCKET_UNEXPECTED_CLOSE,
            this.info
          );
        } else {
          err.fatal = true;
          err.sqlState = "HY000";
        }
        switch (this.status) {
          case Status.CONNECTING:
          case Status.AUTHENTICATING:
            const currentCmd = this.receiveQueue.peekFront();
            if (currentCmd && currentCmd.stack && err) {
              err.stack += "\n From event:\n" + currentCmd.stack.substring(currentCmd.stack.indexOf("\n") + 1);
            }
            this.authFailHandler(err);
            break;
          default:
            this.fatalError(err, false);
        }
      }
      /**
       * Fatal unexpected error : closing connection, and throw exception.
       */
      fatalError(err, avoidThrowError) {
        if (this.status >= Status.CLOSING) {
          this.socketErrorDispatchToQueries(err);
          return;
        }
        const mustThrowError = this.status !== Status.CONNECTING;
        this.status = Status.CLOSING;
        this.addCommand = this.addCommandDisabled;
        if (this.socket) {
          this.socket.removeAllListeners("error");
          this.socket.removeAllListeners("timeout");
          this.socket.removeAllListeners("close");
          this.socket.removeAllListeners("data");
          if (!this.socket.destroyed) this.socket.destroy();
          this.socket = void 0;
        }
        this.status = Status.CLOSED;
        const errorThrownByCmd = this.socketErrorDispatchToQueries(err);
        if (mustThrowError) {
          if (this.opts.logger.error) this.opts.logger.error(err);
          if (this.listenerCount("error") > 0) {
            this.emit("error", err);
            this.emit("end");
            this.clear();
          } else {
            this.emit("end");
            this.clear();
            if (!avoidThrowError && !errorThrownByCmd) throw err;
          }
        } else {
          this.clear();
        }
      }
      /**
       * Dispatch fatal error to current running queries.
       *
       * @param err        the fatal error
       * @return {boolean} return if error has been relayed to queries
       */
      socketErrorDispatchToQueries(err) {
        let receiveCmd;
        let errorThrownByCmd = false;
        while (receiveCmd = this.receiveQueue.shift()) {
          if (receiveCmd && receiveCmd.onPacketReceive) {
            errorThrownByCmd = true;
            setImmediate(receiveCmd.throwError.bind(receiveCmd, err, this.info));
          }
        }
        return errorThrownByCmd;
      }
      /**
       * Will send next command in queue if any.
       *
       * @private
       */
      nextSendCmd() {
        let sendCmd;
        if (sendCmd = this.sendQueue.shift()) {
          if (sendCmd.sending) {
            this.sendQueue.unshift(sendCmd);
          } else {
            sendCmd.start(this.streamOut, this.opts, this.info);
            if (sendCmd.sending) {
              this.sendQueue.unshift(sendCmd);
              sendCmd.prependOnceListener("send_end", this.sendQueue.shift.bind(this.sendQueue));
            }
          }
        }
      }
      /**
       * Change transaction state.
       *
       * @param cmdParam command parameter
       * @param resolve success function to call
       * @param reject error function to call
       * @private
       */
      changeTransaction(cmdParam, resolve, reject) {
        if (this.status >= Status.CLOSING) {
          const err = Errors.createFatalError(
            "Cannot execute new commands: connection closed",
            Errors.ER_CMD_CONNECTION_CLOSED,
            this.info,
            "08S01",
            cmdParam.sql
          );
          if (this.opts.logger.error) this.opts.logger.error(err);
          reject(err);
          return;
        }
        if (this.receiveQueue.peekFront() || this.info.status & ServerStatus.STATUS_IN_TRANS) {
          const cmd = new Query(
            resolve,
            (err) => {
              if (this.opts.logger.error) this.opts.logger.error(err);
              reject(err);
            },
            this.opts,
            cmdParam
          );
          this.addCommand(cmd, true);
        } else resolve();
      }
      changeUser(cmdParam, resolve, reject) {
        if (!this.info.isMariaDB()) {
          const err = Errors.createError(
            "method changeUser not available for MySQL server due to Bug #83472",
            Errors.ER_MYSQL_CHANGE_USER_BUG,
            this.info,
            "0A000"
          );
          if (this.opts.logger.error) this.opts.logger.error(err);
          reject(err);
          return;
        }
        if (this.status < Status.CLOSING) {
          this.addCommand = this.addCommandEnable;
        }
        let conn = this;
        if (cmdParam.opts && cmdParam.opts.collation && typeof cmdParam.opts.collation === "string") {
          const val = cmdParam.opts.collation.toUpperCase();
          cmdParam.opts.collation = Collations.fromName(cmdParam.opts.collation.toUpperCase());
          if (cmdParam.opts.collation === void 0) return reject(new RangeError(`Unknown collation '${val}'`));
        }
        this.addCommand(
          new ChangeUser(
            cmdParam,
            this.opts,
            (res) => {
              if (conn.status < Status.CLOSING && conn.opts.pipelining) conn.addCommand = conn.addCommandEnablePipeline;
              if (cmdParam.opts && cmdParam.opts.collation) conn.opts.collation = cmdParam.opts.collation;
              conn.handleCharset().then(() => {
                if (cmdParam.opts && cmdParam.opts.collation) {
                  conn.info.collation = cmdParam.opts.collation;
                  conn.opts.emit("collation", cmdParam.opts.collation);
                }
                resolve(res);
              }).catch((err) => {
                const res2 = () => conn.authFailHandler.call(conn, err);
                if (!err.fatal) {
                  conn.end(res2, res2);
                } else {
                  res2();
                }
                reject(err);
              });
            },
            this.authFailHandler.bind(this, reject),
            this.getSocket.bind(this)
          ),
          true
        );
      }
      query(cmdParam, resolve, reject) {
        if (!cmdParam.sql)
          return reject(
            Errors.createError(
              "sql parameter is mandatory",
              Errors.ER_UNDEFINED_SQL,
              this.info,
              "HY000",
              null,
              false,
              cmdParam.stack
            )
          );
        const cmd = new Query(
          resolve,
          (err) => {
            if (this.opts.logger.error) this.opts.logger.error(err);
            reject(err);
          },
          this.opts,
          cmdParam
        );
        this.addCommand(cmd, true);
      }
      prepare(cmdParam, resolve, reject) {
        if (!cmdParam.sql)
          return reject(Errors.createError("sql parameter is mandatory", Errors.ER_UNDEFINED_SQL, this.info, "HY000"));
        if (this.prepareCache && (this.sendQueue.isEmpty() || !this.receiveQueue.peekFront())) {
          const cachedPrepare = this.prepareCache.get(cmdParam.sql);
          if (cachedPrepare) {
            return resolve(cachedPrepare);
          }
        }
        const cmd = new Prepare(
          resolve,
          (err) => {
            if (this.opts.logger.error) this.opts.logger.error(err);
            reject(err);
          },
          this.opts,
          cmdParam,
          this
        );
        this.addCommand(cmd, true);
      }
      prepareExecute(cmdParam) {
        if (!cmdParam.sql) {
          return Promise.reject(
            Errors.createError("sql parameter is mandatory", Errors.ER_UNDEFINED_SQL, this.info, "HY000")
          );
        }
        if (this.prepareCache && (this.sendQueue.isEmpty() || !this.receiveQueue.peekFront())) {
          const cachedPrepare = this.prepareCache.get(cmdParam.sql);
          if (cachedPrepare) {
            return new Promise(this.executePromise.bind(this, cmdParam, cachedPrepare)).finally(
              () => cachedPrepare.close()
            );
          }
        }
        const conn = this;
        if (this.opts.pipelining && this.info.isMariaDB() && this.info.hasMinVersion(10, 2, 4)) {
          let hasStreamingValue = false;
          const vals = cmdParam.values ? Array.isArray(cmdParam.values) ? cmdParam.values : [cmdParam.values] : [];
          for (let i = 0; i < vals.length; i++) {
            const val = vals[i];
            if (val != null && typeof val === "object" && typeof val.pipe === "function" && typeof val.read === "function") {
              hasStreamingValue = true;
            }
          }
          if (!hasStreamingValue) {
            return new Promise((resolve, reject) => {
              let nbExecute = 0;
              const executeCommand = new Execute(
                (res) => {
                  if (nbExecute++ === 0) {
                    executeCommand.prepare.close();
                    resolve(res);
                  }
                },
                (err) => {
                  if (nbExecute++ === 0) {
                    if (conn.opts.logger.error) conn.opts.logger.error(err);
                    reject(err);
                    if (executeCommand.prepare) {
                      executeCommand.prepare.close();
                    }
                  }
                },
                conn.opts,
                cmdParam,
                null
              );
              cmdParam.executeCommand = executeCommand;
              const cmd = new Prepare(
                (prep) => {
                  if (nbExecute > 0) prep.close();
                },
                (err) => {
                  if (nbExecute++ === 0) {
                    if (conn.opts.logger.error) conn.opts.logger.error(err);
                    reject(err);
                  }
                },
                conn.opts,
                cmdParam,
                conn
              );
              conn.addCommand(cmd, true);
              conn.addCommand(executeCommand, true);
            });
          }
        }
        return new Promise((resolve, reject) => {
          const cmd = new Prepare(resolve, reject, this.opts, cmdParam, conn);
          conn.addCommand(cmd, true);
        }).then((prepare) => {
          return new Promise(function(resolve, reject) {
            conn.executePromise.call(conn, cmdParam, prepare, resolve, reject);
          }).finally(() => prepare.close());
        }).catch((err) => {
          if (conn.opts.logger.error) conn.opts.logger.error(err);
          throw err;
        });
      }
      importFile(cmdParam, resolve, reject) {
        const conn = this;
        if (!cmdParam || !cmdParam.file) {
          return reject(
            Errors.createError(
              "SQL file parameter is mandatory",
              Errors.ER_MISSING_SQL_PARAMETER,
              conn.info,
              "HY000",
              null,
              false,
              cmdParam.stack
            )
          );
        }
        const prevAddCommand = this.addCommand.bind(conn);
        this.waitingAuthenticationQueue = new Queue();
        this.addCommand = this.addCommandQueue;
        const tmpQuery = function(sql, resolve2, reject2) {
          const cmd = new Query(
            resolve2,
            (err) => {
              if (conn.opts.logger.error) conn.opts.logger.error(err);
              reject2(err);
            },
            conn.opts,
            {
              sql,
              opts: {}
            }
          );
          prevAddCommand(cmd, true);
        };
        let prevDatabase = null;
        return (cmdParam.skipDbCheck ? Promise.resolve() : new Promise(tmpQuery.bind(conn, "SELECT DATABASE() as db"))).then((res) => {
          prevDatabase = res ? res[0].db : null;
          if (cmdParam.skipDbCheck && !conn.opts.database || !cmdParam.skipDbCheck && !cmdParam.database && !prevDatabase) {
            return reject(
              Errors.createError(
                "Database parameter is not set and no database is selected",
                Errors.ER_MISSING_DATABASE_PARAMETER,
                conn.info,
                "HY000",
                null,
                false,
                cmdParam.stack
              )
            );
          }
          const searchDbPromise = cmdParam.database ? new Promise(tmpQuery.bind(conn, `USE \`${cmdParam.database.replace(/`/gi, "``")}\``)) : Promise.resolve();
          return searchDbPromise.then(() => {
            const endingFunction = () => {
              if (conn.status < Status.CLOSING) {
                conn.addCommand = conn.addCommandEnable.bind(conn);
                if (conn.status < Status.CLOSING && conn.opts.pipelining) {
                  conn.addCommand = conn.addCommandEnablePipeline.bind(conn);
                }
                const commands = conn.waitingAuthenticationQueue.toArray();
                commands.forEach((cmd) => conn.addCommand(cmd, true));
                conn.waitingAuthenticationQueue = null;
              }
            };
            return fsPromises.open(cmdParam.file, "r").then(async (fd) => {
              const buf = {
                buffer: Buffer.allocUnsafe(16384),
                offset: 0,
                end: 0
              };
              const queryPromises = [];
              let cmdError = null;
              while (!cmdError) {
                try {
                  const res2 = await fd.read(buf.buffer, buf.end, buf.buffer.length - buf.end, null);
                  if (res2.bytesRead === 0) {
                    fd.close().catch(() => {
                    });
                    if (cmdError) {
                      endingFunction();
                      reject(cmdError);
                      return;
                    }
                    await Promise.allSettled(queryPromises).then(() => {
                      if (!cmdParam.skipDbCheck && prevDatabase && cmdParam.database && cmdParam.database !== prevDatabase) {
                        return new Promise(tmpQuery.bind(conn, `USE \`${prevDatabase.replace(/`/gi, "``")}\``));
                      }
                      return Promise.resolve();
                    }).then(() => {
                      endingFunction();
                      if (cmdError) {
                        reject(cmdError);
                      }
                      resolve();
                    }).catch((err) => {
                      endingFunction();
                      reject(err);
                    });
                    return;
                  } else {
                    buf.end += res2.bytesRead;
                    const queries = Parse.parseQueries(buf);
                    const queryIntermediatePromise = queries.flatMap((element) => {
                      return new Promise(tmpQuery.bind(conn, element)).catch((err) => {
                        cmdError = err;
                      });
                    });
                    queryPromises.push(...queryIntermediatePromise);
                    if (buf.offset === buf.end) {
                      buf.offset = 0;
                      buf.end = 0;
                    } else {
                      if (buf.offset > 8192) {
                        buf.buffer.copy(buf.buffer, 0, buf.offset, buf.end);
                        buf.end -= buf.offset;
                        buf.offset = 0;
                      } else if (buf.buffer.length - buf.end < 8192) {
                        const tmpBuf = Buffer.allocUnsafe(buf.buffer.length << 1);
                        buf.buffer.copy(tmpBuf, 0, buf.offset, buf.end);
                        buf.buffer = tmpBuf;
                        buf.end -= buf.offset;
                        buf.offset = 0;
                      }
                    }
                  }
                } catch (e) {
                  fd.close().catch(() => {
                  });
                  endingFunction();
                  Promise.allSettled(queryPromises).catch(() => {
                  });
                  return reject(
                    Errors.createError(
                      e.message,
                      Errors.ER_SQL_FILE_ERROR,
                      conn.info,
                      "HY000",
                      null,
                      false,
                      cmdParam.stack
                    )
                  );
                }
              }
              if (cmdError) {
                endingFunction();
                reject(cmdError);
              }
            }).catch((err) => {
              endingFunction();
              if (err.code === "ENOENT") {
                return reject(
                  Errors.createError(
                    `SQL file parameter '${cmdParam.file}' doesn't exists`,
                    Errors.ER_MISSING_SQL_FILE,
                    conn.info,
                    "HY000",
                    null,
                    false,
                    cmdParam.stack
                  )
                );
              }
              return reject(
                Errors.createError(err.message, Errors.ER_SQL_FILE_ERROR, conn.info, "HY000", null, false, cmdParam.stack)
              );
            });
          });
        });
      }
      /**
       * Clearing connection variables when ending.
       *
       * @private
       */
      clear() {
        this.sendQueue.clear();
        this.opts.removeAllListeners();
        this.streamOut = void 0;
        this.socket = void 0;
      }
      /**
       * Redirecting connection to server indicated value.
       * @param value server host string
       * @param resolve promise result when done
       */
      redirect(value, resolve) {
        if (this.opts.permitRedirect && value) {
          if (this.receiveQueue.length <= 1 && (this.info.status & ServerStatus.STATUS_IN_TRANS) === 0) {
            this.info.redirectRequest = null;
            const matchResults = value.match(redirectUrlFormat);
            if (!matchResults) {
              if (this.opts.logger.error)
                this.opts.logger.error(
                  new Error(
                    `error parsing redirection string '${value}'. format must be 'mariadb/mysql://[<user>[:<password>]@]<host>[:<port>]/[<db>[?<opt1>=<value1>[&<opt2>=<value2>]]]'`
                  )
                );
              return resolve();
            }
            const options = {
              host: matchResults[7] ? decodeURIComponent(matchResults[7]) : matchResults[6],
              port: matchResults[9] ? parseInt(matchResults[9]) : 3306
            };
            if (options.host === this.opts.host && options.port === this.opts.port) {
              return resolve();
            }
            if (matchResults[3]) options.user = matchResults[3];
            if (matchResults[5]) options.password = matchResults[5];
            const redirectOpts = ConnectionOptions.parseOptionDataType(options);
            const finalRedirectOptions = new ConnOptions(Object.assign({}, this.opts, redirectOpts));
            const conn = new _Connection(finalRedirectOptions);
            conn.connect().then(
              async function() {
                await new Promise(this.end.bind(this, {}));
                this.status = Status.CONNECTED;
                this.info = conn.info;
                this.opts = conn.opts;
                this.socket = conn.socket;
                if (this.prepareCache) this.prepareCache.reset();
                this.streamOut = conn.streamOut;
                this.streamIn = conn.streamIn;
                resolve();
              }.bind(this)
            ).catch(
              function(e) {
                if (this.opts.logger.error) {
                  const err = new Error(`fail to redirect to '${value}'`);
                  err.cause = e;
                  this.opts.logger.error(err);
                }
                resolve();
              }.bind(this)
            );
          } else {
            this.info.redirectRequest = value;
            resolve();
          }
        } else {
          this.info.redirectRequest = null;
          resolve();
        }
      }
      get threadId() {
        return this.info ? this.info.threadId : null;
      }
      _sendNextCmdImmediate() {
        if (!this.sendQueue.isEmpty()) {
          setImmediate(this.nextSendCmd.bind(this));
        }
      }
      _closePrepare(prepareResultPacket) {
        this.addCommand(
          new ClosePrepare(
            {},
            () => {
            },
            () => {
            },
            prepareResultPacket
          ),
          false
        );
      }
      _logAndReject(reject, err) {
        if (this.opts.logger.error) this.opts.logger.error(err);
        reject(err);
      }
    };
    var _collation, _socket;
    var TestMethods = class {
      constructor(collation, socket) {
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _collation);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _socket);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _collation, collation);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _socket, socket);
      }
      getCollation() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _collation);
      }
      getSocket() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _socket);
      }
    };
    _collation = /* @__PURE__ */ new WeakMap();
    _socket = /* @__PURE__ */ new WeakMap();
    module2.exports = Connection;
  }
});
var require_stream = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cmd/stream.js"(exports, module2) {
    "use strict";
    var Query = require_query();
    var { Readable } = (0, import_chunk_WWAWV7DQ.__require)("stream");
    var Stream = class extends Query {
      constructor(cmdParam, connOpts, socket) {
        super(
          () => {
          },
          () => {
          },
          connOpts,
          cmdParam
        );
        this.socket = socket;
        this.inStream = new Readable({
          objectMode: true,
          read: () => {
            this.socket.resume();
          }
        });
        this.on("fields", function(meta) {
          this.inStream.emit("fields", meta);
        });
        this.on("error", function(err) {
          this.inStream.emit("error", err);
        });
        this.on("close", function(err) {
          this.inStream.emit("error", err);
        });
        this.on("end", function(err) {
          if (err) this.inStream.emit("error", err);
          this.socket.resume();
          this.inStream.push(null);
        });
        this.inStream.close = function() {
          this.handleNewRows = () => {
          };
          this.socket.resume();
        }.bind(this);
      }
      handleNewRows(row) {
        if (!this.inStream.push(row)) {
          this.socket.pause();
        }
      }
    };
    module2.exports = Stream;
  }
});
var require_connection_promise = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/connection-promise.js"(exports, module2) {
    "use strict";
    var Stream = require_stream();
    var Errors = require_errors();
    var _conn, _capture;
    var ConnectionPromise = class {
      constructor(conn) {
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _conn);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _capture);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _conn, conn);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _capture, conn.opts.trace ? Error.captureStackTrace : () => {
        });
      }
      get threadId() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).threadId;
      }
      get info() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).info;
      }
      get prepareCache() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).prepareCache;
      }
      /**
       * Permit to change user during connection.
       * All user variables will be reset, Prepare commands will be released.
       * !!! mysql has a bug when CONNECT_ATTRS capability is set, that is default !!!!
       *
       * @param options   connection options
       * @returns {Promise} promise
       */
      changeUser(options) {
        const param = { opts: options };
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _capture).call(this, param);
        return new Promise((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).changeUser.bind((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), param));
      }
      /**
       * Start transaction
       *
       * @returns {Promise} promise
       */
      beginTransaction() {
        const param = { sql: "START TRANSACTION" };
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _capture).call(this, param);
        return new Promise((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).query.bind((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), param));
      }
      /**
       * Commit a transaction.
       *
       * @returns {Promise} command if commit was needed only
       */
      commit() {
        const param = { sql: "COMMIT" };
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _capture).call(this, param);
        return new Promise((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).changeTransaction.bind((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), param));
      }
      /**
       * Roll back a transaction.
       *
       * @returns {Promise} promise
       */
      rollback() {
        const param = { sql: "ROLLBACK" };
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _capture).call(this, param);
        return new Promise((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).changeTransaction.bind((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), param));
      }
      /**
       * Execute query using text protocol.
       *
       * @param sql     sql parameter Object can be used to supersede default option.
       *                Object must then have sql property.
       * @param values  object / array of placeholder values (not mandatory)
       * @returns {Promise} promise
       */
      query(sql, values) {
        const cmdParam = paramSetter(sql, values);
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _capture).call(this, cmdParam);
        return new Promise((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).query.bind((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), cmdParam));
      }
      static _PARAM_DEF(sql, values) {
        if (typeof sql === "object") {
          return { sql: sql.sql, values: sql.values ? sql.values : values, opts: sql };
        } else return { sql, values };
      }
      execute(sql, values) {
        const cmdParam = paramSetter(sql, values);
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _capture).call(this, cmdParam);
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).prepareExecute(cmdParam);
      }
      static _EXECUTE_CMD(conn, cmdParam) {
        return conn.prepareExecute(cmdParam);
      }
      prepare(sql) {
        let param;
        if (typeof sql === "object") {
          param = { sql: sql.sql, opts: sql };
        } else {
          param = { sql };
        }
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _capture).call(this, param);
        return new Promise((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).prepare.bind((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), param));
      }
      /**
       * Execute batch using text protocol.
       *
       * @param sql     sql parameter Object can be used to supersede default option.
       *                Object must then have sql property.
       * @param values  object / array of placeholder values
       * @returns {Promise} promise
       */
      batch(sql, values) {
        const cmdParam = paramSetter(sql, values);
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _capture).call(this, cmdParam);
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).batch(cmdParam);
      }
      static _BATCH_CMD(conn, cmdParam) {
        return conn.batch(cmdParam);
      }
      /**
       * Import sql file.
       *
       * @param opts JSON array with 2 possible fields: file and database
       */
      importFile(opts) {
        if (!opts || !opts.file) {
          return Promise.reject(
            Errors.createError(
              "SQL file parameter is mandatory",
              Errors.ER_MISSING_SQL_PARAMETER,
              (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).info,
              "HY000",
              null,
              false,
              null
            )
          );
        }
        return new Promise((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).importFile.bind((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), { file: opts.file, database: opts.database }));
      }
      /**
       * Execute query returning a Readable Object that will emit columns/data/end/error events
       * to permit streaming big result-set
       *
       * @param sql     sql parameter Object can be used to supersede default option.
       *                Object must then have sql property.
       * @param values  object / array of placeholder values (not mandatory)
       * @returns {Readable}
       */
      queryStream(sql, values) {
        const cmdParam = paramSetter(sql, values);
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _capture).call(this, cmdParam);
        const cmd = new Stream(cmdParam, (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).opts, (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).socket);
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).opts.logger.error) cmd.on("error", (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).opts.logger.error);
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).addCommand(cmd, true);
        return cmd.inStream;
      }
      /**
       * Send an empty MySQL packet to ensure connection is active, and reset @@wait_timeout
       * @param timeout (optional) timeout value in ms. If reached, throw error and close connection
       * @returns {Promise} promise
       */
      ping(timeout) {
        const cmdParam = {
          opts: { timeout }
        };
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _capture).call(this, cmdParam);
        return new Promise((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).ping.bind((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), cmdParam));
      }
      /**
       * Send a reset command that will
       * - rollback any open transaction
       * - reset transaction isolation level
       * - reset session variables
       * - delete user variables
       * - remove temporary tables
       * - remove all PREPARE statement
       *
       * @returns {Promise} promise
       */
      reset() {
        const cmdParam = {};
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _capture).call(this, cmdParam);
        return new Promise((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).reset.bind((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), cmdParam));
      }
      /**
       * Indicates the state of the connection as the driver knows it
       * @returns {boolean}
       */
      isValid() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).isValid();
      }
      /**
       * Terminate connection gracefully.
       *
       * @returns {Promise} promise
       */
      end() {
        const cmdParam = {};
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _capture).call(this, cmdParam);
        return new Promise((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).end.bind((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), cmdParam));
      }
      /**
       * Alias for destroy.
       */
      close() {
        this.destroy();
      }
      /**
       * Force connection termination by closing the underlying socket and killing server process if any.
       */
      destroy() {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).destroy();
      }
      pause() {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).pause();
      }
      resume() {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).resume();
      }
      format(sql, values) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).format(sql, values);
      }
      /**
       * return current connected server version information.
       *
       * @returns {*}
       */
      serverVersion() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).serverVersion();
      }
      /**
       * Change option "debug" during connection.
       * @param val   debug value
       */
      debug(val) {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).debug(val);
      }
      debugCompress(val) {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).debugCompress(val);
      }
      escape(val) {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).escape(val);
      }
      escapeId(val) {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).escapeId(val);
      }
      //*****************************************************************
      // EventEmitter proxy methods
      //*****************************************************************
      on(eventName, listener) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).on.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), eventName, listener);
        return this;
      }
      off(eventName, listener) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).off.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), eventName, listener);
        return this;
      }
      once(eventName, listener) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).once.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), eventName, listener);
        return this;
      }
      listeners(eventName) {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).listeners.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), eventName);
      }
      addListener(eventName, listener) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).addListener.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), eventName, listener);
        return this;
      }
      eventNames() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).eventNames.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn));
      }
      getMaxListeners() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).getMaxListeners.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn));
      }
      listenerCount(eventName, listener) {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).listenerCount.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), eventName, listener);
      }
      prependListener(eventName, listener) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).prependListener.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), eventName, listener);
        return this;
      }
      prependOnceListener(eventName, listener) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).prependOnceListener.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), eventName, listener);
        return this;
      }
      removeAllListeners(eventName, listener) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).removeAllListeners.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), eventName, listener);
        return this;
      }
      removeListener(eventName, listener) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).removeListener.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), eventName, listener);
        return this;
      }
      setMaxListeners(n) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).setMaxListeners.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), n);
        return this;
      }
      rawListeners(eventName) {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).rawListeners.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), eventName);
      }
      //*****************************************************************
      // internal public testing methods
      //*****************************************************************
      get __tests() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).__tests;
      }
    };
    _conn = /* @__PURE__ */ new WeakMap();
    _capture = /* @__PURE__ */ new WeakMap();
    var paramSetter = function(sql, values) {
      if (typeof sql === "object") {
        return { sql: sql.sql, values: sql.values ? sql.values : values, opts: sql };
      } else return { sql, values };
    };
    module2.exports = ConnectionPromise;
    module2.exports.paramSetter = paramSetter;
  }
});
var require_pool = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/pool.js"(exports, module2) {
    "use strict";
    var { EventEmitter } = (0, import_chunk_WWAWV7DQ.__require)("events");
    var Queue = require_denque();
    var Errors = require_errors();
    var Utils = require_utils();
    var Connection = require_connection();
    var _closed, _connectionInCreation, _errorCreatingConnection, _idleConnections, _activeConnections, _requests, _unusedConnectionRemoverId, _requestTimeoutId, _connErrorNumber, _initialized;
    var Pool = class extends EventEmitter {
      constructor(options) {
        super();
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "opts");
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _closed, false);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _connectionInCreation, false);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _errorCreatingConnection, null);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _idleConnections, new Queue());
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _activeConnections, {});
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _requests, new Queue());
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _unusedConnectionRemoverId);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _requestTimeoutId);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _connErrorNumber, 0);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _initialized, false);
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "_sizeHandlerTimeout");
        this.opts = options;
        this.on("_idle", this._requestsHandler);
        this.on("validateSize", this._sizeHandler);
        this._sizeHandler();
      }
      //*****************************************************************
      // pool automatic handlers
      //*****************************************************************
      _doCreateConnection(resolve, reject, timeoutEnd) {
        this._createConnection(timeoutEnd).then((conn) => {
          if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _closed)) {
            conn.forceEnd(
              null,
              () => {
              },
              () => {
              }
            );
            reject(
              new Errors.createFatalError(
                "Cannot create new connection to pool, pool closed",
                Errors.ER_ADD_CONNECTION_CLOSED_POOL
              )
            );
            return;
          }
          conn.lastUse = Date.now();
          const nativeDestroy = conn.destroy.bind(conn);
          const pool = this;
          conn.destroy = function() {
            pool._endLeak(conn);
            delete (0, import_chunk_WWAWV7DQ.__privateGet)(pool, _activeConnections)[conn.threadId];
            nativeDestroy();
            pool.emit("validateSize");
          };
          conn.once("error", function() {
            let idx = 0;
            let currConn;
            pool._endLeak(conn);
            delete (0, import_chunk_WWAWV7DQ.__privateGet)(pool, _activeConnections)[conn.threadId];
            while (currConn = (0, import_chunk_WWAWV7DQ.__privateGet)(pool, _idleConnections).peekAt(idx)) {
              if (currConn === conn) {
                (0, import_chunk_WWAWV7DQ.__privateGet)(pool, _idleConnections).removeOne(idx);
                continue;
              }
              currConn.lastUse = Math.min(currConn.lastUse, Date.now() - pool.opts.minDelayValidation);
              idx++;
            }
            setTimeout(() => {
              if (!(0, import_chunk_WWAWV7DQ.__privateGet)(pool, _requests).isEmpty()) {
                pool._sizeHandler();
              }
            }, 0);
          });
          (0, import_chunk_WWAWV7DQ.__privateGet)(this, _idleConnections).push(conn);
          (0, import_chunk_WWAWV7DQ.__privateSet)(this, _connectionInCreation, false);
          this.emit("_idle");
          this.emit("connection", conn);
          resolve(conn);
        }).catch((err) => {
          if (err instanceof AggregateError) {
            err = err.errors[0];
          }
          if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _closed) || err.errno && (err.errno === 1524 || err.errno === 1045 || err.errno === 1698) || timeoutEnd < Date.now()) {
            err.message = err.message + this._errorMsgAddon();
            reject(err);
            return;
          }
          setTimeout(this._doCreateConnection.bind(this, resolve, reject, timeoutEnd), 500);
        });
      }
      _destroy(conn) {
        this._endLeak(conn);
        delete (0, import_chunk_WWAWV7DQ.__privateGet)(this, _activeConnections)[conn.threadId];
        conn.lastUse = Date.now();
        conn.forceEnd(
          null,
          () => {
          },
          () => {
          }
        );
        if (this.totalConnections() === 0) {
          this._stopReaping();
        }
        this.emit("validateSize");
      }
      release(conn) {
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _activeConnections)[conn.threadId]) {
          this._endLeak(conn);
          (0, import_chunk_WWAWV7DQ.__privateGet)(this, _activeConnections)[conn.threadId] = null;
          conn.lastUse = Date.now();
          if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _closed)) {
            conn.forceEnd(
              null,
              () => {
              },
              () => {
              }
            );
          } else if (conn.isValid()) {
            this.emit("release", conn);
            (0, import_chunk_WWAWV7DQ.__privateGet)(this, _idleConnections).push(conn);
            process.nextTick(this.emit.bind(this, "_idle"));
          } else {
            this.emit("validateSize");
          }
        }
      }
      _checkLeak(conn) {
        conn.lastUse = Date.now();
        conn.leaked = false;
        conn.leakProcess = setTimeout(
          (conn2) => {
            conn2.leaked = true;
            conn2.opts.logger.warning(
              `A possible connection leak on the thread ${conn2.info.threadId} (the connection not returned to the pool since ${Date.now() - conn2.lastUse} ms). Has the connection.release() been called ?` + this._errorMsgAddon()
            );
          },
          this.opts.leakDetectionTimeout,
          conn
        );
      }
      _endLeak(conn) {
        if (conn.leakProcess) {
          clearTimeout(conn.leakProcess);
          conn.leakProcess = null;
          if (conn.leaked) {
            conn.opts.logger.warning(
              `Previous possible leak connection with thread ${conn.info.threadId} was returned to pool`
            );
          }
        }
      }
      /**
       * Permit to remove idle connection if unused for some time.
       */
      _startReaping() {
        if (!(0, import_chunk_WWAWV7DQ.__privateGet)(this, _unusedConnectionRemoverId) && this.opts.idleTimeout > 0) {
          (0, import_chunk_WWAWV7DQ.__privateSet)(this, _unusedConnectionRemoverId, setInterval(this._reaper.bind(this), 500));
        }
      }
      _stopReaping() {
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _unusedConnectionRemoverId) && this.totalConnections() === 0) {
          clearInterval((0, import_chunk_WWAWV7DQ.__privateGet)(this, _unusedConnectionRemoverId));
        }
      }
      _reaper() {
        const idleTimeRemoval = Date.now() - this.opts.idleTimeout * 1e3;
        let maxRemoval = Math.max(0, (0, import_chunk_WWAWV7DQ.__privateGet)(this, _idleConnections).length - this.opts.minimumIdle);
        while (maxRemoval > 0) {
          const conn = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _idleConnections).peek();
          maxRemoval--;
          if (conn && conn.lastUse < idleTimeRemoval) {
            (0, import_chunk_WWAWV7DQ.__privateGet)(this, _idleConnections).shift();
            conn.forceEnd(
              null,
              () => {
              },
              () => {
              }
            );
            continue;
          }
          break;
        }
        if (this.totalConnections() === 0) {
          this._stopReaping();
        }
        this.emit("validateSize");
      }
      _shouldCreateMoreConnections() {
        return !(0, import_chunk_WWAWV7DQ.__privateGet)(this, _connectionInCreation) && (0, import_chunk_WWAWV7DQ.__privateGet)(this, _idleConnections).length < this.opts.minimumIdle && this.totalConnections() < this.opts.connectionLimit && !(0, import_chunk_WWAWV7DQ.__privateGet)(this, _closed);
      }
      /**
       * Grow pool connections until reaching connection limit.
       */
      _sizeHandler() {
        if (this._shouldCreateMoreConnections() && !this._sizeHandlerTimeout) {
          (0, import_chunk_WWAWV7DQ.__privateSet)(this, _connectionInCreation, true);
          setImmediate(
            function() {
              const timeoutEnd = Date.now() + this.opts.initializationTimeout;
              new Promise((resolve, reject) => {
                this._doCreateConnection(resolve, reject, timeoutEnd);
              }).then(() => {
                (0, import_chunk_WWAWV7DQ.__privateSet)(this, _initialized, true);
                (0, import_chunk_WWAWV7DQ.__privateSet)(this, _errorCreatingConnection, null);
                (0, import_chunk_WWAWV7DQ.__privateSet)(this, _connErrorNumber, 0);
                if (this._shouldCreateMoreConnections()) {
                  this.emit("validateSize");
                }
                this._startReaping();
              }).catch((err) => {
                (0, import_chunk_WWAWV7DQ.__privateSet)(this, _connectionInCreation, false);
                if (!(0, import_chunk_WWAWV7DQ.__privateGet)(this, _closed)) {
                  if (!(0, import_chunk_WWAWV7DQ.__privateGet)(this, _initialized)) {
                    err.message = "Error during pool initialization: " + err.message;
                  } else {
                    err.message = "Pool fails to create connection: " + err.message;
                  }
                  (0, import_chunk_WWAWV7DQ.__privateSet)(this, _errorCreatingConnection, err);
                  this.emit("error", err);
                  this._sizeHandlerTimeout = setTimeout(
                    function() {
                      this._sizeHandlerTimeout = null;
                      if (!(0, import_chunk_WWAWV7DQ.__privateGet)(this, _requests).isEmpty()) {
                        this._sizeHandler();
                      }
                    }.bind(this),
                    Math.min(++(0, import_chunk_WWAWV7DQ.__privateWrapper)(this, _connErrorNumber)._ * 500, 1e4)
                  );
                }
              });
            }.bind(this)
          );
        }
      }
      /**
       * Launch next waiting task request if available connections.
       */
      _requestsHandler() {
        clearTimeout((0, import_chunk_WWAWV7DQ.__privateGet)(this, _requestTimeoutId));
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _requestTimeoutId, null);
        const request = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _requests).shift();
        if (request) {
          const conn = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _idleConnections).shift();
          if (conn) {
            if (this.opts.leakDetectionTimeout > 0) this._checkLeak(conn);
            this.emit("acquire", conn);
            (0, import_chunk_WWAWV7DQ.__privateGet)(this, _activeConnections)[conn.threadId] = conn;
            request.resolver(conn);
          } else {
            (0, import_chunk_WWAWV7DQ.__privateGet)(this, _requests).unshift(request);
          }
          this._requestTimeoutHandler();
        }
      }
      _hasIdleConnection() {
        return !(0, import_chunk_WWAWV7DQ.__privateGet)(this, _idleConnections).isEmpty();
      }
      /**
       * Return an idle Connection.
       * If connection has not been used for some time ( minDelayValidation), validate connection status.
       *
       * @returns {Promise<Connection>} connection of null of no valid idle connection.
       */
      async _doAcquire() {
        if (!this._hasIdleConnection() || (0, import_chunk_WWAWV7DQ.__privateGet)(this, _closed)) return Promise.reject();
        let conn;
        let mustRecheckSize = false;
        while ((conn = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _idleConnections).shift()) != null) {
          if (conn.isValid()) {
            (0, import_chunk_WWAWV7DQ.__privateGet)(this, _activeConnections)[conn.threadId] = conn;
            if (this.opts.minDelayValidation <= 0 || Date.now() - conn.lastUse > this.opts.minDelayValidation) {
              try {
                const cmdParam = {
                  opts: { timeout: this.opts.pingTimeout }
                };
                await new Promise(conn.ping.bind(conn, cmdParam));
              } catch (e) {
                delete (0, import_chunk_WWAWV7DQ.__privateGet)(this, _activeConnections)[conn.threadId];
                continue;
              }
            }
            if (this.opts.leakDetectionTimeout > 0) this._checkLeak(conn);
            if (mustRecheckSize) setImmediate(this.emit.bind(this, "validateSize"));
            return Promise.resolve(conn);
          }
          mustRecheckSize = true;
        }
        setImmediate(this.emit.bind(this, "validateSize"));
        return Promise.reject();
      }
      _requestTimeoutHandler() {
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _requestTimeoutId, null);
        const currTime = Date.now();
        let request;
        while (request = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _requests).peekFront()) {
          if (request.timeout <= currTime) {
            (0, import_chunk_WWAWV7DQ.__privateGet)(this, _requests).shift();
            let cause = this.activeConnections() === 0 ? (0, import_chunk_WWAWV7DQ.__privateGet)(this, _errorCreatingConnection) : null;
            let err = Errors.createError(
              `retrieve connection from pool timeout after ${Math.abs(
                Date.now() - (request.timeout - this.opts.acquireTimeout)
              )}ms${this._errorMsgAddon()}`,
              Errors.ER_GET_CONNECTION_TIMEOUT,
              null,
              "HY000",
              null,
              false,
              request.stack,
              null,
              cause
            );
            request.reject(err);
          } else {
            (0, import_chunk_WWAWV7DQ.__privateSet)(this, _requestTimeoutId, setTimeout(this._requestTimeoutHandler.bind(this), request.timeout - currTime));
            return;
          }
        }
      }
      /**
       * Search info object of an existing connection. to know server type and version.
       * @returns information object if connection available.
       */
      _searchInfo() {
        let info = null;
        let conn = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _idleConnections).get(0);
        if (!conn) {
          for (const threadId in Object.keys((0, import_chunk_WWAWV7DQ.__privateGet)(this, _activeConnections))) {
            conn = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _activeConnections)[threadId];
            if (!conn) {
              break;
            }
          }
        }
        if (conn) {
          info = conn.info;
        }
        return info;
      }
      async _createConnection(timeoutEnd) {
        const minTimeout = Math.max(1, timeoutEnd - 100);
        const connectionOpts = !this.opts.connOptions.connectTimeout || this.opts.connOptions.connectTimeout > minTimeout ? Object.assign({}, this.opts.connOptions, { connectTimeout: minTimeout }) : this.opts.connOptions;
        const conn = new Connection(connectionOpts);
        await conn.connect();
        const pool = this;
        conn.forceEnd = conn.end;
        conn.release = function(resolve) {
          if ((0, import_chunk_WWAWV7DQ.__privateGet)(pool, _closed) || !conn.isValid()) {
            pool._destroy(conn);
            resolve();
            return;
          }
          if (pool.opts.noControlAfterUse) {
            pool.release(conn);
            resolve();
            return;
          }
          let revertFunction;
          if (pool.opts.resetAfterUse && conn.info.isMariaDB() && (conn.info.serverVersion.minor === 2 && conn.info.hasMinVersion(10, 2, 22) || conn.info.hasMinVersion(10, 3, 13))) {
            revertFunction = conn.reset.bind(conn, {});
          } else revertFunction = conn.changeTransaction.bind(conn, { sql: "ROLLBACK" });
          new Promise(revertFunction).then(pool.release.bind(pool, conn), pool._destroy.bind(pool, conn)).finally(resolve);
        };
        conn.end = conn.release;
        return conn;
      }
      _leakedConnections() {
        let counter = 0;
        for (const connection of Object.values((0, import_chunk_WWAWV7DQ.__privateGet)(this, _activeConnections))) {
          if (connection && connection.leaked) counter++;
        }
        return counter;
      }
      _errorMsgAddon() {
        if (this.opts.leakDetectionTimeout > 0) {
          return `
    (pool connections: active=${this.activeConnections()} idle=${this.idleConnections()} leak=${this._leakedConnections()} limit=${this.opts.connectionLimit})`;
        }
        return `
    (pool connections: active=${this.activeConnections()} idle=${this.idleConnections()} limit=${this.opts.connectionLimit})`;
      }
      toString() {
        return `active=${this.activeConnections()} idle=${this.idleConnections()} limit=${this.opts.connectionLimit}`;
      }
      //*****************************************************************
      // public methods
      //*****************************************************************
      get closed() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _closed);
      }
      /**
       * Get current total connection number.
       * @return {number}
       */
      totalConnections() {
        return this.activeConnections() + this.idleConnections();
      }
      /**
       * Get current active connections.
       * @return {number}
       */
      activeConnections() {
        let counter = 0;
        for (const connection of Object.values((0, import_chunk_WWAWV7DQ.__privateGet)(this, _activeConnections))) {
          if (connection) counter++;
        }
        return counter;
      }
      /**
       * Get current idle connection number.
       * @return {number}
       */
      idleConnections() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _idleConnections).length;
      }
      /**
       * Get current stacked connection request.
       * @return {number}
       */
      taskQueueSize() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _requests).length;
      }
      escape(value) {
        return Utils.escape(this.opts.connOptions, this._searchInfo(), value);
      }
      escapeId(value) {
        return Utils.escapeId(this.opts.connOptions, this._searchInfo(), value);
      }
      //*****************************************************************
      // promise methods
      //*****************************************************************
      /**
       * Retrieve a connection from pool.
       * Create a new one, if limit is not reached.
       * wait until acquireTimeout.
       * @param cmdParam for stackTrace error
       * @return {Promise}
       */
      getConnection(cmdParam) {
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _closed)) {
          return Promise.reject(
            Errors.createError(
              "pool is closed",
              Errors.ER_POOL_ALREADY_CLOSED,
              null,
              "HY000",
              cmdParam === null ? null : cmdParam.sql,
              false,
              cmdParam.stack
            )
          );
        }
        return this._doAcquire().then(
          (conn) => {
            this.emit("acquire", conn);
            return conn;
          },
          () => {
            if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _closed)) {
              throw Errors.createError(
                "Cannot add request to pool, pool is closed",
                Errors.ER_POOL_ALREADY_CLOSED,
                null,
                "HY000",
                cmdParam === null ? null : cmdParam.sql,
                false,
                cmdParam.stack
              );
            }
            setImmediate(this.emit.bind(this, "validateSize"));
            return new Promise(
              function(resolver, rejecter) {
                setImmediate(this.emit.bind(this, "enqueue"));
                const request = new Request(Date.now() + this.opts.acquireTimeout, cmdParam.stack, resolver, rejecter);
                (0, import_chunk_WWAWV7DQ.__privateGet)(this, _requests).push(request);
                if (!(0, import_chunk_WWAWV7DQ.__privateGet)(this, _requestTimeoutId)) {
                  (0, import_chunk_WWAWV7DQ.__privateSet)(this, _requestTimeoutId, setTimeout(this._requestTimeoutHandler.bind(this), this.opts.acquireTimeout));
                }
              }.bind(this)
            );
          }
        );
      }
      /**
       * Close all connection in pool
       * Ends in multiple step :
       * - close idle connections
       * - ensure that no new request is possible
       *   (active connection release are automatically closed on release)
       * - if remaining, after 10 seconds, close remaining active connections
       *
       * @return Promise
       */
      end() {
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _closed)) {
          return Promise.reject(Errors.createError("pool is already closed", Errors.ER_POOL_ALREADY_CLOSED));
        }
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _closed, true);
        clearInterval((0, import_chunk_WWAWV7DQ.__privateGet)(this, _unusedConnectionRemoverId));
        clearInterval(this._sizeHandlerTimeout);
        const cmdParam = {};
        if (this.opts.trace) Error.captureStackTrace(cmdParam);
        const idleConnectionsEndings = [];
        let conn;
        while (conn = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _idleConnections).shift()) {
          idleConnectionsEndings.push(new Promise(conn.forceEnd.bind(conn, cmdParam)));
        }
        clearTimeout((0, import_chunk_WWAWV7DQ.__privateGet)(this, _requestTimeoutId));
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _requestTimeoutId, null);
        if (!(0, import_chunk_WWAWV7DQ.__privateGet)(this, _requests).isEmpty()) {
          const err = Errors.createError(
            "pool is ending, connection request aborted",
            Errors.ER_CLOSING_POOL,
            null,
            "HY000",
            null,
            false,
            cmdParam.stack
          );
          let task;
          while (task = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _requests).shift()) {
            task.reject(err);
          }
        }
        const pool = this;
        return Promise.all(idleConnectionsEndings).then(async () => {
          if (pool.activeConnections() > 0) {
            let remaining = 100;
            while (remaining-- > 0) {
              if (pool.activeConnections() > 0) {
                await new Promise((res) => setTimeout(() => res(), 100));
              }
            }
            for (const connection of Object.values((0, import_chunk_WWAWV7DQ.__privateGet)(pool, _activeConnections))) {
              if (connection) connection.destroy();
            }
          }
          return Promise.resolve();
        });
      }
    };
    _closed = /* @__PURE__ */ new WeakMap();
    _connectionInCreation = /* @__PURE__ */ new WeakMap();
    _errorCreatingConnection = /* @__PURE__ */ new WeakMap();
    _idleConnections = /* @__PURE__ */ new WeakMap();
    _activeConnections = /* @__PURE__ */ new WeakMap();
    _requests = /* @__PURE__ */ new WeakMap();
    _unusedConnectionRemoverId = /* @__PURE__ */ new WeakMap();
    _requestTimeoutId = /* @__PURE__ */ new WeakMap();
    _connErrorNumber = /* @__PURE__ */ new WeakMap();
    _initialized = /* @__PURE__ */ new WeakMap();
    var Request = class {
      constructor(timeout, stack, resolver, rejecter) {
        this.timeout = timeout;
        this.stack = stack;
        this.resolver = resolver;
        this.rejecter = rejecter;
      }
      reject(err) {
        process.nextTick(this.rejecter, err);
      }
    };
    module2.exports = Pool;
  }
});
var require_pool_promise = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/pool-promise.js"(exports, module2) {
    "use strict";
    var { EventEmitter } = (0, import_chunk_WWAWV7DQ.__require)("events");
    var Pool = require_pool();
    var ConnectionPromise = require_connection_promise();
    var Errors = require_errors();
    var _pool;
    var PoolPromise = class extends EventEmitter {
      constructor(options) {
        super();
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _pool);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _pool, new Pool(options));
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).on("acquire", this.emit.bind(this, "acquire"));
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).on("connection", this.emit.bind(this, "connection"));
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).on("enqueue", this.emit.bind(this, "enqueue"));
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).on("release", this.emit.bind(this, "release"));
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).on("error", this.emit.bind(this, "error"));
      }
      get closed() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).closed;
      }
      /**
       * Get current total connection number.
       * @return {number}
       */
      totalConnections() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).totalConnections();
      }
      /**
       * Get current active connections.
       * @return {number}
       */
      activeConnections() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).activeConnections();
      }
      /**
       * Get current idle connection number.
       * @return {number}
       */
      idleConnections() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).idleConnections();
      }
      /**
       * Get current stacked connection request.
       * @return {number}
       */
      taskQueueSize() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).taskQueueSize();
      }
      escape(value) {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).escape(value);
      }
      escapeId(value) {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).escapeId(value);
      }
      /**
       * Ends pool
       *
       * @return Promise
       **/
      end() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).end();
      }
      /**
       * Retrieve a connection from pool.
       * Create a new one, if limit is not reached.
       * wait until acquireTimeout.
       *
       */
      async getConnection() {
        const cmdParam = {};
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).opts.connOptions.trace) Error.captureStackTrace(cmdParam);
        const baseConn = await (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).getConnection(cmdParam);
        const conn = new ConnectionPromise(baseConn);
        conn.release = () => new Promise(baseConn.release);
        conn.end = conn.release;
        conn.close = conn.release;
        return conn;
      }
      /**
       * Execute query using text protocol with callback emit columns/data/end/error
       * events to permit streaming big result-set
       *
       * @param sql     sql parameter Object can be used to supersede default option.
       *                Object must then have sql property.
       * @param values  object / array of placeholder values (not mandatory)
       */
      query(sql, values) {
        const cmdParam = ConnectionPromise.paramSetter(sql, values);
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).opts.connOptions.trace) Error.captureStackTrace(cmdParam);
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).getConnection(cmdParam).then((baseConn) => {
          return new Promise(baseConn.query.bind(baseConn, cmdParam)).finally(() => {
            (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).release(baseConn);
          });
        });
      }
      /**
       * Execute query using binary protocol with callback emit columns/data/end/error
       * events to permit streaming big result-set
       *
       * @param sql     sql parameter Object can be used to supersede default option.
       *                Object must then have sql property.
       * @param values  object / array of placeholder values (not mandatory)
       */
      execute(sql, values) {
        const cmdParam = ConnectionPromise.paramSetter(sql, values);
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).opts.connOptions.trace) Error.captureStackTrace(cmdParam);
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).getConnection(cmdParam).then((baseConn) => {
          return ConnectionPromise._EXECUTE_CMD(baseConn, cmdParam).finally(() => {
            (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).release(baseConn);
          });
        });
      }
      /**
       * execute a batch
       *
       * @param sql     sql parameter Object can be used to supersede default option.
       *                Object must then have sql property.
       * @param values  array of placeholder values
       */
      batch(sql, values) {
        const cmdParam = ConnectionPromise.paramSetter(sql, values);
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).opts.connOptions.trace) Error.captureStackTrace(cmdParam);
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).getConnection(cmdParam).then((baseConn) => {
          return ConnectionPromise._BATCH_CMD(baseConn, cmdParam).finally(() => {
            (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).release(baseConn);
          });
        });
      }
      /**
       * Import sql file.
       *
       * @param opts JSON array with 2 possible fields: file and database
       */
      importFile(opts) {
        if (!opts) {
          return Promise.reject(
            Errors.createError(
              "SQL file parameter is mandatory",
              Errors.ER_MISSING_SQL_PARAMETER,
              null,
              "HY000",
              null,
              false,
              null
            )
          );
        }
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).getConnection({}).then((baseConn) => {
          return new Promise(baseConn.importFile.bind(baseConn, { file: opts.file, database: opts.database })).finally(
            () => {
              (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).release(baseConn);
            }
          );
        });
      }
      toString() {
        return "poolPromise(" + (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).toString() + ")";
      }
    };
    _pool = /* @__PURE__ */ new WeakMap();
    module2.exports = PoolPromise;
  }
});
var require_cluster_options = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/config/cluster-options.js"(exports, module2) {
    "use strict";
    var ClusterOptions = class {
      constructor(opts) {
        if (opts) {
          this.canRetry = opts.canRetry === void 0 ? true : opts.canRetry;
          this.removeNodeErrorCount = opts.removeNodeErrorCount || Infinity;
          this.restoreNodeTimeout = opts.restoreNodeTimeout || 1e3;
          this.defaultSelector = opts.defaultSelector || "RR";
        } else {
          this.canRetry = true;
          this.removeNodeErrorCount = Infinity;
          this.restoreNodeTimeout = 1e3;
          this.defaultSelector = "RR";
        }
      }
    };
    module2.exports = ClusterOptions;
  }
});
var require_pool_options = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/config/pool-options.js"(exports, module2) {
    "use strict";
    var ConnOptions = require_connection_options();
    var PoolOptions = class {
      constructor(opts) {
        if (typeof opts === "string") {
          opts = ConnOptions.parse(opts);
          if (opts.acquireTimeout) opts.acquireTimeout = parseInt(opts.acquireTimeout);
          if (opts.connectionLimit) opts.connectionLimit = parseInt(opts.connectionLimit);
          if (opts.idleTimeout) opts.idleTimeout = parseInt(opts.idleTimeout);
          if (opts.leakDetectionTimeout) opts.leakDetectionTimeout = parseInt(opts.leakDetectionTimeout);
          if (opts.initializationTimeout) opts.initializationTimeout = parseInt(opts.initializationTimeout);
          if (opts.minDelayValidation) opts.minDelayValidation = parseInt(opts.minDelayValidation);
          if (opts.minimumIdle) opts.minimumIdle = parseInt(opts.minimumIdle);
          if (opts.noControlAfterUse) opts.noControlAfterUse = opts.noControlAfterUse === "true";
          if (opts.resetAfterUse) opts.resetAfterUse = opts.resetAfterUse === "true";
          if (opts.pingTimeout) opts.pingTimeout = parseInt(opts.pingTimeout);
        }
        this.acquireTimeout = opts.acquireTimeout === void 0 ? 1e4 : opts.acquireTimeout;
        this.connectionLimit = opts.connectionLimit === void 0 ? 10 : opts.connectionLimit;
        this.idleTimeout = opts.idleTimeout === void 0 ? 1800 : opts.idleTimeout;
        this.leakDetectionTimeout = opts.leakDetectionTimeout || 0;
        this.initializationTimeout = opts.initializationTimeout === void 0 ? Math.max(100, this.acquireTimeout - 100) : opts.initializationTimeout;
        this.minDelayValidation = opts.minDelayValidation === void 0 ? 500 : opts.minDelayValidation;
        this.minimumIdle = opts.minimumIdle === void 0 ? this.connectionLimit : Math.min(opts.minimumIdle, this.connectionLimit);
        this.noControlAfterUse = opts.noControlAfterUse || false;
        this.resetAfterUse = opts.resetAfterUse || false;
        this.pingTimeout = opts.pingTimeout || 250;
        this.connOptions = new ConnOptions(opts);
        if (this.acquireTimeout > 0 && this.connOptions.connectTimeout > this.acquireTimeout) {
          this.connOptions.connectTimeout = this.acquireTimeout;
        }
      }
    };
    module2.exports = PoolOptions;
  }
});
var require_connection_callback = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/connection-callback.js"(exports, module2) {
    "use strict";
    var Errors = require_errors();
    var { Status } = require_connection_status();
    var Query = require_query();
    var _conn, _noop;
    var _ConnectionCallback = class _ConnectionCallback2 {
      constructor(conn) {
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _conn);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _noop, () => {
        });
        (0, import_chunk_WWAWV7DQ.__publicField)(this, "release", (cb) => {
          (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).release(() => {
            if (cb) cb();
          });
        });
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _conn, conn);
      }
      get threadId() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).info ? (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).info.threadId : null;
      }
      get info() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).info;
      }
      /**
       * Permit to change user during connection.
       * All user variables will be reset, Prepare commands will be released.
       * !!! mysql has a bug when CONNECT_ATTRS capability is set, that is default !!!!
       *
       * @param options   connection options
       * @param callback  callback function
       */
      changeUser(options, callback) {
        let _options, _cb;
        if (typeof options === "function") {
          _cb = options;
          _options = void 0;
        } else {
          _options = options;
          _cb = callback;
        }
        const cmdParam = {
          opts: _options,
          callback: _cb
        };
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).opts.trace) Error.captureStackTrace(cmdParam);
        new Promise((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).changeUser.bind((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), cmdParam)).then(() => {
          if (cmdParam.callback) cmdParam.callback(null, null, null);
        }).catch(cmdParam.callback || (0, import_chunk_WWAWV7DQ.__privateGet)(this, _noop));
      }
      /**
       * Start transaction
       *
       * @param callback  callback function
       */
      beginTransaction(callback) {
        this.query("START TRANSACTION", null, callback);
      }
      /**
       * Commit a transaction.
       *
       * @param callback  callback function
       */
      commit(callback) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).changeTransaction(
          { sql: "COMMIT" },
          () => {
            if (callback) callback(null, null, null);
          },
          callback || (0, import_chunk_WWAWV7DQ.__privateGet)(this, _noop)
        );
      }
      /**
       * Roll back a transaction.
       *
       * @param callback  callback function
       */
      rollback(callback) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).changeTransaction(
          { sql: "ROLLBACK" },
          () => {
            if (callback) callback(null, null, null);
          },
          callback || (0, import_chunk_WWAWV7DQ.__privateGet)(this, _noop)
        );
      }
      /**
       * Execute query using text protocol with callback emit columns/data/end/error
       * events to permit streaming big result-set
       *
       * @param sql     sql parameter Object can be used to supersede default option.
       *                Object must then have sql property.
       * @param values  object / array of placeholder values (not mandatory)
       * @param callback  callback function
       */
      query(sql, values, callback) {
        const cmdParam = _ConnectionCallback2._PARAM((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).opts, sql, values, callback);
        return _ConnectionCallback2._QUERY_CMD((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), cmdParam);
      }
      static _QUERY_CMD(conn, cmdParam) {
        let cmd;
        if (cmdParam.callback) {
          cmdParam.opts = cmdParam.opts ? Object.assign(cmdParam.opts, { metaAsArray: true }) : { metaAsArray: true };
          cmd = new Query(
            ([rows, meta]) => {
              cmdParam.callback(null, rows, meta);
            },
            cmdParam.callback,
            conn.opts,
            cmdParam
          );
        } else {
          cmd = new Query(
            () => {
            },
            () => {
            },
            conn.opts,
            cmdParam
          );
        }
        cmd.handleNewRows = (row) => {
          cmd._rows[cmd._responseIndex].push(row);
          cmd.emit("data", row);
        };
        conn.addCommand(cmd, true);
        cmd.stream = (opt) => cmd._stream(conn.socket, opt);
        return cmd;
      }
      execute(sql, values, callback) {
        const cmdParam = _ConnectionCallback2._PARAM((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).opts, sql, values, callback);
        cmdParam.opts = cmdParam.opts ? Object.assign(cmdParam.opts, { metaAsArray: true }) : { metaAsArray: true };
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).prepareExecute(cmdParam).then(([rows, meta]) => {
          if (cmdParam.callback) {
            cmdParam.callback(null, rows, meta);
          }
        }).catch((err) => {
          if (cmdParam.callback) {
            cmdParam.callback(err);
          }
        });
      }
      static _PARAM(options, sql, values, callback) {
        let _cmdOpt, _sql, _values = values, _cb = callback;
        if (typeof values === "function") {
          _cb = values;
          _values = void 0;
        }
        if (typeof sql === "object") {
          _cmdOpt = sql;
          _sql = _cmdOpt.sql;
          if (_cmdOpt.values) _values = _cmdOpt.values;
        } else {
          _sql = sql;
        }
        const cmdParam = {
          sql: _sql,
          values: _values,
          opts: _cmdOpt,
          callback: _cb
        };
        if (options.trace) Error.captureStackTrace(cmdParam, _ConnectionCallback2._PARAM);
        return cmdParam;
      }
      static _EXECUTE_CMD(conn, cmdParam) {
        new Promise(conn.prepare.bind(conn, cmdParam)).then((prepare) => {
          const opts = cmdParam.opts ? Object.assign(cmdParam.opts, { metaAsArray: true }) : { metaAsArray: true };
          return prepare.execute(cmdParam.values, opts, null, cmdParam.stack).then(([rows, meta]) => {
            if (cmdParam.callback) {
              cmdParam.callback(null, rows, meta);
            }
          }).finally(() => prepare.close());
        }).catch((err) => {
          if (conn.opts.logger.error) conn.opts.logger.error(err);
          if (cmdParam.callback) cmdParam.callback(err);
        });
      }
      prepare(sql, callback) {
        let _cmdOpt, _sql;
        if (typeof sql === "object") {
          _cmdOpt = sql;
          _sql = _cmdOpt.sql;
        } else {
          _sql = sql;
        }
        const cmdParam = {
          sql: _sql,
          opts: _cmdOpt,
          callback
        };
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).opts.trace) Error.captureStackTrace(cmdParam);
        return new Promise((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).prepare.bind((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), cmdParam)).then((prepare) => {
          if (callback) callback(null, prepare, null);
        }).catch(callback || (0, import_chunk_WWAWV7DQ.__privateGet)(this, _noop));
      }
      /**
       * Execute a batch
       * events to permit streaming big result-set
       *
       * @param sql     sql parameter Object can be used to supersede default option.
       *                Object must then have sql property.
       * @param values  object / array of placeholder values (not mandatory)
       * @param callback callback
       */
      batch(sql, values, callback) {
        const cmdParam = _ConnectionCallback2._PARAM((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).opts, sql, values, callback);
        return _ConnectionCallback2._BATCH_CMD((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), cmdParam);
      }
      static _BATCH_CMD(conn, cmdParam) {
        conn.batch(cmdParam).then((res) => {
          if (cmdParam.callback) cmdParam.callback(null, res);
        }).catch((err) => {
          if (cmdParam.callback) cmdParam.callback(err);
        });
      }
      /**
       * Import sql file.
       *
       * @param opts JSON array with 2 possible fields: file and database
       * @param cb callback
       */
      importFile(opts, cb) {
        if (!opts || !opts.file) {
          if (cb)
            cb(
              Errors.createError(
                "SQL file parameter is mandatory",
                Errors.ER_MISSING_SQL_PARAMETER,
                (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).info,
                "HY000",
                null,
                false,
                null
              )
            );
          return;
        }
        new Promise((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).importFile.bind((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), { file: opts.file, database: opts.database })).then(() => {
          if (cb) cb();
        }).catch((err) => {
          if (cb) cb(err);
        });
      }
      /**
       * Send an empty MySQL packet to ensure connection is active, and reset @@wait_timeout
       * @param timeout (optional) timeout value in ms. If reached, throw error and close connection
       * @param callback callback
       */
      ping(timeout, callback) {
        let _cmdOpt = {}, _cb;
        if (typeof timeout === "function") {
          _cb = timeout;
        } else {
          _cmdOpt.timeout = timeout;
          _cb = callback;
        }
        const cmdParam = {
          opts: _cmdOpt,
          callback: _cb
        };
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).opts.trace) Error.captureStackTrace(cmdParam);
        new Promise((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).ping.bind((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), cmdParam)).then(_cb || (0, import_chunk_WWAWV7DQ.__privateGet)(this, _noop)).catch(_cb || (0, import_chunk_WWAWV7DQ.__privateGet)(this, _noop));
      }
      /**
       * Send a reset command that will
       * - rollback any open transaction
       * - reset transaction isolation level
       * - reset session variables
       * - delete user variables
       * - remove temporary tables
       * - remove all PREPARE statement
       *
       * @param callback callback
       */
      reset(callback) {
        const cmdParam = {};
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).opts.trace) Error.captureStackTrace(cmdParam);
        return new Promise((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).reset.bind((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), cmdParam)).then(callback || (0, import_chunk_WWAWV7DQ.__privateGet)(this, _noop)).catch(callback || (0, import_chunk_WWAWV7DQ.__privateGet)(this, _noop));
      }
      /**
       * Indicates the state of the connection as the driver knows it
       * @returns {boolean}
       */
      isValid() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).isValid();
      }
      /**
       * Terminate connection gracefully.
       *
       * @param callback callback
       */
      end(callback) {
        const cmdParam = {};
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).opts.trace) Error.captureStackTrace(cmdParam);
        new Promise((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).end.bind((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), cmdParam)).then(() => {
          if (callback) callback();
        }).catch(callback || (0, import_chunk_WWAWV7DQ.__privateGet)(this, _noop));
      }
      /**
       * Alias for destroy.
       */
      close() {
        this.destroy();
      }
      /**
       * Force connection termination by closing the underlying socket and killing server process if any.
       */
      destroy() {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).destroy();
      }
      pause() {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).pause();
      }
      resume() {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).resume();
      }
      format(sql, values) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).format(sql, values);
      }
      /**
       * return current connected server version information.
       *
       * @returns {*}
       */
      serverVersion() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).serverVersion();
      }
      /**
       * Change option "debug" during connection.
       * @param val   debug value
       */
      debug(val) {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).debug(val);
      }
      debugCompress(val) {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).debugCompress(val);
      }
      escape(val) {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).escape(val);
      }
      escapeId(val) {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).escapeId(val);
      }
      //*****************************************************************
      // internal public testing methods
      //*****************************************************************
      get __tests() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).__tests;
      }
      connect(callback) {
        if (!callback) {
          throw new Errors.createError(
            "missing mandatory callback parameter",
            Errors.ER_MISSING_PARAMETER,
            (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).info
          );
        }
        switch ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).status) {
          case Status.NOT_CONNECTED:
          case Status.CONNECTING:
          case Status.AUTHENTICATING:
          case Status.INIT_CMD:
            this.once("connect", callback);
            break;
          case Status.CONNECTED:
            callback.call(this);
            break;
          case Status.CLOSING:
          case Status.CLOSED:
            callback.call(
              this,
              Errors.createError(
                "Connection closed",
                Errors.ER_CONNECTION_ALREADY_CLOSED,
                (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).info,
                "08S01",
                null,
                true
              )
            );
            break;
        }
      }
      //*****************************************************************
      // EventEmitter proxy methods
      //*****************************************************************
      on(eventName, listener) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).on.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), eventName, listener);
        return this;
      }
      off(eventName, listener) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).off.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), eventName, listener);
        return this;
      }
      once(eventName, listener) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).once.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), eventName, listener);
        return this;
      }
      listeners(eventName) {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).listeners.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), eventName);
      }
      addListener(eventName, listener) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).addListener.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), eventName, listener);
        return this;
      }
      eventNames() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).eventNames.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn));
      }
      getMaxListeners() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).getMaxListeners.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn));
      }
      listenerCount(eventName, listener) {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).listenerCount.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), eventName, listener);
      }
      prependListener(eventName, listener) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).prependListener.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), eventName, listener);
        return this;
      }
      prependOnceListener(eventName, listener) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).prependOnceListener.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), eventName, listener);
        return this;
      }
      removeAllListeners(eventName, listener) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).removeAllListeners.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), eventName, listener);
        return this;
      }
      removeListener(eventName, listener) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).removeListener.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), eventName, listener);
        return this;
      }
      setMaxListeners(n) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).setMaxListeners.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), n);
        return this;
      }
      rawListeners(eventName) {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn).rawListeners.call((0, import_chunk_WWAWV7DQ.__privateGet)(this, _conn), eventName);
      }
    };
    _conn = /* @__PURE__ */ new WeakMap();
    _noop = /* @__PURE__ */ new WeakMap();
    var ConnectionCallback = _ConnectionCallback;
    module2.exports = ConnectionCallback;
  }
});
var require_pool_callback = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/pool-callback.js"(exports, module2) {
    "use strict";
    var { EventEmitter } = (0, import_chunk_WWAWV7DQ.__require)("events");
    var Pool = require_pool();
    var Errors = require_errors();
    var ConnectionCallback = require_connection_callback();
    var _pool, _noop;
    var PoolCallback = class extends EventEmitter {
      constructor(options) {
        super();
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _pool);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _noop, () => {
        });
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _pool, new Pool(options));
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).on("acquire", this.emit.bind(this, "acquire"));
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).on("connection", this.emit.bind(this, "connection"));
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).on("enqueue", this.emit.bind(this, "enqueue"));
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).on("release", this.emit.bind(this, "release"));
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).on("error", this.emit.bind(this, "error"));
      }
      get closed() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).closed;
      }
      /**
       * Get current total connection number.
       * @return {number}
       */
      totalConnections() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).totalConnections();
      }
      /**
       * Get current active connections.
       * @return {number}
       */
      activeConnections() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).activeConnections();
      }
      /**
       * Get current idle connection number.
       * @return {number}
       */
      idleConnections() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).idleConnections();
      }
      /**
       * Get current stacked connection request.
       * @return {number}
       */
      taskQueueSize() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).taskQueueSize();
      }
      escape(value) {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).escape(value);
      }
      escapeId(value) {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).escapeId(value);
      }
      /**
       * Ends pool
       *
       * @param callback
       */
      end(callback) {
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).end().then(() => {
          if (callback) callback(null);
        }).catch(callback || (0, import_chunk_WWAWV7DQ.__privateGet)(this, _noop));
      }
      /**
       * Retrieve a connection from pool.
       * Create a new one, if limit is not reached.
       * wait until acquireTimeout.
       *
       * @param cb callback
       */
      getConnection(cb) {
        if (!cb) {
          throw new Errors.createError("missing mandatory callback parameter", Errors.ER_MISSING_PARAMETER);
        }
        const cmdParam = {};
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).opts.connOptions.trace) Error.captureStackTrace(cmdParam);
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).getConnection(cmdParam).then((baseConn) => {
          const cc = new ConnectionCallback(baseConn);
          cc.end = (cb2) => cc.release(cb2);
          cc.close = (cb2) => cc.release(cb2);
          cb(null, cc);
        }).catch(cb);
      }
      /**
       * Execute query using text protocol with callback emit columns/data/end/error
       * events to permit streaming big result-set
       *
       * @param sql     sql parameter Object can be used to supersede default option.
       *                Object must then have sql property.
       * @param values  object / array of placeholder values (not mandatory)
       * @param cb      callback
       */
      query(sql, values, cb) {
        const cmdParam = ConnectionCallback._PARAM((0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).opts.connOptions, sql, values, cb);
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).getConnection(cmdParam).then((baseConn) => {
          const _cb = cmdParam.callback;
          cmdParam.callback = (err, rows, meta) => {
            (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).release(baseConn);
            if (_cb) _cb(err, rows, meta);
          };
          ConnectionCallback._QUERY_CMD(baseConn, cmdParam);
        }).catch((err) => {
          if (cmdParam.callback) cmdParam.callback(err);
        });
      }
      /**
       * Execute query using binary protocol with callback emit columns/data/end/error
       * events to permit streaming big result-set
       *
       * @param sql     sql parameter Object can be used to supersede default option.
       *                Object must then have sql property.
       * @param values  object / array of placeholder values (not mandatory)
       * @param cb      callback
       */
      execute(sql, values, cb) {
        const cmdParam = ConnectionCallback._PARAM((0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).opts.connOptions, sql, values, cb);
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).getConnection(cmdParam).then((baseConn) => {
          const _cb = cmdParam.callback;
          cmdParam.callback = (err, rows, meta) => {
            (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).release(baseConn);
            if (_cb) _cb(err, rows, meta);
          };
          ConnectionCallback._EXECUTE_CMD(baseConn, cmdParam);
        }).catch((err) => {
          if (cmdParam.callback) cmdParam.callback(err);
        });
      }
      /**
       * execute a batch
       *
       * @param sql     sql parameter Object can be used to supersede default option.
       *                Object must then have sql property.
       * @param values  array of placeholder values
       * @param cb      callback
       */
      batch(sql, values, cb) {
        const cmdParam = ConnectionCallback._PARAM((0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).opts.connOptions, sql, values, cb);
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).getConnection(cmdParam).then((baseConn) => {
          const _cb = cmdParam.callback;
          cmdParam.callback = (err, rows, meta) => {
            (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).release(baseConn);
            if (_cb) _cb(err, rows, meta);
          };
          ConnectionCallback._BATCH_CMD(baseConn, cmdParam);
        }).catch((err) => {
          if (cmdParam.callback) cmdParam.callback(err);
        });
      }
      /**
       * Import sql file.
       *
       * @param opts JSON array with 2 possible fields: file and database
       * @param cb callback
       */
      importFile(opts, cb) {
        if (!opts) {
          if (cb)
            cb(
              Errors.createError(
                "SQL file parameter is mandatory",
                Errors.ER_MISSING_SQL_PARAMETER,
                null,
                "HY000",
                null,
                false,
                null
              )
            );
          return;
        }
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).getConnection({}).then((baseConn) => {
          return new Promise(baseConn.importFile.bind(baseConn, { file: opts.file, database: opts.database })).finally(
            () => {
              (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).release(baseConn);
            }
          );
        }).then(() => {
          if (cb) cb();
        }).catch((err) => {
          if (cb) cb(err);
        });
      }
      toString() {
        return "poolCallback(" + (0, import_chunk_WWAWV7DQ.__privateGet)(this, _pool).toString() + ")";
      }
    };
    _pool = /* @__PURE__ */ new WeakMap();
    _noop = /* @__PURE__ */ new WeakMap();
    module2.exports = PoolCallback;
  }
});
var require_filtered_cluster = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/filtered-cluster.js"(exports, module2) {
    "use strict";
    var _cluster, _pattern, _selector;
    var FilteredCluster = class {
      constructor(poolCluster, patternArg, selectorArg) {
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _cluster);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _pattern);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _selector);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _cluster, poolCluster);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _pattern, patternArg);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _selector, selectorArg);
      }
      /**
       * Get a connection according to previously indicated pattern and selector.
       *
       * @return {Promise}
       */
      getConnection() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _cluster).getConnection((0, import_chunk_WWAWV7DQ.__privateGet)(this, _pattern), (0, import_chunk_WWAWV7DQ.__privateGet)(this, _selector));
      }
      /**
       * Execute a text query on one connection from available pools matching pattern
       * in cluster.
       *
       * @param sql   sql command
       * @param value parameter value of sql command (not mandatory)
       * @return {Promise}
       */
      query(sql, value) {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _cluster).getConnection((0, import_chunk_WWAWV7DQ.__privateGet)(this, _pattern), (0, import_chunk_WWAWV7DQ.__privateGet)(this, _selector)).then((conn) => {
          return conn.query(sql, value).then((res) => {
            conn.release();
            return res;
          }).catch((err) => {
            conn.release();
            return Promise.reject(err);
          });
        }).catch((err) => {
          return Promise.reject(err);
        });
      }
      /**
       * Execute a binary query on one connection from available pools matching pattern
       * in cluster.
       *
       * @param sql   sql command
       * @param value parameter value of sql command (not mandatory)
       * @return {Promise}
       */
      execute(sql, value) {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _cluster).getConnection((0, import_chunk_WWAWV7DQ.__privateGet)(this, _pattern), (0, import_chunk_WWAWV7DQ.__privateGet)(this, _selector)).then((conn) => {
          return conn.execute(sql, value).then((res) => {
            conn.release();
            return res;
          }).catch((err) => {
            conn.release();
            return Promise.reject(err);
          });
        }).catch((err) => {
          return Promise.reject(err);
        });
      }
      /**
       * Execute a batch on one connection from available pools matching pattern
       * in cluster.
       *
       * @param sql   sql command
       * @param value parameter value of sql command
       * @return {Promise}
       */
      batch(sql, value) {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _cluster).getConnection((0, import_chunk_WWAWV7DQ.__privateGet)(this, _pattern), (0, import_chunk_WWAWV7DQ.__privateGet)(this, _selector)).then((conn) => {
          return conn.batch(sql, value).then((res) => {
            conn.release();
            return res;
          }).catch((err) => {
            conn.release();
            return Promise.reject(err);
          });
        }).catch((err) => {
          return Promise.reject(err);
        });
      }
    };
    _cluster = /* @__PURE__ */ new WeakMap();
    _pattern = /* @__PURE__ */ new WeakMap();
    _selector = /* @__PURE__ */ new WeakMap();
    module2.exports = FilteredCluster;
  }
});
var require_cluster = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/lib/cluster.js"(exports, module2) {
    "use strict";
    var ClusterOptions = require_cluster_options();
    var PoolOptions = require_pool_options();
    var PoolCallback = require_pool_callback();
    var PoolPromise = require_pool_promise();
    var FilteredCluster = require_filtered_cluster();
    var EventEmitter = (0, import_chunk_WWAWV7DQ.__require)("events");
    var _opts, _nodes, _cachedPatterns, _nodeCounter;
    var Cluster = class extends EventEmitter {
      constructor(args) {
        super();
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _opts);
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _nodes, {});
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _cachedPatterns, {});
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _nodeCounter, 0);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _opts, new ClusterOptions(args));
      }
      /**
       * Add a new pool node to cluster.
       *
       * @param id      identifier
       * @param config  pool configuration
       */
      add(id, config) {
        let identifier;
        if (typeof id === "string" || id instanceof String) {
          identifier = id;
          if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _nodes)[identifier]) throw new Error(`Node identifier '${identifier}' already exist !`);
        } else {
          identifier = "PoolNode-" + (0, import_chunk_WWAWV7DQ.__privateWrapper)(this, _nodeCounter)._++;
          config = id;
        }
        const options = new PoolOptions(config);
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _nodes)[identifier] = this._createPool(options);
      }
      /**
       * End cluster (and underlying pools).
       *
       * @return {Promise<any[]>}
       */
      end() {
        const cluster = this;
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _cachedPatterns, {});
        const poolEndPromise = [];
        Object.keys((0, import_chunk_WWAWV7DQ.__privateGet)(this, _nodes)).forEach((pool) => {
          const res = (0, import_chunk_WWAWV7DQ.__privateGet)(cluster, _nodes)[pool].end();
          if (res) poolEndPromise.push(res);
        });
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _nodes, null);
        return Promise.all(poolEndPromise);
      }
      of(pattern, selector) {
        return new FilteredCluster(this, pattern, selector);
      }
      /**
       * Remove nodes according to pattern.
       *
       * @param pattern  pattern
       */
      remove(pattern) {
        if (!pattern) throw new Error("pattern parameter in Cluster.remove(pattern)  is mandatory");
        const regex = RegExp(pattern);
        Object.keys((0, import_chunk_WWAWV7DQ.__privateGet)(this, _nodes)).forEach(
          function(key) {
            if (regex.test(key)) {
              (0, import_chunk_WWAWV7DQ.__privateGet)(this, _nodes)[key].end();
              delete (0, import_chunk_WWAWV7DQ.__privateGet)(this, _nodes)[key];
              (0, import_chunk_WWAWV7DQ.__privateSet)(this, _cachedPatterns, {});
            }
          }.bind(this)
        );
      }
      /**
       * Get connection from available pools matching pattern, according to selector
       *
       * @param pattern       pattern filter (not mandatory)
       * @param selector      node selector ('RR','RANDOM' or 'ORDER')
       * @return {Promise}
       */
      getConnection(pattern, selector) {
        return this._getConnection(pattern, selector, void 0, void 0, void 0);
      }
      /**
       * Force using callback methods.
       */
      _setCallback() {
        this.getConnection = this._getConnectionCallback;
        this._createPool = this._createPoolCallback;
      }
      /**
       * Get connection from available pools matching pattern, according to selector
       * with additional parameter to avoid reusing failing node
       *
       * @param pattern       pattern filter (not mandatory)
       * @param selector      node selector ('RR','RANDOM' or 'ORDER')
       * @param avoidNodeKey  failing node
       * @param lastError     last error
       * @param remainingRetry remaining possible retry
       * @return {Promise}
       * @private
       */
      _getConnection(pattern, selector, remainingRetry, avoidNodeKey, lastError) {
        const matchingNodeList = this._matchingNodes(pattern || /^/);
        if (matchingNodeList.length === 0) {
          if (Object.keys((0, import_chunk_WWAWV7DQ.__privateGet)(this, _nodes)).length === 0 && !lastError) {
            return Promise.reject(
              new Error("No node have been added to cluster or nodes have been removed due to too much connection error")
            );
          }
          if (avoidNodeKey === void 0) return Promise.reject(new Error(`No node found for pattern '${pattern}'`));
          const errMsg = `No Connection available for '${pattern}'${lastError ? ". Last connection error was: " + lastError.message : ""}`;
          return Promise.reject(new Error(errMsg));
        }
        if (remainingRetry === void 0) remainingRetry = matchingNodeList.length;
        const retry = --remainingRetry >= 0 ? this._getConnection.bind(this, pattern, selector, remainingRetry) : null;
        try {
          const nodeKey = this._selectPool(matchingNodeList, selector, avoidNodeKey);
          return this._handleConnectionError(matchingNodeList, nodeKey, retry);
        } catch (e) {
          return Promise.reject(e);
        }
      }
      _createPool(options) {
        const pool = new PoolPromise(options);
        pool.on("error", (err) => {
        });
        return pool;
      }
      _createPoolCallback(options) {
        const pool = new PoolCallback(options);
        pool.on("error", (err) => {
        });
        return pool;
      }
      /**
       * Get connection from available pools matching pattern, according to selector
       * with additional parameter to avoid reusing failing node
       *
       * @param pattern       pattern filter (not mandatory)
       * @param selector      node selector ('RR','RANDOM' or 'ORDER')
       * @param callback      callback function
       * @param avoidNodeKey  failing node
       * @param lastError     last error
       * @private
       */
      _getConnectionCallback(pattern, selector, callback, avoidNodeKey, lastError) {
        const matchingNodeList = this._matchingNodes(pattern || /^/);
        if (matchingNodeList.length === 0) {
          if (Object.keys((0, import_chunk_WWAWV7DQ.__privateGet)(this, _nodes)).length === 0 && !lastError) {
            callback(
              new Error("No node have been added to cluster or nodes have been removed due to too much connection error")
            );
            return;
          }
          if (avoidNodeKey === void 0) callback(new Error(`No node found for pattern '${pattern}'`));
          const errMsg = `No Connection available for '${pattern}'${lastError ? ". Last connection error was: " + lastError.message : ""}`;
          callback(new Error(errMsg));
          return;
        }
        const retry = this._getConnectionCallback.bind(this, pattern, selector, callback);
        try {
          const nodeKey = this._selectPool(matchingNodeList, selector, avoidNodeKey);
          this._handleConnectionCallbackError(matchingNodeList, nodeKey, retry, callback);
        } catch (e) {
          callback(e);
        }
      }
      /**
       * Selecting nodes according to pattern.
       *
       * @param pattern pattern
       * @return {*}
       * @private
       */
      _matchingNodes(pattern) {
        if ((0, import_chunk_WWAWV7DQ.__privateGet)(this, _cachedPatterns)[pattern]) return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _cachedPatterns)[pattern];
        const regex = RegExp(pattern);
        const matchingNodeList = [];
        Object.keys((0, import_chunk_WWAWV7DQ.__privateGet)(this, _nodes)).forEach((key) => {
          if (regex.test(key)) {
            matchingNodeList.push(key);
          }
        });
        (0, import_chunk_WWAWV7DQ.__privateGet)(this, _cachedPatterns)[pattern] = matchingNodeList;
        return matchingNodeList;
      }
      /**
       * Select next node to be chosen in nodeList according to selector and failed nodes.
       *
       * @param nodeList        current node list
       * @param selectorParam   selector
       * @param avoidNodeKey    last failing node to avoid selecting this one.
       * @return {Promise}
       * @private
       */
      _selectPool(nodeList, selectorParam, avoidNodeKey) {
        const selector = selectorParam || (0, import_chunk_WWAWV7DQ.__privateGet)(this, _opts).defaultSelector;
        let selectorFct;
        switch (selector) {
          case "RR":
            selectorFct = roundRobinSelector;
            break;
          case "RANDOM":
            selectorFct = randomSelector;
            break;
          case "ORDER":
            selectorFct = orderedSelector;
            break;
          default:
            throw new Error(`Wrong selector value '${selector}'. Possible values are 'RR','RANDOM' or 'ORDER'`);
        }
        let nodeIdx = 0;
        let nodeKey = selectorFct(nodeList, nodeIdx);
        while ((avoidNodeKey === nodeKey || (0, import_chunk_WWAWV7DQ.__privateGet)(this, _nodes)[nodeKey].blacklistedUntil && (0, import_chunk_WWAWV7DQ.__privateGet)(this, _nodes)[nodeKey].blacklistedUntil > Date.now()) && nodeIdx < nodeList.length - 1) {
          nodeIdx++;
          nodeKey = selectorFct(nodeList, nodeIdx);
        }
        if (avoidNodeKey === nodeKey) {
          nodeIdx = 0;
          while (avoidNodeKey === nodeKey && nodeIdx < nodeList.length - 1) {
            nodeIdx++;
            nodeKey = selectorFct(nodeList, nodeIdx);
          }
        }
        return nodeKey;
      }
      /**
       * Connect, or if fail handle retry / set timeout error
       *
       * @param nodeList    current node list
       * @param nodeKey     node name to connect
       * @param retryFct    retry function
       * @return {Promise}
       * @private
       */
      _handleConnectionError(nodeList, nodeKey, retryFct) {
        const cluster = this;
        const node = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _nodes)[nodeKey];
        return node.getConnection().then((conn) => {
          node.blacklistedUntil = null;
          node.errorCount = 0;
          return Promise.resolve(conn);
        }).catch((err) => {
          node.errorCount = node.errorCount ? node.errorCount + 1 : 1;
          node.blacklistedUntil = Date.now() + (0, import_chunk_WWAWV7DQ.__privateGet)(cluster, _opts).restoreNodeTimeout;
          if ((0, import_chunk_WWAWV7DQ.__privateGet)(cluster, _opts).removeNodeErrorCount && node.errorCount >= (0, import_chunk_WWAWV7DQ.__privateGet)(cluster, _opts).removeNodeErrorCount && (0, import_chunk_WWAWV7DQ.__privateGet)(cluster, _nodes)[nodeKey]) {
            delete (0, import_chunk_WWAWV7DQ.__privateGet)(cluster, _nodes)[nodeKey];
            (0, import_chunk_WWAWV7DQ.__privateSet)(cluster, _cachedPatterns, {});
            delete nodeList.lastRrIdx;
            setImmediate(cluster.emit.bind(cluster, "remove", nodeKey));
            node.end().catch((err2) => {
            });
          }
          if (nodeList.length !== 0 && (0, import_chunk_WWAWV7DQ.__privateGet)(cluster, _opts).canRetry && retryFct) {
            return retryFct(nodeKey, err);
          }
          return Promise.reject(err);
        });
      }
      /**
       * Connect, or if fail handle retry / set timeout error
       *
       * @param nodeList    current node list
       * @param nodeKey     node name to connect
       * @param retryFct    retry function
       * @param callback    callback function
       * @private
       */
      _handleConnectionCallbackError(nodeList, nodeKey, retryFct, callback) {
        const cluster = this;
        const node = (0, import_chunk_WWAWV7DQ.__privateGet)(this, _nodes)[nodeKey];
        node.getConnection((err, conn) => {
          if (err) {
            node.errorCount = node.errorCount ? node.errorCount + 1 : 1;
            node.blacklistedUntil = Date.now() + (0, import_chunk_WWAWV7DQ.__privateGet)(cluster, _opts).restoreNodeTimeout;
            if ((0, import_chunk_WWAWV7DQ.__privateGet)(cluster, _opts).removeNodeErrorCount && node.errorCount >= (0, import_chunk_WWAWV7DQ.__privateGet)(cluster, _opts).removeNodeErrorCount && (0, import_chunk_WWAWV7DQ.__privateGet)(cluster, _nodes)[nodeKey]) {
              delete (0, import_chunk_WWAWV7DQ.__privateGet)(cluster, _nodes)[nodeKey];
              (0, import_chunk_WWAWV7DQ.__privateSet)(cluster, _cachedPatterns, {});
              delete nodeList.lastRrIdx;
              setImmediate(cluster.emit.bind(cluster, "remove", nodeKey));
              node.end(() => {
              });
            }
            if (nodeList.length !== 0 && (0, import_chunk_WWAWV7DQ.__privateGet)(cluster, _opts).canRetry && retryFct) {
              return retryFct(nodeKey, err);
            }
            callback(err);
          } else {
            node.errorCount = 0;
            callback(null, conn);
          }
        });
      }
      //*****************************************************************
      // internal public testing methods
      //*****************************************************************
      get __tests() {
        return new TestMethods((0, import_chunk_WWAWV7DQ.__privateGet)(this, _nodes));
      }
    };
    _opts = /* @__PURE__ */ new WeakMap();
    _nodes = /* @__PURE__ */ new WeakMap();
    _cachedPatterns = /* @__PURE__ */ new WeakMap();
    _nodeCounter = /* @__PURE__ */ new WeakMap();
    var _nodes2;
    var TestMethods = class {
      constructor(nodes) {
        (0, import_chunk_WWAWV7DQ.__privateAdd)(this, _nodes2);
        (0, import_chunk_WWAWV7DQ.__privateSet)(this, _nodes2, nodes);
      }
      getNodes() {
        return (0, import_chunk_WWAWV7DQ.__privateGet)(this, _nodes2);
      }
    };
    _nodes2 = /* @__PURE__ */ new WeakMap();
    var roundRobinSelector = (nodeList) => {
      let lastRoundRobin = nodeList.lastRrIdx;
      if (lastRoundRobin === void 0) lastRoundRobin = -1;
      if (++lastRoundRobin >= nodeList.length) lastRoundRobin = 0;
      nodeList.lastRrIdx = lastRoundRobin;
      return nodeList[lastRoundRobin];
    };
    var randomSelector = (nodeList) => {
      let randomIdx = ~~(Math.random() * nodeList.length);
      return nodeList[randomIdx];
    };
    var orderedSelector = (nodeList, retry) => {
      return nodeList[retry];
    };
    module2.exports = Cluster;
  }
});
var require_promise = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/mariadb@3.3.1/node_modules/mariadb/promise.js"(exports, module2) {
    "use strict";
    require_check_node();
    var Connection = require_connection();
    var ConnectionPromise = require_connection_promise();
    var PoolPromise = require_pool_promise();
    var Cluster = require_cluster();
    var ConnOptions = require_connection_options();
    var PoolOptions = require_pool_options();
    var ClusterOptions = require_cluster_options();
    module2.exports.version = require_package().version;
    module2.exports.SqlError = require_errors().SqlError;
    module2.exports.defaultOptions = function defaultOptions(opts) {
      const connOpts = new ConnOptions(opts);
      const res = {};
      for (const [key, value] of Object.entries(connOpts)) {
        if (!key.startsWith("_")) {
          res[key] = value;
        }
      }
      return res;
    };
    module2.exports.createConnection = function createConnection(opts) {
      try {
        const options = new ConnOptions(opts);
        const conn = new Connection(options);
        const connPromise = new ConnectionPromise(conn);
        return conn.connect().then(() => Promise.resolve(connPromise));
      } catch (err) {
        return Promise.reject(err);
      }
    };
    module2.exports.createPool = function createPool(opts) {
      const options = new PoolOptions(opts);
      const pool = new PoolPromise(options);
      pool.on("error", (err) => {
      });
      return pool;
    };
    module2.exports.createPoolCluster = function createPoolCluster(opts) {
      const options = new ClusterOptions(opts);
      return new Cluster(options);
    };
    module2.exports.importFile = function importFile(opts) {
      try {
        const options = new ConnOptions(opts);
        const conn = new Connection(options);
        return conn.connect().then(() => {
          return new Promise(conn.importFile.bind(conn, Object.assign({ skipDbCheck: true }, opts)));
        }).finally(() => {
          new Promise(conn.end.bind(conn, {})).catch(console.log);
        });
      } catch (err) {
        return Promise.reject(err);
      }
    };
  }
});
var import_mariadb = (0, import_chunk_WWAWV7DQ.__toESM)(require_promise());
async function setupMysql(options) {
  const { connectionString } = options;
  const { dirname } = options;
  const credentials = (0, import_internals.uriToCredentials)(connectionString);
  const dbDefault = await import_mariadb.default.createConnection({
    host: credentials.host,
    port: credentials.port,
    // database: credentials.database, // use the default db
    user: credentials.user,
    password: credentials.password,
    multipleStatements: true,
    allowPublicKeyRetrieval: true
  });
  await dbDefault.query(`
CREATE DATABASE IF NOT EXISTS \`${credentials.database}-shadowdb\`;
CREATE DATABASE IF NOT EXISTS \`${credentials.database}\`;
`);
  await dbDefault.end();
  if (dirname !== "") {
    const db = await import_mariadb.default.createConnection({
      host: credentials.host,
      port: credentials.port,
      database: credentials.database,
      // use final db
      user: credentials.user,
      password: credentials.password,
      multipleStatements: true,
      allowPublicKeyRetrieval: true
    });
    await db.query(import_fs.default.readFileSync(import_path.default.join(dirname, "setup.sql"), "utf-8"));
    await db.end();
  }
}
async function tearDownMysql(options) {
  const { connectionString } = options;
  const credentials = (0, import_internals.uriToCredentials)(connectionString);
  const credentialsClone = { ...credentials };
  credentialsClone.database = "mysql";
  const db = await import_mariadb.default.createConnection({
    host: credentialsClone.host,
    port: credentialsClone.port,
    database: credentialsClone.database,
    user: credentialsClone.user,
    password: credentialsClone.password,
    multipleStatements: true,
    allowPublicKeyRetrieval: true
  });
  await db.query(`
    DROP DATABASE IF EXISTS \`${credentials.database}\`;
  `);
  await db.end();
}
