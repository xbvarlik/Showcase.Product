"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_ZLGLVUFD_exports = {};
__export(chunk_ZLGLVUFD_exports, {
  DbSeed: () => DbSeed,
  init_DbSeed: () => init_DbSeed
});
module.exports = __toCommonJS(chunk_ZLGLVUFD_exports);
var import_chunk_EFPE3Q7J = require("./chunk-EFPE3Q7J.js");
var import_chunk_6TE2RIPN = require("./chunk-6TE2RIPN.js");
var import_chunk_WWAWV7DQ = require("./chunk-WWAWV7DQ.js");
var import_internals = require("@prisma/internals");
var require_arg = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/arg@5.0.2/node_modules/arg/index.js"(exports, module2) {
    "use strict";
    var flagSymbol = Symbol("arg flag");
    var ArgError2 = class _ArgError extends Error {
      constructor(msg, code) {
        super(msg);
        this.name = "ArgError";
        this.code = code;
        Object.setPrototypeOf(this, _ArgError.prototype);
      }
    };
    function arg2(opts, {
      argv = process.argv.slice(2),
      permissive = false,
      stopAtPositional = false
    } = {}) {
      if (!opts) {
        throw new ArgError2(
          "argument specification object is required",
          "ARG_CONFIG_NO_SPEC"
        );
      }
      const result = { _: [] };
      const aliases = {};
      const handlers = {};
      for (const key of Object.keys(opts)) {
        if (!key) {
          throw new ArgError2(
            "argument key cannot be an empty string",
            "ARG_CONFIG_EMPTY_KEY"
          );
        }
        if (key[0] !== "-") {
          throw new ArgError2(
            `argument key must start with '-' but found: '${key}'`,
            "ARG_CONFIG_NONOPT_KEY"
          );
        }
        if (key.length === 1) {
          throw new ArgError2(
            `argument key must have a name; singular '-' keys are not allowed: ${key}`,
            "ARG_CONFIG_NONAME_KEY"
          );
        }
        if (typeof opts[key] === "string") {
          aliases[key] = opts[key];
          continue;
        }
        let type = opts[key];
        let isFlag = false;
        if (Array.isArray(type) && type.length === 1 && typeof type[0] === "function") {
          const [fn] = type;
          type = (value, name, prev = []) => {
            prev.push(fn(value, name, prev[prev.length - 1]));
            return prev;
          };
          isFlag = fn === Boolean || fn[flagSymbol] === true;
        } else if (typeof type === "function") {
          isFlag = type === Boolean || type[flagSymbol] === true;
        } else {
          throw new ArgError2(
            `type missing or not a function or valid array type: ${key}`,
            "ARG_CONFIG_VAD_TYPE"
          );
        }
        if (key[1] !== "-" && key.length > 2) {
          throw new ArgError2(
            `short argument keys (with a single hyphen) must have only one character: ${key}`,
            "ARG_CONFIG_SHORTOPT_TOOLONG"
          );
        }
        handlers[key] = [type, isFlag];
      }
      for (let i = 0, len = argv.length; i < len; i++) {
        const wholeArg = argv[i];
        if (stopAtPositional && result._.length > 0) {
          result._ = result._.concat(argv.slice(i));
          break;
        }
        if (wholeArg === "--") {
          result._ = result._.concat(argv.slice(i + 1));
          break;
        }
        if (wholeArg.length > 1 && wholeArg[0] === "-") {
          const separatedArguments = wholeArg[1] === "-" || wholeArg.length === 2 ? [wholeArg] : wholeArg.slice(1).split("").map((a) => `-${a}`);
          for (let j = 0; j < separatedArguments.length; j++) {
            const arg3 = separatedArguments[j];
            const [originalArgName, argStr] = arg3[1] === "-" ? arg3.split(/=(.*)/, 2) : [arg3, void 0];
            let argName = originalArgName;
            while (argName in aliases) {
              argName = aliases[argName];
            }
            if (!(argName in handlers)) {
              if (permissive) {
                result._.push(arg3);
                continue;
              } else {
                throw new ArgError2(
                  `unknown or unexpected option: ${originalArgName}`,
                  "ARG_UNKNOWN_OPTION"
                );
              }
            }
            const [type, isFlag] = handlers[argName];
            if (!isFlag && j + 1 < separatedArguments.length) {
              throw new ArgError2(
                `option requires argument (but was followed by another short argument): ${originalArgName}`,
                "ARG_MISSING_REQUIRED_SHORTARG"
              );
            }
            if (isFlag) {
              result[argName] = type(true, argName, result[argName]);
            } else if (argStr === void 0) {
              if (argv.length < i + 2 || argv[i + 1].length > 1 && argv[i + 1][0] === "-" && !(argv[i + 1].match(/^-?\d*(\.(?=\d))?\d*$/) && (type === Number || // eslint-disable-next-line no-undef
              typeof BigInt !== "undefined" && type === BigInt))) {
                const extended = originalArgName === argName ? "" : ` (alias for ${argName})`;
                throw new ArgError2(
                  `option requires argument: ${originalArgName}${extended}`,
                  "ARG_MISSING_REQUIRED_LONGARG"
                );
              }
              result[argName] = type(argv[i + 1], argName, result[argName]);
              ++i;
            } else {
              result[argName] = type(argStr, argName, result[argName]);
            }
          }
        } else {
          result._.push(wholeArg);
        }
      }
      return result;
    }
    arg2.flag = (fn) => {
      fn[flagSymbol] = true;
      return fn;
    };
    arg2.COUNT = arg2.flag((v, name, existingCount) => (existingCount || 0) + 1);
    arg2.ArgError = ArgError2;
    module2.exports = arg2;
  }
});
var import_arg, _DbSeed, DbSeed;
var init_DbSeed = (0, import_chunk_WWAWV7DQ.__esm)({
  "src/commands/DbSeed.ts"() {
    import_arg = (0, import_chunk_WWAWV7DQ.__toESM)(require_arg());
    (0, import_chunk_6TE2RIPN.init_colors)();
    (0, import_chunk_EFPE3Q7J.init_seed)();
    _DbSeed = class _DbSeed2 {
      static new() {
        return new _DbSeed2();
      }
      async parse(argv) {
        const args = (0, import_internals.arg)(
          argv,
          {
            "--help": Boolean,
            "-h": "--help",
            "--schema": String,
            "--telemetry-information": String
          },
          false
        );
        if ((0, import_internals.isError)(args)) {
          if (args instanceof import_arg.ArgError && args.code === "ARG_UNKNOWN_OPTION") {
            throw new Error(`${args.message}
Did you mean to pass these as arguments to your seed script? If so, add a -- separator before them:
${(0, import_chunk_6TE2RIPN.dim)("$")} prisma db seed -- --arg1 value1 --arg2 value2`);
          }
          return this.help(args.message);
        }
        if (args["--help"]) {
          return this.help();
        }
        await (0, import_internals.loadEnvFile)({ schemaPath: args["--schema"], printMessage: true });
        const seedCommandFromPkgJson = await (0, import_chunk_EFPE3Q7J.getSeedCommandFromPackageJson)(process.cwd());
        if (!seedCommandFromPkgJson) {
          const schemaResult = await (0, import_internals.getSchemaWithPath)(args["--schema"]);
          const message = await (0, import_chunk_EFPE3Q7J.verifySeedConfigAndReturnMessage)(schemaResult?.schemaPath ?? null);
          if (message) {
            throw new Error(message);
          }
          return ``;
        }
        const extraArgs = args._.join(" ");
        const successfulSeeding = await (0, import_chunk_EFPE3Q7J.executeSeedCommand)({ commandFromConfig: seedCommandFromPkgJson, extraArgs });
        if (successfulSeeding) {
          return `
${process.platform === "win32" ? "" : "\u{1F331}  "}The seed command has been executed.`;
        } else {
          process.exit(1);
        }
      }
      help(error) {
        if (error) {
          return new import_internals.HelpError(`
${(0, import_chunk_6TE2RIPN.bold)((0, import_chunk_6TE2RIPN.red)(`!`))} ${error}
${_DbSeed2.help}`);
        }
        return _DbSeed2.help;
      }
    };
    _DbSeed.help = (0, import_internals.format)(`
${process.platform === "win32" ? "" : "\u{1F64C}  "}Seed your database

${(0, import_chunk_6TE2RIPN.bold)("Usage")}

  ${(0, import_chunk_6TE2RIPN.dim)("$")} prisma db seed [options]

${(0, import_chunk_6TE2RIPN.bold)("Options")}

  -h, --help   Display this help message

${(0, import_chunk_6TE2RIPN.bold)("Examples")}

  Passing extra arguments to the seed command
    ${(0, import_chunk_6TE2RIPN.dim)("$")} prisma db seed -- --arg1 value1 --arg2 value2
`);
    DbSeed = _DbSeed;
  }
});
