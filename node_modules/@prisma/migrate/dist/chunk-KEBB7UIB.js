"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_KEBB7UIB_exports = {};
__export(chunk_KEBB7UIB_exports, {
  ensureCanConnectToDatabase: () => ensureCanConnectToDatabase,
  ensureDatabaseExists: () => ensureDatabaseExists,
  getDatasourceInfo: () => getDatasourceInfo,
  getDbLocation: () => getDbLocation,
  init_ensureDatabaseExists: () => init_ensureDatabaseExists,
  prettifyProvider: () => prettifyProvider
});
module.exports = __toCommonJS(chunk_KEBB7UIB_exports);
var import_chunk_KPUNMK5W = require("./chunk-KPUNMK5W.js");
var import_chunk_6TE2RIPN = require("./chunk-6TE2RIPN.js");
var import_chunk_WWAWV7DQ = require("./chunk-WWAWV7DQ.js");
var import_internals = require("@prisma/internals");
async function getDatasourceInfo({
  schemaPath,
  throwIfEnvError
} = {}) {
  const schema = await (0, import_internals.getSchema)(schemaPath);
  let config;
  try {
    config = await (0, import_internals.getConfig)({ datamodel: schema, ignoreEnvVarErrors: false });
  } catch (error) {
    if (throwIfEnvError) {
      throw error;
    }
    config = await (0, import_internals.getConfig)({ datamodel: schema, ignoreEnvVarErrors: true });
  }
  const firstDatasource = config.datasources[0] ? config.datasources[0] : void 0;
  if (!firstDatasource) {
    return {
      name: void 0,
      prettyProvider: void 0,
      dbName: void 0,
      dbLocation: void 0,
      url: void 0,
      schema: void 0,
      schemas: void 0,
      configDir: void 0
    };
  }
  const prettyProvider = prettifyProvider(firstDatasource.provider);
  const url = (0, import_internals.getEffectiveUrl)(firstDatasource).value;
  if (!url || firstDatasource.provider === "sqlserver") {
    return {
      name: firstDatasource.name,
      prettyProvider,
      dbName: void 0,
      dbLocation: void 0,
      url: url || void 0,
      schema: void 0,
      schemas: firstDatasource.schemas,
      configDir: (0, import_internals.getMigrateConfigDir)(config, schemaPath)
    };
  }
  try {
    const credentials = (0, import_internals.uriToCredentials)(url);
    const dbLocation = getDbLocation(credentials);
    let schema2 = void 0;
    if (["postgresql", "cockroachdb"].includes(firstDatasource.provider)) {
      if (credentials.schema) {
        schema2 = credentials.schema;
      } else {
        schema2 = "public";
      }
    }
    const datasourceInfo = {
      name: firstDatasource.name,
      prettyProvider,
      dbName: credentials.database,
      dbLocation,
      url,
      schema: schema2,
      schemas: firstDatasource.schemas,
      configDir: (0, import_internals.getMigrateConfigDir)(config, schemaPath)
    };
    if (firstDatasource.provider === "postgresql" && datasourceInfo.dbName === void 0) {
      datasourceInfo.dbName = "postgres";
    }
    return datasourceInfo;
  } catch (e) {
    return {
      name: firstDatasource.name,
      prettyProvider,
      dbName: void 0,
      dbLocation: void 0,
      url,
      schema: void 0,
      schemas: firstDatasource.schemas,
      configDir: (0, import_internals.getMigrateConfigDir)(config, schemaPath)
    };
  }
}
async function ensureCanConnectToDatabase(schemaPath) {
  const schema = await (0, import_internals.getSchema)(schemaPath);
  const config = await (0, import_internals.getConfig)({ datamodel: schema, ignoreEnvVarErrors: false });
  const firstDatasource = config.datasources[0] ? config.datasources[0] : void 0;
  if (!firstDatasource) {
    throw new Error(`A datasource block is missing in the Prisma schema file.`);
  }
  const schemaDir = (0, import_internals.getMigrateConfigDir)(config, schemaPath);
  const url = (0, import_internals.getEffectiveUrl)(firstDatasource).value;
  const canConnect = await (0, import_internals.canConnectToDatabase)(url, schemaDir);
  if (canConnect === true) {
    return true;
  } else {
    const { code, message } = canConnect;
    throw new Error(`${code}: ${message}`);
  }
}
async function ensureDatabaseExists(action, schemaPath) {
  const schemas = await (0, import_internals.getSchema)(schemaPath);
  const config = await (0, import_internals.getConfig)({ datamodel: schemas, ignoreEnvVarErrors: false });
  const firstDatasource = config.datasources[0] ? config.datasources[0] : void 0;
  if (!firstDatasource) {
    throw new Error(`A datasource block is missing in the Prisma schema file.`);
  }
  const schemaDir = (0, import_internals.getMigrateConfigDir)(config, schemaPath);
  const url = (0, import_internals.getEffectiveUrl)(firstDatasource).value;
  const canConnect = await (0, import_internals.canConnectToDatabase)(url, schemaDir);
  if (canConnect === true) {
    return;
  }
  const { code, message } = canConnect;
  if (code !== "P1003") {
    throw new Error(`${code}: ${message}`);
  }
  if (!schemaDir) {
    throw new Error(`Could not locate ${schemaPath || "schema.prisma"}`);
  }
  if (await (0, import_internals.createDatabase)(url, schemaDir)) {
    if (firstDatasource.provider === "sqlserver") {
      return `SQL Server database created.
`;
    }
    const credentials = (0, import_internals.uriToCredentials)(url);
    const prettyProvider = prettifyProvider(firstDatasource.provider);
    let message2 = `${prettyProvider} database${credentials.database ? ` ${credentials.database} ` : " "}created`;
    const dbLocation = getDbLocation(credentials);
    if (dbLocation) {
      message2 += ` at ${(0, import_chunk_6TE2RIPN.bold)(dbLocation)}`;
    }
    return message2;
  }
  return void 0;
}
function getDbLocation(credentials) {
  if (credentials.type === "sqlite") {
    return credentials.uri;
  }
  const socket = (0, import_chunk_KPUNMK5W.getSocketFromDatabaseCredentials)(credentials);
  if (socket) {
    return `unix:${socket}`;
  } else if (credentials.host && credentials.port) {
    return `${credentials.host}:${credentials.port}`;
  } else if (credentials.host) {
    return `${credentials.host}`;
  }
  return void 0;
}
function prettifyProvider(provider) {
  switch (provider) {
    case "mysql":
      return `MySQL`;
    case "postgres":
    case "postgresql":
      return `PostgreSQL`;
    case "sqlite":
      return `SQLite`;
    case "cockroachdb":
      return `CockroachDB`;
    case "sqlserver":
      return `SQL Server`;
    case "mongodb":
      return `MongoDB`;
  }
}
var init_ensureDatabaseExists = (0, import_chunk_WWAWV7DQ.__esm)({
  "src/utils/ensureDatabaseExists.ts"() {
    (0, import_chunk_6TE2RIPN.init_colors)();
    (0, import_chunk_KPUNMK5W.init_unixSocket)();
  }
});
