import type { SqlQueryOutput } from '@prisma/generator-helper';
import type { MigrateTypes } from '@prisma/internals';
import type { IntrospectionViewDefinition } from './views/handleViewsIO';
export interface RpcRequestResponse {
    id: number;
    jsonrpc: '2.0';
}
export interface RpcSuccessResponse<T> extends RpcRequestResponse {
    result: T;
}
interface RpcErrorResponse<T> extends RpcRequestResponse {
    error: T;
}
export type RpcResponse<T, E> = RpcSuccessResponse<T> | RpcErrorResponse<E>;
export interface RPCPayload extends RpcRequestResponse {
    method: string;
    params: any;
}
interface UserFacingError {
    is_panic: boolean;
    message: string;
    error_code?: string;
    meta?: unknown;
}
export type UserFacingErrorWithMeta = {
    is_panic: boolean;
    message: string;
    error_code: 'P3006';
    meta: {
        migration_name: string;
        inner_error?: {
            is_panic: boolean;
            message: string;
            backtrace: string;
        };
    };
};
export type DriftDiagnostic = {
    diagnostic: 'driftDetected';
    rollback: string;
} | {
    diagnostic: 'migrationFailedToApply';
    error: UserFacingError;
};
export type HistoryDiagnostic = {
    diagnostic: 'databaseIsBehind';
    unappliedMigrationNames: string[];
} | {
    diagnostic: 'migrationsDirectoryIsBehind';
    unpersistedMigrationNames: string[];
} | {
    diagnostic: 'historiesDiverge';
    lastCommonMigrationName: string;
    unpersistedMigrationNames: string[];
    unappliedMigrationNames: string[];
};
export interface MigrationFeedback {
    message: string;
    stepIndex: number;
}
export type DevAction = {
    tag: 'reset';
    reason: string;
} | {
    tag: 'createMigration';
};
export declare namespace EngineArgs {
    /**
     * These RPCs need a sourceConfig, therefore a db connection to function
     */
    export interface ApplyMigrationsInput {
        migrationsDirectoryPath: string;
    }
    export interface CreateMigrationInput {
        migrationsDirectoryPath: string;
        schema: MigrateTypes.SchemasContainer;
        draft: boolean;
        migrationName?: string;
    }
    export interface CreateDatabaseInput {
        datasource: MigrateTypes.DatasourceParam;
    }
    export interface DropDatabase {
        schema: string;
    }
    export type DbExecuteDatasourceType = MigrateTypes.Tagged<'schema', MigrateTypes.SchemasWithConfigDir> | MigrateTypes.Tagged<'url', MigrateTypes.UrlContainer>;
    export interface DbExecuteInput {
        datasourceType: DbExecuteDatasourceType;
        script: string;
    }
    export interface IntrospectParams {
        schema: MigrateTypes.SchemasContainer;
        baseDirectoryPath: string;
        force?: Boolean;
        compositeTypeDepth?: number;
        namespaces?: string[];
    }
    export interface IntrospectResult {
        schema: MigrateTypes.SchemasContainer;
        warnings: string | null;
        /**
         * Views retrieved from the databases.
         * Supported databases: 'postgresql'.
         *
         * This value is:
         * - `null` if "views" doesn't appear in the schema's preview features
         * - `[]` if the database doesn't have any views
         * - a non-empty array in other cases
         */
        views: IntrospectionViewDefinition[] | null;
    }
    export interface DevDiagnosticInput {
        migrationsDirectoryPath: string;
    }
    export interface DiagnoseMigrationHistoryInput {
        migrationsDirectoryPath: string;
        optInToShadowDatabase: boolean;
    }
    export interface EnsureConnectionValidityInput {
        datasource: MigrateTypes.DatasourceParam;
    }
    export interface EvaluateDataLossInput {
        migrationsDirectoryPath: string;
        schema: MigrateTypes.SchemasContainer;
    }
    export interface ListMigrationDirectoriesInput {
        migrationsDirectoryPath: string;
    }
    export interface MarkMigrationAppliedInput {
        migrationsDirectoryPath: string;
        migrationName: string;
    }
    export interface MarkMigrationRolledBackInput {
        migrationName: string;
    }
    type MigrateDiffTargetUrl = MigrateTypes.Tagged<'url', MigrateTypes.UrlContainer>;
    type MigrateDiffTargetEmpty = {
        tag: 'empty';
    };
    type MigrateDiffTargetSchemaDatamodel = MigrateTypes.Tagged<'schemaDatamodel', MigrateTypes.SchemasContainer>;
    type MigrateDiffTargetSchemaDatasource = MigrateTypes.Tagged<'schemaDatasource', MigrateTypes.SchemasWithConfigDir>;
    type MigrateDiffTargetMigrations = {
        tag: 'migrations';
        path: string;
    };
    export type MigrateDiffTarget = MigrateDiffTargetUrl | MigrateDiffTargetEmpty | MigrateDiffTargetSchemaDatamodel | MigrateDiffTargetSchemaDatasource | MigrateDiffTargetMigrations;
    export interface MigrateDiffInput {
        from: MigrateDiffTarget;
        to: MigrateDiffTarget;
        script: boolean;
        shadowDatabaseUrl?: string;
        exitCode?: boolean;
    }
    export interface SchemaPushInput {
        schema: MigrateTypes.SchemasContainer;
        force: boolean;
    }
    export interface IntrospectSqlParams {
        url: string;
        queries: SqlQueryInput[];
    }
    export interface SqlQueryInput {
        name: string;
        source: string;
    }
    export {};
}
export declare namespace EngineResults {
    interface ApplyMigrationsOutput {
        appliedMigrationNames: string[];
    }
    interface CreateDatabaseOutput {
        database_name: string;
    }
    interface CreateMigrationOutput {
        generatedMigrationName: string | null;
    }
    interface DbExecuteOutput {
    }
    interface DevDiagnosticOutput {
        action: DevAction;
    }
    interface DiagnoseMigrationHistoryOutput {
        history: HistoryDiagnostic | null;
        failedMigrationNames: string[];
        editedMigrationNames: string[];
        hasMigrationsTable: boolean;
    }
    interface EvaluateDataLossOutput {
        migrationSteps: number;
        warnings: MigrationFeedback[];
        unexecutableSteps: MigrationFeedback[];
    }
    interface ListMigrationDirectoriesOutput {
        migrations: string[];
    }
    enum MigrateDiffExitCode {
        SUCCESS = 0,
        ERROR = 1,
        SUCCESS_NONEMPTY = 2
    }
    interface MigrateDiffOutput {
        exitCode: MigrateDiffExitCode;
    }
    interface SchemaPush {
        executedSteps: number;
        warnings: string[];
        unexecutable: string[];
    }
    interface IntrospectSqlOutput {
        queries: SqlQueryOutput[];
    }
}
export interface FileMap {
    [fileName: string]: string;
}
export interface Dictionary<T> {
    [key: string]: T;
}
export {};
