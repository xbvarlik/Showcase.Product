"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_EFPE3Q7J_exports = {};
__export(chunk_EFPE3Q7J_exports, {
  executeSeedCommand: () => executeSeedCommand,
  getSeedCommandFromPackageJson: () => getSeedCommandFromPackageJson,
  init_seed: () => init_seed,
  legacyTsNodeScriptWarning: () => legacyTsNodeScriptWarning,
  verifySeedConfigAndReturnMessage: () => verifySeedConfigAndReturnMessage
});
module.exports = __toCommonJS(chunk_EFPE3Q7J_exports);
var import_chunk_WIZM7TFT = require("./chunk-WIZM7TFT.js");
var import_chunk_6TE2RIPN = require("./chunk-6TE2RIPN.js");
var import_chunk_WWAWV7DQ = require("./chunk-WWAWV7DQ.js");
var import_debug = __toESM(require("@prisma/debug"));
var import_internals = require("@prisma/internals");
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var require_has_yarn = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/has-yarn@2.1.0/node_modules/has-yarn/index.js"(exports, module2) {
    "use strict";
    var path2 = (0, import_chunk_WWAWV7DQ.__require)("path");
    var fs2 = (0, import_chunk_WWAWV7DQ.__require)("fs");
    var hasYarn2 = (cwd = process.cwd()) => fs2.existsSync(path2.resolve(cwd, "yarn.lock"));
    module2.exports = hasYarn2;
    module2.exports.default = hasYarn2;
  }
});
var require_path_exists = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/path-exists@3.0.0/node_modules/path-exists/index.js"(exports, module2) {
    "use strict";
    var fs2 = (0, import_chunk_WWAWV7DQ.__require)("fs");
    module2.exports = (fp) => new Promise((resolve) => {
      fs2.access(fp, (err) => {
        resolve(!err);
      });
    });
    module2.exports.sync = (fp) => {
      try {
        fs2.accessSync(fp);
        return true;
      } catch (err) {
        return false;
      }
    };
  }
});
var require_p_try = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/p-try@2.2.0/node_modules/p-try/index.js"(exports, module2) {
    "use strict";
    var pTry = (fn, ...arguments_) => new Promise((resolve) => {
      resolve(fn(...arguments_));
    });
    module2.exports = pTry;
    module2.exports.default = pTry;
  }
});
var require_p_limit = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/p-limit@2.3.0/node_modules/p-limit/index.js"(exports, module2) {
    "use strict";
    var pTry = require_p_try();
    var pLimit = (concurrency) => {
      if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
        return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
      }
      const queue = [];
      let activeCount = 0;
      const next = () => {
        activeCount--;
        if (queue.length > 0) {
          queue.shift()();
        }
      };
      const run = (fn, resolve, ...args) => {
        activeCount++;
        const result = pTry(fn, ...args);
        resolve(result);
        result.then(next, next);
      };
      const enqueue = (fn, resolve, ...args) => {
        if (activeCount < concurrency) {
          run(fn, resolve, ...args);
        } else {
          queue.push(run.bind(null, fn, resolve, ...args));
        }
      };
      const generator = (fn, ...args) => new Promise((resolve) => enqueue(fn, resolve, ...args));
      Object.defineProperties(generator, {
        activeCount: {
          get: () => activeCount
        },
        pendingCount: {
          get: () => queue.length
        },
        clearQueue: {
          value: () => {
            queue.length = 0;
          }
        }
      });
      return generator;
    };
    module2.exports = pLimit;
    module2.exports.default = pLimit;
  }
});
var require_p_locate = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/p-locate@3.0.0/node_modules/p-locate/index.js"(exports, module2) {
    "use strict";
    var pLimit = require_p_limit();
    var EndError = class extends Error {
      constructor(value) {
        super();
        this.value = value;
      }
    };
    var testElement = (el, tester) => Promise.resolve(el).then(tester);
    var finder = (el) => Promise.all(el).then((val) => val[1] === true && Promise.reject(new EndError(val[0])));
    module2.exports = (iterable, tester, opts) => {
      opts = Object.assign({
        concurrency: Infinity,
        preserveOrder: true
      }, opts);
      const limit = pLimit(opts.concurrency);
      const items = [...iterable].map((el) => [el, limit(testElement, el, tester)]);
      const checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);
      return Promise.all(items.map((el) => checkLimit(finder, el))).then(() => {
      }).catch((err) => err instanceof EndError ? err.value : Promise.reject(err));
    };
  }
});
var require_locate_path = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/locate-path@3.0.0/node_modules/locate-path/index.js"(exports, module2) {
    "use strict";
    var path2 = (0, import_chunk_WWAWV7DQ.__require)("path");
    var pathExists = require_path_exists();
    var pLocate = require_p_locate();
    module2.exports = (iterable, options) => {
      options = Object.assign({
        cwd: process.cwd()
      }, options);
      return pLocate(iterable, (el) => pathExists(path2.resolve(options.cwd, el)), options);
    };
    module2.exports.sync = (iterable, options) => {
      options = Object.assign({
        cwd: process.cwd()
      }, options);
      for (const el of iterable) {
        if (pathExists.sync(path2.resolve(options.cwd, el))) {
          return el;
        }
      }
    };
  }
});
var require_find_up = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/find-up@3.0.0/node_modules/find-up/index.js"(exports, module2) {
    "use strict";
    var path2 = (0, import_chunk_WWAWV7DQ.__require)("path");
    var locatePath = require_locate_path();
    module2.exports = (filename, opts = {}) => {
      const startDir = path2.resolve(opts.cwd || "");
      const { root } = path2.parse(startDir);
      const filenames = [].concat(filename);
      return new Promise((resolve) => {
        (function find(dir) {
          locatePath(filenames, { cwd: dir }).then((file) => {
            if (file) {
              resolve(path2.join(dir, file));
            } else if (dir === root) {
              resolve(null);
            } else {
              find(path2.dirname(dir));
            }
          });
        })(startDir);
      });
    };
    module2.exports.sync = (filename, opts = {}) => {
      let dir = path2.resolve(opts.cwd || "");
      const { root } = path2.parse(dir);
      const filenames = [].concat(filename);
      while (true) {
        const file = locatePath.sync(filenames, { cwd: dir });
        if (file) {
          return path2.join(dir, file);
        }
        if (dir === root) {
          return null;
        }
        dir = path2.dirname(dir);
      }
    };
  }
});
var require_pkg_up = (0, import_chunk_WWAWV7DQ.__commonJS)({
  "../../node_modules/.pnpm/pkg-up@3.1.0/node_modules/pkg-up/index.js"(exports, module2) {
    "use strict";
    var findUp = require_find_up();
    module2.exports = async ({ cwd } = {}) => findUp("package.json", { cwd });
    module2.exports.sync = ({ cwd } = {}) => findUp.sync("package.json", { cwd });
  }
});
async function verifySeedConfigAndReturnMessage(schemaPath) {
  const cwd = process.cwd();
  const detected = detectSeedFiles(cwd, schemaPath);
  const prismaConfig = await (0, import_internals.getPrismaConfigFromPackageJson)(cwd);
  if (prismaConfig && prismaConfig.data?.seed) {
    return void 0;
  }
  const packageManager = (0, import_has_yarn.default)() ? "yarn add -D" : "npm i -D";
  let message = `${(0, import_chunk_6TE2RIPN.red)(
    'To configure seeding in your project you need to add a "prisma.seed" property in your package.json with the command to execute it:'
  )}

1. Open the package.json of your project
`;
  if (detected.numberOfSeedFiles) {
    await legacyTsNodeScriptWarning();
    message += `2. Add the following example to it:`;
    if (detected.js) {
      message += `
\`\`\`
"prisma": {
  "seed": "node ${detected.js}"
}
\`\`\`
`;
    } else if (detected.ts) {
      message += `
\`\`\`
"prisma": {
  "seed": "ts-node ${detected.ts}"
}
\`\`\`
If you are using ESM (ECMAScript modules):
\`\`\`
"prisma": {
  "seed": "node --loader ts-node/esm ${detected.ts}"
}
\`\`\`

3. Install the required dependencies by running:
${(0, import_chunk_6TE2RIPN.green)(`${packageManager} ts-node typescript @types/node`)}
`;
    } else if (detected.sh) {
      message += `
\`\`\`
"prisma": {
  "seed": "${detected.sh}"
}
\`\`\`
And run \`chmod +x ${detected.sh}\` to make it executable.`;
    }
  } else {
    message += `2. Add one of the following examples to your package.json:

${(0, import_chunk_6TE2RIPN.bold)("TypeScript:")}
\`\`\`
"prisma": {
  "seed": "ts-node ./prisma/seed.ts"
}
\`\`\`
If you are using ESM (ECMAScript modules):
\`\`\`
"prisma": {
  "seed": "node --loader ts-node/esm ./prisma/seed.ts"
}
\`\`\`

And install the required dependencies by running:
${packageManager} ts-node typescript @types/node

${(0, import_chunk_6TE2RIPN.bold)("JavaScript:")}
\`\`\`
"prisma": {
  "seed": "node ./prisma/seed.js"
}
\`\`\`

${(0, import_chunk_6TE2RIPN.bold)("Bash:")}
\`\`\`
"prisma": {
  "seed": "./prisma/seed.sh"
}
\`\`\`
And run \`chmod +x prisma/seed.sh\` to make it executable.`;
  }
  message += `
More information in our documentation:
${(0, import_internals.link)("https://pris.ly/d/seeding")}`;
  return message;
}
async function getSeedCommandFromPackageJson(cwd) {
  const prismaConfig = await (0, import_internals.getPrismaConfigFromPackageJson)(cwd);
  debug({ prismaConfig });
  if (!prismaConfig || !prismaConfig.data?.seed) {
    return null;
  }
  const seedCommandFromPkgJson = prismaConfig.data.seed;
  if (typeof seedCommandFromPkgJson !== "string") {
    throw new Error(
      `Provided seed command \`${seedCommandFromPkgJson}\` from \`${import_path.default.relative(
        cwd,
        prismaConfig.packagePath
      )}\` must be of type string`
    );
  }
  if (!seedCommandFromPkgJson) {
    throw new Error(
      `Provided seed command \`${seedCommandFromPkgJson}\` from \`${import_path.default.relative(
        cwd,
        prismaConfig.packagePath
      )}\` cannot be empty`
    );
  }
  return seedCommandFromPkgJson;
}
async function executeSeedCommand({
  commandFromConfig,
  extraArgs
}) {
  const command = extraArgs ? `${commandFromConfig} ${extraArgs}` : commandFromConfig;
  process.stdout.write(`Running seed command \`${(0, import_chunk_6TE2RIPN.italic)(command)}\` ...
`);
  try {
    await import_execa.default.command(command, {
      stdout: "inherit",
      stderr: "inherit"
    });
  } catch (_e) {
    const e = _e;
    debug({ e });
    console.error((0, import_chunk_6TE2RIPN.bold)((0, import_chunk_6TE2RIPN.red)(`
An error occurred while running the seed command:`)));
    console.error((0, import_chunk_6TE2RIPN.red)(e.stderr || String(e)));
    return false;
  }
  return true;
}
function detectSeedFiles(cwd, schemaPath) {
  let parentDirectory = import_path.default.relative(cwd, import_path.default.join(cwd, "prisma"));
  if (schemaPath) {
    parentDirectory = import_path.default.relative(cwd, import_path.default.dirname(schemaPath));
  }
  const seedPath = import_path.default.join(parentDirectory, "seed.");
  const detected = {
    seedPath,
    numberOfSeedFiles: 0,
    js: "",
    ts: "",
    sh: ""
  };
  const extensions = ["js", "ts", "sh"];
  for (const extension of extensions) {
    const fullPath = seedPath + extension;
    if (!import_fs.default.existsSync(fullPath)) {
      continue;
    }
    detected[extension] = fullPath;
    detected.numberOfSeedFiles++;
  }
  debug({ detected });
  return detected;
}
async function legacyTsNodeScriptWarning() {
  const scripts = await getScriptsFromPackageJson();
  if (scripts?.["ts-node"]) {
    import_internals.logger.warn(
      (0, import_chunk_6TE2RIPN.yellow)(`The "ts-node" script in the package.json is not used anymore since version 3.0 and can now be removed.`)
    );
  }
  return void 0;
}
async function getScriptsFromPackageJson(cwd = process.cwd()) {
  try {
    const pkgJsonPath = await (0, import_pkg_up.default)({ cwd });
    if (!pkgJsonPath) {
      return null;
    }
    const pkgJsonString = await import_fs.default.promises.readFile(pkgJsonPath, "utf-8");
    const pkgJson = JSON.parse(pkgJsonString);
    const { "ts-node": tsnode } = pkgJson.scripts;
    return { "ts-node": tsnode };
  } catch {
    return null;
  }
}
var import_execa, import_has_yarn, import_pkg_up, debug;
var init_seed = (0, import_chunk_WWAWV7DQ.__esm)({
  "src/utils/seed.ts"() {
    import_execa = (0, import_chunk_WWAWV7DQ.__toESM)((0, import_chunk_WIZM7TFT.require_execa)());
    import_has_yarn = (0, import_chunk_WWAWV7DQ.__toESM)(require_has_yarn());
    (0, import_chunk_6TE2RIPN.init_colors)();
    import_pkg_up = (0, import_chunk_WWAWV7DQ.__toESM)(require_pkg_up());
    debug = (0, import_debug.default)("prisma:migrate:seed");
  }
});
