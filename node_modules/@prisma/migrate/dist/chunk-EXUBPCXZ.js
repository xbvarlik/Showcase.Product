"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_EXUBPCXZ_exports = {};
__export(chunk_EXUBPCXZ_exports, {
  DbPull: () => DbPull,
  init_DbPull: () => init_DbPull
});
module.exports = __toCommonJS(chunk_EXUBPCXZ_exports);
var import_chunk_GRGGAY6L = require("./chunk-GRGGAY6L.js");
var import_chunk_BAFPAACN = require("./chunk-BAFPAACN.js");
var import_chunk_35LAJN5S = require("./chunk-35LAJN5S.js");
var import_chunk_7IT2ZO3D = require("./chunk-7IT2ZO3D.js");
var import_chunk_W3ROQKBN = require("./chunk-W3ROQKBN.js");
var import_chunk_QBK5XTJE = require("./chunk-QBK5XTJE.js");
var import_chunk_INC2OACE = require("./chunk-INC2OACE.js");
var import_chunk_GN5BY5N2 = require("./chunk-GN5BY5N2.js");
var import_chunk_XLLUFIQK = require("./chunk-XLLUFIQK.js");
var import_chunk_LVFPGUOH = require("./chunk-LVFPGUOH.js");
var import_chunk_U374EXYQ = require("./chunk-U374EXYQ.js");
var import_chunk_Q7ACZDDT = require("./chunk-Q7ACZDDT.js");
var import_chunk_KEBB7UIB = require("./chunk-KEBB7UIB.js");
var import_chunk_6TE2RIPN = require("./chunk-6TE2RIPN.js");
var import_chunk_WWAWV7DQ = require("./chunk-WWAWV7DQ.js");
var import_debug = __toESM(require("@prisma/debug"));
var import_internals = require("@prisma/internals");
var import_path = __toESM(require("path"));
var debug, _DbPull, DbPull;
var init_DbPull = (0, import_chunk_WWAWV7DQ.__esm)({
  "src/commands/DbPull.ts"() {
    (0, import_chunk_6TE2RIPN.init_colors)();
    (0, import_chunk_LVFPGUOH.init_dist)();
    (0, import_chunk_XLLUFIQK.init_SchemaEngine)();
    (0, import_chunk_GN5BY5N2.init_countModelsAndTypes)();
    (0, import_chunk_KEBB7UIB.init_ensureDatabaseExists)();
    (0, import_chunk_U374EXYQ.init_errors)();
    (0, import_chunk_INC2OACE.init_isSchemaEmpty)();
    (0, import_chunk_Q7ACZDDT.init_printDatasource)();
    (0, import_chunk_35LAJN5S.init_printDatasources)();
    (0, import_chunk_7IT2ZO3D.init_printIntrospectedSchema)();
    (0, import_chunk_W3ROQKBN.init_removeSchemaFiles)();
    (0, import_chunk_QBK5XTJE.init_replaceOrAddDatasource)();
    (0, import_chunk_BAFPAACN.init_saveSchemaFiles)();
    (0, import_chunk_GRGGAY6L.init_spinner)();
    debug = (0, import_debug.default)("prisma:db:pull");
    _DbPull = class _DbPull2 {
      static new() {
        return new _DbPull2();
      }
      urlToDatasource(url, defaultProvider) {
        const provider = defaultProvider || (0, import_internals.protocolToConnectorType)(`${url.split(":")[0]}:`);
        return (0, import_chunk_35LAJN5S.printDatasources)([
          {
            config: {},
            provider,
            name: "db",
            url
          }
        ]);
      }
      async parse(argv) {
        const args = (0, import_internals.arg)(argv, {
          "--help": Boolean,
          "-h": "--help",
          "--url": String,
          "--print": Boolean,
          "--schema": String,
          "--schemas": String,
          "--force": Boolean,
          "--composite-type-depth": Number,
          // optional, only on mongodb
          "--local-d1": Boolean
          // optional, only on cloudflare D1
        });
        const spinnerFactory = (0, import_chunk_GRGGAY6L.createSpinner)(!args["--print"]);
        if (args instanceof Error) {
          return this.help(args.message);
        }
        await (0, import_internals.checkUnsupportedDataProxy)("db pull", args, !args["--url"]);
        if (args["--help"]) {
          return this.help();
        }
        const url = args["--url"];
        const schemaPathResult = await (0, import_internals.getSchemaWithPathOptional)(args["--schema"]);
        let schemaPath = schemaPathResult?.schemaPath ?? null;
        const rootDir = schemaPathResult?.schemaRootDir ?? process.cwd();
        debug("schemaPathResult", schemaPathResult);
        if (schemaPath && !args["--print"]) {
          process.stdout.write((0, import_chunk_6TE2RIPN.dim)(`Prisma schema loaded from ${import_path.default.relative(process.cwd(), schemaPath)}`) + "\n");
          await (0, import_internals.loadEnvFile)({ schemaPath: args["--schema"], printMessage: true });
          (0, import_chunk_Q7ACZDDT.printDatasource)({ datasourceInfo: await (0, import_chunk_KEBB7UIB.getDatasourceInfo)({ schemaPath }) });
        } else {
          await (0, import_internals.loadEnvFile)({ schemaPath: args["--schema"], printMessage: false });
        }
        const fromD1 = Boolean(args["--local-d1"]);
        if (!url && !schemaPath && !fromD1) {
          throw new import_chunk_U374EXYQ.NoSchemaFoundError();
        }
        const { firstDatasource, schema, validationWarning } = await (0, import_chunk_LVFPGUOH.$)({ url, schemaPath, fromD1 }).when(
          (input) => input.schemaPath !== null,
          async (input) => {
            const rawSchema = await (0, import_internals.getSchema)(input.schemaPath);
            const config = await (0, import_internals.getConfig)({
              datamodel: rawSchema,
              ignoreEnvVarErrors: true
            });
            const previewFeatures = config.generators.find(({ name }) => name === "client")?.previewFeatures;
            const firstDatasource2 = config.datasources[0] ? config.datasources[0] : void 0;
            if (input.url) {
              let providerFromSchema = firstDatasource2?.provider;
              if (providerFromSchema === "postgres") {
                providerFromSchema = "postgresql";
              }
              const providerFromUrl = (0, import_internals.protocolToConnectorType)(`${input.url.split(":")[0]}:`);
              const schema2 = (0, import_chunk_QBK5XTJE.replaceOrAddDatasource)(this.urlToDatasource(input.url, providerFromSchema), rawSchema);
              if (providerFromSchema && providerFromUrl && providerFromSchema !== providerFromUrl && Boolean(providerFromSchema === "cockroachdb" && providerFromUrl === "postgresql") === false) {
                throw new Error(
                  `The database provider found in --url (${providerFromUrl}) is different from the provider found in the Prisma schema (${providerFromSchema}).`
                );
              }
              return { firstDatasource: firstDatasource2, schema: schema2, validationWarning: void 0 };
            } else if (input.fromD1) {
              const d1Database = await (0, import_internals.locateLocalCloudflareD1)({ arg: "--from-local-d1" });
              const pathToSQLiteFile = import_path.default.relative(import_path.default.dirname(input.schemaPath), d1Database);
              const schema2 = [
                ["schema.prisma", this.urlToDatasource(`file:${pathToSQLiteFile}`, "sqlite")]
              ];
              const config2 = await (0, import_internals.getConfig)({
                datamodel: schema2,
                ignoreEnvVarErrors: true
              });
              const result = { firstDatasource: config2.datasources[0], schema: schema2, validationWarning: void 0 };
              const hasDriverAdaptersPreviewFeature = (previewFeatures || []).includes("driverAdapters");
              const validationWarning2 = `Without the ${(0, import_chunk_6TE2RIPN.bold)(
                "driverAdapters"
              )} preview feature, the schema introspected via the ${(0, import_chunk_6TE2RIPN.bold)("--local-d1")} flag will not work with ${(0, import_chunk_6TE2RIPN.bold)(
                "@prisma/client"
              )}.`;
              if (hasDriverAdaptersPreviewFeature) {
                return result;
              } else {
                return { ...result, validationWarning: validationWarning2 };
              }
            } else {
              await (0, import_internals.getConfig)({
                datamodel: rawSchema,
                ignoreEnvVarErrors: false
              });
            }
            return { firstDatasource: firstDatasource2, schema: rawSchema, validationWarning: void 0 };
          }
        ).when(
          (input) => input.fromD1 === true,
          async (_) => {
            const d1Database = await (0, import_internals.locateLocalCloudflareD1)({ arg: "--from-local-d1" });
            const pathToSQLiteFile = import_path.default.relative(process.cwd(), d1Database);
            const schemaContent = `generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}
${this.urlToDatasource(`file:${pathToSQLiteFile}`, "sqlite")}`;
            const schema2 = [["schema.prisma", schemaContent]];
            const config = await (0, import_internals.getConfig)({
              datamodel: schema2,
              ignoreEnvVarErrors: true
            });
            return { firstDatasource: config.datasources[0], schema: schema2, validationWarning: void 0 };
          }
        ).when(
          (input) => input.url !== void 0,
          async (input) => {
            (0, import_internals.protocolToConnectorType)(`${input.url.split(":")[0]}:`);
            const schema2 = [["schema.prisma", this.urlToDatasource(input.url)]];
            const config = await (0, import_internals.getConfig)({
              datamodel: schema2,
              ignoreEnvVarErrors: true
            });
            return { firstDatasource: config.datasources[0], schema: schema2, validationWarning: void 0 };
          }
        ).run();
        if (schemaPath) {
          const schemas = await (0, import_internals.getSchema)(args["--schema"]);
          const modelRegex = /\s*model\s*(\w+)\s*{/;
          const isReintrospection = schemas.some(([_, schema2]) => !!modelRegex.exec(schema2));
          if (isReintrospection && !args["--force"] && firstDatasource?.provider === "mongodb") {
            throw new Error(`Iterating on one schema using re-introspection with db pull is currently not supported with MongoDB provider.
You can explicitly ignore and override your current local schema file with ${(0, import_chunk_6TE2RIPN.green)(
              (0, import_internals.getCommandWithExecutor)("prisma db pull --force")
            )}
Some information will be lost (relations, comments, mapped fields, @ignore...), follow ${(0, import_internals.link)(
              "https://github.com/prisma/prisma/issues/9585"
            )} for more info.`);
          }
        }
        const engine = new import_chunk_XLLUFIQK.SchemaEngine({
          schemaPath: schemaPath ?? void 0
        });
        const basedOn = !args["--url"] && schemaPath ? ` based on datasource defined in ${(0, import_chunk_6TE2RIPN.underline)(import_path.default.relative(process.cwd(), schemaPath))}` : "";
        const introspectionSpinner = spinnerFactory(`Introspecting${basedOn}`);
        const before = Math.round(performance.now());
        let introspectionSchema = void 0;
        let introspectionWarnings;
        try {
          const introspectionResult = await engine.introspect({
            schema: (0, import_internals.toSchemasContainer)(schema),
            baseDirectoryPath: rootDir,
            force: args["--force"],
            compositeTypeDepth: args["--composite-type-depth"],
            namespaces: args["--schemas"]?.split(",")
          });
          introspectionSchema = introspectionResult.schema;
          introspectionWarnings = introspectionResult.warnings;
          debug(`Introspection warnings`, introspectionWarnings);
        } catch (e) {
          introspectionSpinner.failure();
          if (e.code === "P4001" && (0, import_chunk_INC2OACE.isSchemaEmpty)(introspectionSchema)) {
            throw new Error(`
${(0, import_chunk_6TE2RIPN.red)((0, import_chunk_6TE2RIPN.bold)(`${e.code} `))}${(0, import_chunk_6TE2RIPN.red)("The introspected database was empty:")}

${(0, import_chunk_6TE2RIPN.bold)("prisma db pull")} could not create any models in your ${(0, import_chunk_6TE2RIPN.bold)(
              "schema.prisma"
            )} file and you will not be able to generate Prisma Client with the ${(0, import_chunk_6TE2RIPN.bold)(
              (0, import_internals.getCommandWithExecutor)("prisma generate")
            )} command.

${(0, import_chunk_6TE2RIPN.bold)("To fix this, you have two options:")}

- manually create a table in your database.
- make sure the database connection URL inside the ${(0, import_chunk_6TE2RIPN.bold)("datasource")} block in ${(0, import_chunk_6TE2RIPN.bold)(
              "schema.prisma"
            )} points to a database that is not empty (it must contain at least one table).

Then you can run ${(0, import_chunk_6TE2RIPN.green)((0, import_internals.getCommandWithExecutor)("prisma db pull"))} again. 
`);
          } else if (e.code === "P1003") {
            throw new Error(`
${(0, import_chunk_6TE2RIPN.red)((0, import_chunk_6TE2RIPN.bold)(`${e.code} `))}${(0, import_chunk_6TE2RIPN.red)("The introspected database does not exist:")}

${(0, import_chunk_6TE2RIPN.bold)("prisma db pull")} could not create any models in your ${(0, import_chunk_6TE2RIPN.bold)(
              "schema.prisma"
            )} file and you will not be able to generate Prisma Client with the ${(0, import_chunk_6TE2RIPN.bold)(
              (0, import_internals.getCommandWithExecutor)("prisma generate")
            )} command.

${(0, import_chunk_6TE2RIPN.bold)("To fix this, you have two options:")}

- manually create a database.
- make sure the database connection URL inside the ${(0, import_chunk_6TE2RIPN.bold)("datasource")} block in ${(0, import_chunk_6TE2RIPN.bold)(
              "schema.prisma"
            )} points to an existing database.

Then you can run ${(0, import_chunk_6TE2RIPN.green)((0, import_internals.getCommandWithExecutor)("prisma db pull"))} again. 
`);
          } else if (e.code === "P1012") {
            process.stdout.write("\n");
            const message = (0, import_internals.relativizePathInPSLError)(e.message);
            throw new Error(`${(0, import_chunk_6TE2RIPN.red)(message)}
Introspection failed as your current Prisma schema file is invalid

Please fix your current schema manually (using either ${(0, import_chunk_6TE2RIPN.green)(
              (0, import_internals.getCommandWithExecutor)("prisma validate")
            )} or the Prisma VS Code extension to understand what's broken and confirm you fixed it), and then run this command again.
Or run this command with the ${(0, import_chunk_6TE2RIPN.green)(
              "--force"
            )} flag to ignore your current schema and overwrite it. All local modifications will be lost.
`);
          }
          process.stdout.write("\n");
          throw e;
        }
        const introspectionWarningsMessage = this.getWarningMessage(introspectionWarnings);
        if (args["--print"]) {
          (0, import_chunk_7IT2ZO3D.printIntrospectedSchema)(introspectionSchema, process.stdout);
          if (introspectionWarningsMessage.trim().length > 0) {
            console.error(introspectionWarningsMessage.replace(/(\n)/gm, "\n// "));
          }
        } else {
          schemaPath = schemaPath || "schema.prisma";
          if (args["--force"]) {
            await (0, import_chunk_W3ROQKBN.removeSchemaFiles)(schema);
          }
          await (0, import_chunk_BAFPAACN.saveSchemaFiles)(introspectionSchema);
          const { modelsCount, typesCount } = (0, import_chunk_GN5BY5N2.countModelsAndTypes)(introspectionSchema);
          const modelsCountMessage = `${modelsCount} ${modelsCount > 1 ? "models" : "model"}`;
          const typesCountMessage = `${typesCount} ${typesCount > 1 ? "embedded documents" : "embedded document"}`;
          let modelsAndTypesMessage;
          if (typesCount > 0) {
            modelsAndTypesMessage = `${modelsCountMessage} and ${typesCountMessage}`;
          } else {
            modelsAndTypesMessage = `${modelsCountMessage}`;
          }
          const modelsAndTypesCountMessage = modelsCount + typesCount > 1 ? `${modelsAndTypesMessage} and wrote them` : `${modelsAndTypesMessage} and wrote it`;
          const renderValidationWarning = validationWarning ? `
${(0, import_chunk_6TE2RIPN.yellow)(validationWarning)}` : "";
          introspectionSpinner.success(`Introspected ${modelsAndTypesCountMessage} into ${(0, import_chunk_6TE2RIPN.underline)(
            import_path.default.relative(process.cwd(), schemaPath)
          )} in ${(0, import_chunk_6TE2RIPN.bold)((0, import_internals.formatms)(Math.round(performance.now()) - before))}
      ${(0, import_chunk_6TE2RIPN.yellow)(introspectionWarningsMessage)}
${`Run ${(0, import_chunk_6TE2RIPN.green)((0, import_internals.getCommandWithExecutor)("prisma generate"))} to generate Prisma Client.`}${renderValidationWarning}`);
        }
        return "";
      }
      getWarningMessage(warnings) {
        if (warnings) {
          return `
${warnings}`;
        }
        return "";
      }
      help(error) {
        if (error) {
          return new import_internals.HelpError(`
${(0, import_chunk_6TE2RIPN.bold)((0, import_chunk_6TE2RIPN.red)(`!`))} ${error}
${_DbPull2.help}`);
        }
        return _DbPull2.help;
      }
    };
    _DbPull.help = (0, import_internals.format)(`
Pull the state from the database to the Prisma schema using introspection

${(0, import_chunk_6TE2RIPN.bold)("Usage")}

  ${(0, import_chunk_6TE2RIPN.dim)("$")} prisma db pull [flags/options]

${(0, import_chunk_6TE2RIPN.bold)("Flags")}

              -h, --help   Display this help message
                 --force   Ignore current Prisma schema file
                 --print   Print the introspected Prisma schema to stdout

${(0, import_chunk_6TE2RIPN.bold)("Options")}

                --schema   Custom path to your Prisma schema
  --composite-type-depth   Specify the depth for introspecting composite types (e.g. Embedded Documents in MongoDB)
                           Number, default is -1 for infinite depth, 0 = off
               --schemas   Specify the database schemas to introspect. This overrides the schemas defined in the datasource block of your Prisma schema.
              --local-d1   Generate a Prisma schema from a local Cloudflare D1 database
${(0, import_chunk_6TE2RIPN.bold)("Examples")}

With an existing Prisma schema
  ${(0, import_chunk_6TE2RIPN.dim)("$")} prisma db pull

Or specify a Prisma schema path
  ${(0, import_chunk_6TE2RIPN.dim)("$")} prisma db pull --schema=./schema.prisma

Instead of saving the result to the filesystem, you can also print it to stdout
  ${(0, import_chunk_6TE2RIPN.dim)("$")} prisma db pull --print

Overwrite the current schema with the introspected schema instead of enriching it
  ${(0, import_chunk_6TE2RIPN.dim)("$")} prisma db pull --force

Set composite types introspection depth to 2 levels
  ${(0, import_chunk_6TE2RIPN.dim)("$")} prisma db pull --composite-type-depth=2

`);
    DbPull = _DbPull;
  }
});
