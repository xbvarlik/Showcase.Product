"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_YOW3VBYS_exports = {};
__export(chunk_YOW3VBYS_exports, {
  introspectSql: () => introspectSql
});
module.exports = __toCommonJS(chunk_YOW3VBYS_exports);
var import_chunk_XLLUFIQK = require("./chunk-XLLUFIQK.js");
var import_internals = require("@prisma/internals");
(0, import_chunk_XLLUFIQK.init_SchemaEngine)();
var supportedProviders = ["postgresql", "cockroachdb", "mysql", "sqlite"];
async function introspectSql(schemaPath, queries) {
  const schema = await (0, import_internals.getSchemaWithPath)(schemaPath);
  const config = await (0, import_internals.getConfig)({ datamodel: schema.schemas });
  if (!supportedProviders.includes(config.datasources?.[0]?.activeProvider)) {
    throw new Error(`Typed SQL is supported only for ${supportedProviders.join(", ")} providers`);
  }
  if (!isTypedSqlEnabled(config)) {
    throw new Error(`\`typedSql\` preview feature needs to be enabled in ${schema.schemaPath}`);
  }
  const firstDatasource = config.datasources[0];
  if (!firstDatasource) {
    throw new Error(`Could not find datasource in schema ${schema.schemaPath}`);
  }
  const url = (0, import_internals.getEffectiveUrl)(firstDatasource).value;
  if (!url) {
    throw new Error(`Could not get url from datasource ${firstDatasource.name} in ${schema.schemaPath}`);
  }
  const schemaEngine = new import_chunk_XLLUFIQK.SchemaEngine({ schemaPath: schema.schemaPath });
  const results = [];
  const errors = [];
  try {
    for (const query of queries) {
      const queryResult = await introspectSingleQuery(schemaEngine, url, query);
      if (queryResult.ok) {
        results.push(queryResult.result);
      } else {
        errors.push(queryResult.error);
      }
    }
  } finally {
    schemaEngine.stop();
  }
  if (errors.length > 0) {
    return { ok: false, errors };
  }
  return { ok: true, queries: results };
}
async function introspectSingleQuery(schemaEngine, url, query) {
  try {
    const result = await schemaEngine.introspectSql({
      url,
      queries: [query]
    });
    const queryResult = result.queries[0];
    if (!queryResult) {
      return {
        ok: false,
        error: {
          fileName: query.fileName,
          message: "Invalid response from schema engine"
        }
      };
    }
    return {
      ok: true,
      result: queryResult
    };
  } catch (error) {
    return {
      ok: false,
      error: {
        fileName: query.fileName,
        message: String(error)
      }
    };
  }
}
function isTypedSqlEnabled(config) {
  return config.generators.some((gen) => gen?.previewFeatures?.includes("typedSql"));
}
